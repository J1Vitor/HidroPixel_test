# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Hidropixel
 Add the description
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Joao Vitor & Adriano Rolim
        email                : jvds@academico.ufpb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import Qt
from qgis.PyQt import uic
from qgis.PyQt.QtCore import Qt, QSettings, QTranslator, QCoreApplication, QUrl
from qgis.PyQt.QtGui import QIcon, QIntValidator, QDoubleValidator, QFont, QPixmap, QDesktopServices
from qgis.PyQt.QtWidgets import QApplication, QAction, QFileDialog, QMessageBox, QTableWidgetItem
from qgis.core import QgsMapLayerProxyModel, Qgis, QgsProject, QgsMapLayer, QgsRasterLayer, QgsVectorLayer
import qgis.utils

# Import the code for the dialog
import os.path
import shutil
import os
import glob
from .hidropixel_dialog import HidropixelDialog
from pathlib import Path
from datetime import datetime
# A importacao dos modulos contendo as variaveis
from hidropixel.modulos_files.RDC_variables import RDCVariables
from hidropixel.modulos_files.global_variables import GlobalVariables

# importa validacoes
from .validations.validators import RasterValidator
from .validations.validation_gate import ensure_validations_pass

# importing animation module
# from .animation.create_rainfall_animation import create_precip_video

# Initialize Qt resources from file resources.py
from .resources import *

# Importing libs
import numpy as np
import subprocess
import sys
import io

from osgeo import ogr, gdal, gdalconst
from functools import wraps

# Ensure sys.stderr is file-like: some hosts or wrappers can set it to None
# which causes libraries (numpy, etc.) to fail when calling sys.stderr.write
if getattr(sys, 'stderr', None) is None:
    try:
        sys.stderr = io.StringIO()
    except Exception:
        # As a last resort, create a minimal object with write method
        class _StderrFallback:
            def write(self, *args, **kwargs):
                pass

        sys.stderr = _StderrFallback()

import matplotlib.pyplot as plt
# import cv2


class Hidropixel:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Hidropixel_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Hidropixel')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Criando instancias das classes: apenas para inicalizar as variaveis que nao sao arrays. Estes dependem da dimensao do raster enviado
        self.global_vars = GlobalVariables(0, 0)
        self.rdc_vars = RDCVariables(0, 0)

        # Seleciona o diretorio atual do plugin
        file_path = os.path.dirname(__file__)

        # Inicia a interface grafica da rotina flow travel time
        ui_file = os.path.join(file_path, 'hidropixel_dialog_flow_tt.ui')

        # Inicia a interface grafica da rotina excess rainfall
        ui_file1 = os.path.join(
            file_path, 'hidropixel_dialog_exec_rainfall.ui')

        # Inicia a interface grafica da rotina flow routing
        ui_file2 = os.path.join(file_path, 'hidropixel_dialog_flow_rout.ui')

        # Inicia a interface grafica da pagina run da funcao rainfall interpolation
        ui_file3 = os.path.join(
            file_path, 'hidropixel_dialog_run_rainfall_interpol.ui')

        # Inicia a interface grafica da pagina run da funcao rainfall interpolation
        ui_file4 = os.path.join(
            file_path, 'hidropixel_dialog_about.ui')

        # Inicia interface para salvar o projeto
        ui_file5 = os.path.join(
            file_path, 'hidropixel_dialog_save_project_flow_tt.ui')

        # Inicia interface para salvar o projeto
        ui_file6 = os.path.join(
            file_path, 'hidropixel_dialog_save_project_flow_tt.ui')

        # Inicia interface para salvar o projeto
        ui_file7 = os.path.join(
            file_path, 'hidropixel_dialog_save_project_flow_tt.ui')

        # inicia instanica das diferentes routinas do plugin Hidropixel
        self.dlg_flow_tt = uic.loadUi(ui_file)
        self.dlg_exc_rain = uic.loadUi(ui_file1)
        self.dlg_flow_rout = uic.loadUi(ui_file2)
        self.dlg_rain_interpl_run = uic.loadUi(ui_file3)
        self.dlg_about = uic.loadUi(ui_file4)
        self.dlg_save_project_flow_tt = uic.loadUi(ui_file5)
        self.dlg_save_project_exc_rain = uic.loadUi(ui_file6)
        self.dlg_save_project_flow_rout = uic.loadUi(ui_file7)

        # Cria outras variaveis necessarias
        self.save_result = None
        self.fn_n_conect_dren = None
        self.fn_num_pix_dren = None
        self.fn_comp_acum = None
        self.fn_comp_foz = None
        self.fn_decli_pix = None
        self.fn_decli_pix_jus = None
        self.fn_temp_total = None
        self.fn_travel_time_map = None
        self.fn_hidrograma = None
        self.flag = None
        self.flag_1 = None
        self.alfa, self.delta_t, self.criterio_parada, self.beta = 0, 0, 0, 0
        self.numero_total_pix = 0
        self.num_intervalos = 0
        self.volume_total = 0.0
        self.quantidade_blocos_chuva = 0
        self.chuva_excedente_calc = 0
        self.blocos_vazao = 0
        self.Pexc = 0
        self.diretorio_atual = os.path.dirname(os.path.abspath(__file__))
        self.file_name_tb1: str = ''
        self.file_name_tb2: str = ''
        self.x_min = 0
        self.x_max = 0
        self.y_min = 0
        self.y_max = 0
        self.dx = 0
        self.dy = 0
        self.output1_flow_tt = ''
        self.output2_flow_tt = ''
        self.output3_flow_tt = ''
        self.output4_flow_tt = ''
        self.output5_flow_tt = ''
        self.output6_flow_tt = ''
        self.map_cond = 0
        self.output1_ri = ''
        self.output1_exec_rain = ''
        self.output2_exec_rain = ''
        self.output3_exec_rain = ''
        self.output4_exec_rain = ''
        self.output5_exec_rain = ''
        self.output6_exec_rain = ''
        self.output1_flow_rout = ''
        self.output2_flow_rout = ''
        self.output3_flow_rout = ''
        self.output4_flow_rout = ''
        self.output5_flow_rout = ''
        self.highlighted_style = "background-color: rgb(173, 216, 230)"
        self.validations = {}
        self.all_validated = None

        self.validator = RasterValidator(
            self,
            self.dlg_flow_tt,
            self.dlg_exc_rain,
            self.dlg_flow_rout
        )

        self._connect_buttons()

        # Cria pasta para salvar os arquivos temporários
        os.makedirs(os.path.join(self.diretorio_atual,
                    'temp/maps'), exist_ok=True)
        os.makedirs(os.path.join(self.diretorio_atual,
                    'temp/hydrographs'), exist_ok=True)
        os.makedirs(os.path.join(self.diretorio_atual,
                    'temp/tv_for_each_poi'), exist_ok=True)

    def _connect_buttons(self):
        # Conexoes da aba Flow Travel Time
        self.dlg_flow_tt.btn_6_pg3.clicked.connect(
            lambda: self.validator.validar_raster_bacia(
                self.dlg_flow_tt.cb_1_pg2.currentText(), modulo=1)
        )
        self.dlg_flow_tt.btn_7_pg3.clicked.connect(
            self.validator.validar_raster_mde)

        # self.dlg_flow_tt.btn_8_pg3.clicked.connect(self.validator.preencher_direcoes_padrao)
        self.dlg_flow_tt.btn_8_pg3.clicked.connect(
            self.validator.validar_direcoes_fluxo)

        self.dlg_flow_tt.btn_10_pg3.clicked.connect(
            lambda: self.validator.verificar_dimensoes_rasters([
                self.dlg_flow_tt.cb_1_pg2.currentText(),
                self.dlg_flow_tt.cb_2_pg2.currentText(),
                self.dlg_flow_tt.cb_3_pg2.currentText(),
                self.dlg_flow_tt.cb_7_pg2.currentText()
            ], modulo=1)
        )
        self.dlg_flow_tt.btn9_pg3.clicked.connect(
            lambda: self.validator.executar_validacao_fluxo())
        self.dlg_flow_tt.btn11_pg3.clicked.connect(
            self.validator.validar_uso_cobertura)
        self.dlg_flow_tt.btn12_pg3.clicked.connect(
            self.validator.validar_tabela_manning_lulc)
        self.dlg_flow_tt.btn13_pg3.clicked.connect(
            self.validator.validar_raster_rdn_classes)
        self.dlg_flow_tt.btn14_pg3.clicked.connect(
            self.validator.verificar_conectividade_rede)
        self.dlg_flow_tt.btn15_pg3.clicked.connect(
            self.validator.verificar_acumulado_drenagem)

        # Conexoes da aba Excess Rain
        self.dlg_exc_rain.btn1_pg_4.clicked.connect(
            lambda: self.validator.verificar_dimensoes_rasters([
                self.dlg_exc_rain.cb_1_pg2.currentText(),
                self.dlg_exc_rain.cb_2_pg2.currentText()
            ], modulo=2)
        )
        self.dlg_exc_rain.btn2_pg_4.clicked.connect(
            lambda: self.validator.validar_raster_bacia(
                self.dlg_exc_rain.cb_1_pg2.currentText(), modulo=2)
        )
        self.dlg_exc_rain.btn3_pg_4.clicked.connect(
            self.validator.validar_raster_cn)

        # Conexoes da aba Flow Routing
        self.dlg_flow_rout.btn_1_pg3.clicked.connect(
            lambda: self.validator.verificar_dimensoes_rasters([
                self.dlg_flow_rout.cb_1_pg2.currentText(),
                self.dlg_flow_rout.cb_3_pg2.currentText(),
                self.dlg_flow_rout.cb_5_pg2.currentText()
            ], modulo=3)
        )
        self.dlg_flow_rout.btn_2_pg3.clicked.connect(
            lambda: self.validator.validar_raster_bacia(
                self.dlg_flow_rout.cb_1_pg2.currentText(), modulo=3)
        )
        self.dlg_flow_rout.btn_3_pg3.clicked.connect(
            self.validator.verificar_tempos_de_viagem)
        self.dlg_flow_rout.btn_4_pg3.clicked.connect(
            self.validator.verificar_chuva_excedente_total)
        self.dlg_flow_rout.btn_5_pg3.clicked.connect(
            self.validator.validar_hietograma_bin)
        self.dlg_flow_rout.btn_6_pg3.clicked.connect(
            self.validator.validar_regioes_interesse_raster)

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Hidropixel', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        # Armazena diretorio do plugin
        icon_path = self.diretorio_atual + '\icons\icon3.png'

        self.add_action(
            icon_path,
            text=self.tr(u'Q-Hidropixel'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Hidropixel'),
                action)
            self.iface.removeToolBarIcon(action)

    def shutdown(self, reason: str = None):
        """Gracefully stop the plugin without quitting the QGIS application.

        This will close any open plugin dialogs, attempt to stop background
        work (if any), and remove UI actions from QGIS. It does not call
        QCoreApplication.quit() so QGIS remains running.
        """
        # Close plugin main dialog and child dialogs if they exist
        for dlg_name in (
            'dlg_hidropixel', 'dlg_flow_tt', 'dlg_exc_rain', 'dlg_flow_rout',
            'dlg_rain_interpl_run', 'dlg_about', 'dlg_save_project_flow_tt',
            'dlg_save_project_exc_rain', 'dlg_save_project_flow_rout'
        ):
            try:
                dlg = getattr(self, dlg_name, None)
                if dlg is not None:
                    # Use close() to allow any closeEvent handlers to run
                    dlg.close()
            except Exception:
                # ignore failures during shutdown
                pass

        # If you have background threads or subprocesses, signal them to stop here.
        # Example:
        # if hasattr(self, 'worker_thread'):
        #     self.worker_thread.requestInterruption()
        #     self.worker_thread.quit()
        #     self.worker_thread.wait()

        # Remove UI actions and toolbar icons
        try:
            self.unload()
        except Exception:
            pass

        # Clear references to UI objects to help GC
        for name in list(self.__dict__.keys()):
            if name.startswith('dlg_') or name.startswith('output'):
                try:
                    delattr(self, name)
                except Exception:
                    pass

        # Notify the user (non-blocking)
        try:
            QMessageBox.information(None, 'Plugin stopped',
                                    'Q-Hidropixel has been stopped.' + (f"\nReason: {reason}" if reason else ''))
        except Exception:
            # if no GUI available, ignore
            pass

    def carrega_work_folder(self, line_edit):
        '''Esta funcao define a pasta padrao tanto para buscar, quanto para salvar os arquivos'''
        # Define as variaveis e configuracoes da janela de escolha do arquivo
        pasta = None
        line_edit.setText('')
        options = QFileDialog.Options()
        pasta = QFileDialog.getExistingDirectory(
            None, caption='Select your working folder!', options=options)

        if pasta != '':
            # Se o usario enviar um arquivo, este sera armazenado na sua referida line edit
            line_edit.setText(pasta)

            # Define por padrao path == working folder
            self.dlg_save_project_flow_tt.le_2_pg1.setText(
                self.dlg_flow_tt.le_21_pg1.text())
            self.dlg_save_project_exc_rain.le_2_pg1.setText(
                self.dlg_exc_rain.le_3_pg1.text())
            self.dlg_save_project_flow_rout.le_2_pg1.setText(
                self.dlg_flow_rout.le_3_pg1.text())
        else:
            # Caso contrario, sera mostrada uma mensagem de aviso
            result = "Wait! You did not select any folder."
            QMessageBox.warning(None, "No folder selected", result)

        return pasta

    def carrega_POI_path(self, cond, line_edit):
        """Carrega a pasta com o os "tempos de viagem para cada POI"""
        # Define as variaveis e configuracoes da janela de escolha do arquivo
        pasta = None
        line_edit.setText('')
        options = QFileDialog.Options()
        if cond == 1:
            pasta = QFileDialog.getExistingDirectory(
                None, caption='Select the path with flow travel time (min) for each POI!', options=options)
        elif cond == 0:
            pasta = QFileDialog.getExistingDirectory(
                None, caption='Select the path to save flow travel time (min) for each POI!', options=options)
        else:
            pasta = QFileDialog.getExistingDirectory(
                None, caption='Select the path to save resulting hydrograph (m³/s) for each POI!', options=options)

        if pasta != '':
            # Se o usario enviar um arquivo, este sera armazenado na sua referida line edit
            line_edit.setText(pasta)
        else:
            # Caso contrario, sera mostrada uma mensagem de aviso
            result = "Wait! You did not select any folder."
            QMessageBox.warning(None, "No folder selected", result)

    def project_path(self):
        """Define por padrao path == working folder para a GUI do save to project"""
        # Define por padrao path == working folder
        self.dlg_save_project_flow_tt.le_2_pg1.setText(
            self.dlg_flow_tt.le_21_pg1.text())
        self.dlg_save_project_exc_rain.le_2_pg1.setText(
            self.dlg_exc_rain.le_3_pg1.text())
        self.dlg_save_project_flow_rout.le_2_pg1.setText(
            self.dlg_flow_rout.le_3_pg1.text())

    def carregaArquivos(self, line_edit, combobox, file_type="raster"):
        """Esta funcao e utilizada para adicionar os arquivos enviados pelo usuario ao plugin"""
        # Define as variaveis e configuracoes da janela de escolha do arquivo
        file_ = None
        options = QFileDialog.Options()
        directory = self.dlg_flow_tt.le_21_pg1.text()
        layer = None

        while True:  # Loop ate que o usuario selecione um arquivo ou cancele

            # Janela de dialogo com o Usuario
            if file_type == "raster":
                file_, _ = QFileDialog.getOpenFileName(
                    None, "Select a file!", directory, "GeoTIFF (*.tif)", options=options)
                if not file_:
                    QMessageBox.warning(
                        None, "No file selected", "Wait! You did not select any file.")
                    return None

                # Se o raster nao estiver no projeto, adiciona
                if file_ not in [layer.source() for layer in QgsProject.instance().mapLayers().values()]:
                    layer = QgsRasterLayer(
                        file_, os.path.basename(file_), "gdal")
                    QgsProject.instance().addMapLayer(layer)

                else:
                    for camada in QgsProject.instance().mapLayers().values():
                        if isinstance(camada, QgsRasterLayer) and camada.source() == file_:
                            layer = camada
                            break

                # Adiciona o arquivo ao combo box
                combobox.setLayer(layer)

                return file_

            elif file_type == "text".lower():
                file_, _ = QFileDialog.getOpenFileName(
                    None, caption="Select a file!", directory=directory, filter="Text Files (*.txt)", options=options)

                # Verificar se algum arquivo foi selecionado
                if file_:
                    line_edit.setText(file_)
                    break

                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(
                        None, "No file selected", result, QMessageBox.Ok)
                    if reply == QMessageBox.Ok:
                        break

            elif file_type == "bin".lower():
                file_, _ = QFileDialog.getOpenFileName(
                    None, caption="Select a file!", directory=directory, filter="Binary (*.bin)", options=options)

                # Verificar se algum arquivo foi selecionado
                if file_:
                    line_edit.setText(file_)
                    break

                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(
                        None, "No file selected", result, QMessageBox.Ok)
                    if reply == QMessageBox.Ok:
                        break

            elif file_type == "shp".lower():
                # seleciona apenas arquivos shapefile
                file_, _ = QFileDialog.getOpenFileName(
                    None, "Select a file!", directory, "Shapefile (*.shp)", options=options)
                if not file_:
                    QMessageBox.warning(
                        None, "No file selected", "Wait! You did not select any file.")
                    return None

                # Se o shp nao estiver no projeto, adiciona
                if file_ not in [layer.source() for layer in QgsProject.instance().mapLayers().values()]:
                    layer = QgsVectorLayer(
                        file_, os.path.basename(file_), "ogr")
                    QgsProject.instance().addMapLayer(layer)

                # Adiciona o arquivo ao combo box
                combobox.setLayer(layer)
                return file_

    def save_buttons(self, line_edit, file_type='raster'):
        '''Esta funcao configura os botoes da salvar (criar arquivo)'''
        # Seleciona o arquivo enviado pelo usuario
        while True:
            # Obtendo o caminho do arquivo a ser salvo usando um dialogo de arquivo
            if file_type == 'raster':
                file_name, _ = QFileDialog.getSaveFileName(
                    None, "Save the file", '', "GeoTIFF(*.tif)")
                if file_name:
                    line_edit.setText(file_name)
                    break
                else:
                    # O usuario nao solucionou um arquivo (um caminho para salvar o arquivo de saida)
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(
                        None, "No file selected", result, QMessageBox.Ok)
                    if reply == QMessageBox.Ok:
                        break

            elif file_type == 'bin':
                file_name, _ = QFileDialog.getSaveFileName(
                    None, "Save the file", '', "Binary (*.bin)")
                if file_name:
                    line_edit.setText(file_name)
                    break
                else:
                    # O usuario nao solucionou um arquivo (um caminho para salvar o arquivo de saida)
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(
                        None, "No file selected", result, QMessageBox.Ok)
                    if reply == QMessageBox.Ok:
                        break

            elif file_type == 'text':
                file_name, _ = QFileDialog.getSaveFileName(
                    None, "Save the file", '', "Text (*.txt)")
                if file_name:
                    line_edit.setText(file_name)
                    break
                else:
                    # O usuario nao solucionou um arquivo (um caminho para salvar o arquivo de saida)
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(
                        None, "No file selected", result, QMessageBox.Ok)
                    if reply == QMessageBox.Ok:
                        break
            elif file_type == 'vid':
                file_name, _ = QFileDialog.getSaveFileName(
                    None, "Save the file", '', "Video (*.mp4)")
                if file_name:
                    line_edit.setText(file_name)
                    break
                else:
                    # O usuario nao solucionou um arquivo (um caminho para salvar o arquivo de saida)
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(
                        None, "No file selected", result, QMessageBox.Ok)
                    if reply == QMessageBox.Ok:
                        break

    def seleciona_pasta(self, line_edit):
        """Esta funcao solicita ao usuario a pasta para salvar os mapas da precipitacao interpolada por cada delta_t"""
        while True:
            file_name = QFileDialog.getExistingDirectory(
                None, "Select a folder")
            if file_name:
                line_edit.setText(file_name)
                break
            else:
                # O usuario nao solucionou um arquivo (um caminho para salvar o arquivo de saida)
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(
                    None, "No file selected", result, QMessageBox.Ok)
                if reply == QMessageBox.Ok:
                    break

    def add_file_to_project(self, caminho_arquivo, combobox, shp=False):
        """
        Adiciona um arquivo .tif ou .shp ao projeto QGIS se ainda nao estiver presente e seleciona no combobox.
        :param caminho_arquivo: Caminho absoluto do arquivo (.tif ou .shp)
        :param combobox: QComboBox do QGIS para selecao da camada
        :param shp: Define se o arquivo e shapefile (True) ou raster (False)
        """
        nome_base = os.path.basename(caminho_arquivo)
        camada_existente = None

        # Verifica se ja existe uma camada com o mesmo source (caminho do arquivo)
        for camada in QgsProject.instance().mapLayers().values():
            if camada.source() == caminho_arquivo:
                camada_existente = camada
                break

        # Caso a camada ainda nao exista, adiciona ao projeto
        if camada_existente is None:
            if shp:
                nova_camada = QgsVectorLayer(caminho_arquivo, nome_base, "ogr")
            else:
                nova_camada = QgsRasterLayer(caminho_arquivo, nome_base)

            if nova_camada.isValid():
                QgsProject.instance().addMapLayer(nova_camada)
                camada_existente = nova_camada
            else:
                QMessageBox.warning(
                    None, "Error", f"Could not add file: {caminho_arquivo}")
                return

        # Atualiza o combobox com o nome da camada
        index = combobox.findText(camada_existente.name())
        if index != -1:
            combobox.setCurrentIndex(index)
        else:
            combobox.addItem(camada_existente.name())
            combobox.setCurrentIndex(
                combobox.findText(camada_existente.name()))

    def save_to_project(self, function, file_name):
        """
        Gera um arquivo de texto unico contendo todas as informacoes 
        apresentadas nas diferentes paginas do plugin.
        Function: Indica qual funcao a pagina pertence
            function == 1: Flow travel time;
            function == 2: Excess rainfall;
            function == 3: Flow routing
        """
        self.save_result = True
        with open(file_name, 'w', encoding='utf-8') as arquivo_txt:

            if function == 1:
                # Atribui nome do projeto a GUI
                self.dlg_flow_tt.le_12_pg2.setText(
                    self.dlg_save_project_flow_tt.le_1_pg1.text())
                self.dlg_flow_tt.le_1_pg3.setText(
                    self.dlg_save_project_flow_tt.le_1_pg1.text())
                self.dlg_flow_tt.le_12_pg4.setText(
                    self.dlg_save_project_flow_tt.le_1_pg1.text())

                # Secao: Flow Travel Time - Configuration (Pagina 1)

                arquivo_txt.write(
                    f"Project name: {self.dlg_save_project_flow_tt.le_1_pg1.text()}\n")

                arquivo_txt.write("Flow Travel Time - Configuration\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("GENERAL INFORMATIONS\n")
                arquivo_txt.write(
                    "Minimum slope surface travel time determination (m/km):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_1_pg1.text()}\n")
                arquivo_txt.write(
                    "Orthogonal step for distance computation (dx):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_3_pg1.text()}\n")
                arquivo_txt.write(
                    "Diagonal step for distance computation (dx):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_4_pg1.text()}\n")
                arquivo_txt.write("Flow direction code:\n")
                arquivo_txt.write(
                    f"A = {self.dlg_flow_tt.le_5_pg1.text()}\n")
                arquivo_txt.write(
                    f"B = {self.dlg_flow_tt.le_6_pg1.text()}\n")
                arquivo_txt.write(
                    f"C = {self.dlg_flow_tt.le_7_pg1.text()}\n")
                arquivo_txt.write(
                    f"D = {self.dlg_flow_tt.le_8_pg1.text()}\n")
                arquivo_txt.write(
                    f"E = {self.dlg_flow_tt.le_9_pg1.text()}\n")
                arquivo_txt.write(
                    f"F = {self.dlg_flow_tt.le_10_pg1.text()}\n")
                arquivo_txt.write(
                    f"G = {self.dlg_flow_tt.le_11_pg1.text()}\n")
                arquivo_txt.write(
                    f"H = {self.dlg_flow_tt.le_12_pg1.text()}\n")
                arquivo_txt.write(
                    "CHANELS WITHOUT CROSS SECTIONAL AREA INFORMATIONS\n")
                arquivo_txt.write(
                    "Manning coefficient for river segments without cross-section information:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_14_pg1.text()}\n")
                arquivo_txt.write("Maximum river segment lenght (m):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_15_pg1.text()}\n")
                arquivo_txt.write("Group Box is checked:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.groupBox_3.isChecked()}\n")
                arquivo_txt.write(
                    f"Coefficient c = {self.dlg_flow_tt.le_16_pg1.text()}\n")
                arquivo_txt.write(
                    f"Coefficient d = {self.dlg_flow_tt.le_17_pg1.text()}\n")
                arquivo_txt.write(
                    f"Coefficient g = {self.dlg_flow_tt.le_18_pg1.text()}\n")
                arquivo_txt.write(
                    f"Coefficient h = {self.dlg_flow_tt.le_19_pg1.text()}\n")
                arquivo_txt.write(
                    "lineage: Este arquivo foi criado automaticamente pelo Hidropixel\n")

                # Secao: Flow Travel Time - Input Data (Pagina 2)
                arquivo_txt.write("Flow Travel Time - Input Data\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Watershed delineation:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.cb_1_pg2.currentLayer().source()}\n")
                arquivo_txt.write("\nPoint of Interest (POI) Location:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.cb_8_pg2.currentLayer().source() if self.dlg_flow_tt.cb_8_pg2.currentLayer() is not None else ''}\n")
                arquivo_txt.write("\nDigital elevation model:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.cb_2_pg2.currentLayer().source()}\n")
                arquivo_txt.write("\nFlow direction:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.cb_3_pg2.currentLayer().source()}\n")
                arquivo_txt.write("\nRiver drainage network (RDN):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.cb_4_pg2.currentLayer().source()}\n")
                arquivo_txt.write("\nRDN segmentation into classes:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.cb_5_pg2.currentLayer().source() if self.dlg_flow_tt.cb_5_pg2.currentLayer() is not None else ''}\n")
                arquivo_txt.write("\nDrainage area (km²):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.cb_6_pg2.currentLayer().source()}\n")
                arquivo_txt.write("\nCharacteristics of RDN classes:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_8_pg2.text()}\n")
                arquivo_txt.write("\nLand use or land cover (LULC) map:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.cb_7_pg2.currentLayer().source()}\n")
                arquivo_txt.write(
                    "\nManning roughness coefficient for each LULC:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_10_pg2.text()}\n")
                arquivo_txt.write("\nRainfall depth for 24-h duration (mm):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.le_11_pg2.text()}\n")

                # Secao: Flow Travel Time - Run page (Pagina 4)
                arquivo_txt.write("Flow Travel Time - Run page\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Slope relative to downstream pixel:\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_flow_tt.le_21_pg1.text(),self.dlg_flow_tt.le_6_pg4.text()) if self.dlg_flow_tt.le_21_pg1.text()!= '' and self.dlg_flow_tt.le_6_pg4.text()!= '' else self.dlg_flow_tt.le_6_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_6_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_17_pg4.isChecked()}\n")
                arquivo_txt.write(
                    "All river segments with similar hydrologic conditions:\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_flow_tt.le_21_pg1.text(),self.dlg_flow_tt.le_7_pg4.text()) if self.dlg_flow_tt.le_21_pg1.text()!= '' and self.dlg_flow_tt.le_7_pg4.text()!= ''  else self.dlg_flow_tt.le_7_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_7_pg4.isChecked()}\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_18_pg4.isChecked()}\n")
                arquivo_txt.write(
                    "Hydraulic radius, roughness and slope for all river segments:\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_flow_tt.le_21_pg1.text(),self.dlg_flow_tt.le_8_pg4.text()) if self.dlg_flow_tt.le_21_pg1.text()!= '' and self.dlg_flow_tt.le_8_pg4.text()!= '' else self.dlg_flow_tt.le_8_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_8_pg4.isChecked()}\n")
                arquivo_txt.write(
                    "River cross-sectional area calculated by regional curves (m²):\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_flow_tt.le_21_pg1.text(),self.dlg_flow_tt.le_9_pg4.text()) if self.dlg_flow_tt.le_21_pg1.text()!= '' and self.dlg_flow_tt.le_9_pg4.text()!= '' else self.dlg_flow_tt.le_9_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_9_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_20_pg4.isChecked()}\n")
                arquivo_txt.write(
                    "River cross-sectional area calculated by regional curves (m):\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_flow_tt.le_21_pg1.text(),self.dlg_flow_tt.le_10_pg4.text()) if self.dlg_flow_tt.le_21_pg1.text()!= '' and self.dlg_flow_tt.le_10_pg4.text()!= '' else self.dlg_flow_tt.le_10_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_10_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_21_pg4.isChecked()}\n")
                arquivo_txt.write("Flow travel time (min):\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_flow_tt.le_21_pg1.text(),self.dlg_flow_tt.le_11_pg4.text()) if self.dlg_flow_tt.le_21_pg1.text()!= '' and self.dlg_flow_tt.le_11_pg4.text()!= '' else self.dlg_flow_tt.le_11_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_11_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_22_pg4.isChecked()}\n")
                arquivo_txt.write("Flow travel time (min) for each POI:\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_flow_tt.le_21_pg1.text(),self.dlg_flow_tt.le_13_pg4.text()) if self.dlg_flow_tt.le_21_pg1.text()!= '' and self.dlg_flow_tt.le_13_pg4.text()!= '' else self.dlg_flow_tt.le_13_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_tt.ch_12_pg4.isChecked()}\n")

                # Escreve working folder
                arquivo_txt.write("Working Folder:\n")
                arquivo_txt.write(f'={self.dlg_flow_tt.le_21_pg1.text()}')

            if function == 2:
                # Define valor do projeto na GUI
                self.dlg_exc_rain.le_6_pg_ri.setText(
                    self.dlg_save_project_exc_rain.le_1_pg1.text())
                self.dlg_exc_rain.le_5_pg2.setText(
                    self.dlg_save_project_exc_rain.le_1_pg1.text())
                self.dlg_exc_rain.le_1_pg3.setText(
                    self.dlg_save_project_exc_rain.le_1_pg1.text())
                self.dlg_exc_rain.le_7_pg4.setText(
                    self.dlg_save_project_exc_rain.le_1_pg1.text())

                # Secao: Excess Rainfall - Configuration page (Funcao 2, Pagina 1)
                arquivo_txt.write(
                    f"Project name: {self.dlg_save_project_exc_rain.le_1_pg1.text()}\n")
                arquivo_txt.write("Excess Rainfall - Configuration page\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Initial abstraction parameter (λ):\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_1_pg1.text()}\n")
                arquivo_txt.write("Rainfall definition:\n")
                arquivo_txt.write("    Areal averaged:\n")
                arquivo_txt.write(
                    f"   ={self.dlg_exc_rain.rb_1_pg1.isChecked()}\n")
                arquivo_txt.write("    Spatially distributed:\n")
                arquivo_txt.write(
                    f"   ={self.dlg_exc_rain.rb_2_pg1.isChecked()}\n")

                # Secao: Excess Rainfall - Rainfall interpolation (Funcao 2, Pagina 2)
                arquivo_txt.write("Excess Rainfall - Rainfall interpolation\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Watershed delineation:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.cb_1_pg_ri.currentLayer().source()}\n")
                arquivo_txt.write("Rain gauges metadata:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_2_pg_ri.text()}\n")
                arquivo_txt.write("Rainfall data:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_3_pg_ri.text()}\n")
                arquivo_txt.write("\nRainfall file:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_4_pg_ri.text()}\n")
                arquivo_txt.write("Rainfall maps:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.le_5_pg_ri.text()}\n")

                # Secao: Excess Rainfall - Input Data (Funcao 2, Pagina 3)
                arquivo_txt.write("Excess Rainfall - Input Data\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Watershed delineation:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.cb_1_pg2.currentLayer().source()}\n")
                arquivo_txt.write("Map of curve-number:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.cb_2_pg2.currentLayer().source()}\n")
                if self.dlg_exc_rain.rb_1_pg1.isChecked():
                    arquivo_txt.write("Areal averaged rainfall:\n")
                    arquivo_txt.write(
                        f"={self.dlg_exc_rain.le_3_pg2.text()}\n")
                else:
                    arquivo_txt.write(
                        "Spatially distributed rainfall:\n")
                    arquivo_txt.write(
                        f"={self.dlg_exc_rain.le_4_pg2.text()}\n")

                # Secao: Excess Rainfall - Run page (Funcao 2, Pagina 4)
                arquivo_txt.write("Excess Rainfall - Run page\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Numbering of watershed pixels:\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_exc_rain.le_3_pg1.text(),self.dlg_exc_rain.le_1_pg4.text()) if self.dlg_exc_rain.le_3_pg1.text()!= '' and self.dlg_exc_rain.le_1_pg4.text()!= '' else self.dlg_exc_rain.le_1_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_1_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_7_pg4.isChecked()}\n")
                arquivo_txt.write("Maximum potential retention (mm):\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_exc_rain.le_3_pg1.text(),self.dlg_exc_rain.le_2_pg4.text()) if self.dlg_exc_rain.le_3_pg1.text()!= '' and self.dlg_exc_rain.le_2_pg4.text()!= '' else self.dlg_exc_rain.le_2_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_2_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_8_pg4.isChecked()}\n")
                arquivo_txt.write("Initial abstraction (mm):\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_exc_rain.le_3_pg1.text(),self.dlg_exc_rain.le_3_pg4.text()) if self.dlg_exc_rain.le_3_pg1.text()!= '' and self.dlg_exc_rain.le_3_pg4.text()!= '' else self.dlg_exc_rain.le_3_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_3_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_9_pg4.isChecked()}\n")
                arquivo_txt.write("Total rainfall (mm):\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_exc_rain.le_3_pg1.text(),self.dlg_exc_rain.le_4_pg4.text()) if self.dlg_exc_rain.le_3_pg1.text()!= '' and self.dlg_exc_rain.le_4_pg4.text()!= '' else self.dlg_exc_rain.le_4_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_4_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_10_pg4.isChecked()}\n")
                arquivo_txt.write("Total excess rainfall (mm):\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_exc_rain.le_3_pg1.text(),self.dlg_exc_rain.le_5_pg4.text()) if self.dlg_exc_rain.le_3_pg1.text()!= '' and self.dlg_exc_rain.le_5_pg4.text()!= '' else self.dlg_exc_rain.le_5_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_5_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_11_pg4.isChecked()}\n")
                arquivo_txt.write("Excess hyetographs per pixel (mm):\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_exc_rain.le_3_pg1.text(),self.dlg_exc_rain.le_6_pg4.text()) if self.dlg_exc_rain.le_3_pg1.text()!= '' and self.dlg_exc_rain.le_6_pg4.text()!= '' else self.dlg_exc_rain.le_6_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_exc_rain.ch_6_pg4.isChecked()}\n")
                # Escreve working folder
                arquivo_txt.write("Working Folder:\n")
                arquivo_txt.write(f'={self.dlg_exc_rain.le_3_pg1.text()}')

            if function == 3:

                # Define valor do projeto na GUI

                self.dlg_flow_rout.le_6_pg2.setText(
                    self.dlg_save_project_flow_rout.le_1_pg1.text())

                self.dlg_flow_rout.le_1_pg3.setText(
                    self.dlg_save_project_flow_rout.le_1_pg1.text())

                self.dlg_flow_rout.le_8_pg4.setText(
                    self.dlg_save_project_flow_rout.le_1_pg1.text())

                # Secao: Flow Routing - Configuration page (Funcao 3, Pagina 1)
                arquivo_txt.write(
                    f"Project name: {self.dlg_save_project_flow_rout.le_1_pg1.text()}\n")
                arquivo_txt.write("Flow Routing - Configuration page\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Model type:\n")
                arquivo_txt.write("    Hidropixel - TUH+:\n")
                arquivo_txt.write(
                    f"   ={self.dlg_flow_rout.rb_2_pg1.isChecked()}\n")
                arquivo_txt.write("    Hidropixel - DLR:\n")
                arquivo_txt.write(
                    f"   ={self.dlg_flow_rout.rb_3_pg1.isChecked()}\n")
                arquivo_txt.write("Parameter β:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.le_5_pg1.text()}\n")
                arquivo_txt.write("Time step (min):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.le_2_pg1.text()}\n")

                # Secao: Flow Routing - Input Data page (Funcao 3, Pagina 2)
                arquivo_txt.write("Flow Routing - Input Data page\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("Watershed delineation:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.cb_1_pg2.currentLayer().source()}\n")
                arquivo_txt.write("Flow travel time:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.cb_3_pg2.currentLayer().source()}\n")
                arquivo_txt.write("Flow travel time (min) for each POI:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.le_3_pg2.text()}\n")
                arquivo_txt.write("Excess hyetographs per pixel:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.le_4_pg2.text()}\n")
                arquivo_txt.write("Total excess rainfall per pixel (mm):\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.cb_5_pg2.currentLayer().source()}\n")
                arquivo_txt.write(
                    "Hydrograph estimation for different watershed classes:\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.groupBox_2.isChecked()}\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.cb_4_pg2.currentText()}\n")

                # Secao: Flow Routing - Run page (Funcao 3, Pagina 4)
                arquivo_txt.write("Flow Routing - Run page\n")
                arquivo_txt.write(
                    "-------------------------------------------------\n")
                arquivo_txt.write("TUH peak discharge per pixel:\n")
                arquivo_txt.write(
                    f"=")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"=False")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"=False")
                arquivo_txt.write("Select unit:\n")
                arquivo_txt.write("(L/s)\n")
                arquivo_txt.write(
                    f"=False")
                arquivo_txt.write("(m³/s)\n")
                arquivo_txt.write(
                    f"=False")
                arquivo_txt.write("TUH base time per pixel (min):\n")
                arquivo_txt.write(
                    f"=")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"=False")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"=False")
                arquivo_txt.write("Map of TUH base time (min):\n")
                arquivo_txt.write(
                    f"=")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"=False")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"=False\n")
                arquivo_txt.write("Resulting peak discharge per pixel:\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_flow_rout.le_3_pg1.text(),self.dlg_flow_rout.le_4_pg4.text()) if self.dlg_flow_rout.le_3_pg1.text()!= '' and self.dlg_flow_rout.le_4_pg4.text()!= '' else self.dlg_flow_rout.le_4_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_4_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_10_pg4.isChecked()}\n")
                arquivo_txt.write("Select unit:\n")
                arquivo_txt.write("(L/s)\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.rb_3_pg4.isChecked()}\n")
                arquivo_txt.write("(m³/s)\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.rb_4_pg4.isChecked()}\n")
                arquivo_txt.write("Resulting runoff volume per pixel (m³):\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_flow_rout.le_3_pg1.text(),self.dlg_flow_rout.le_5_pg4.text()) if self.dlg_flow_rout.le_3_pg1.text()!= '' and self.dlg_flow_rout.le_5_pg4.text()!= '' else self.dlg_flow_rout.le_5_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_5_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_11_pg4.isChecked()}\n")
                arquivo_txt.write("Resulting watershed hydrograph (m³/s):\n")
                arquivo_txt.write(
                    f"={os.path.join(self.dlg_flow_rout.le_3_pg1.text(),self.dlg_flow_rout.le_6_pg4.text()) if self.dlg_flow_rout.le_3_pg1.text()!= '' and self.dlg_flow_rout.le_6_pg4.text()!= '' else self.dlg_flow_rout.le_6_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_6_pg4.isChecked()}\n")
                arquivo_txt.write("Add:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_12_pg4.isChecked()}\n")
                if self.dlg_flow_rout.ch_12_pg4.isChecked():
                    arquivo_txt.write("Observed runoff (m³/s):\n")
                    arquivo_txt.write(
                        f"={os.path.join(self.dlg_flow_rout.le_3_pg1.text(),self.dlg_flow_rout.le_7_pg4.text()) if self.dlg_flow_rout.le_3_pg1.text()!= '' and self.dlg_flow_rout.le_7_pg4.text()!= '' else self.dlg_flow_rout.le_7_pg4.text()}\n")
                arquivo_txt.write(
                    "Resulting hydrograph (m³/s) for each POI:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.le_9_pg4.text()}\n")
                arquivo_txt.write("Selected:\n")
                arquivo_txt.write(
                    f"={self.dlg_flow_rout.ch_13_pg4.isChecked()}\n")

                # Escreve working folder
                arquivo_txt.write("Working Folder:\n")
                arquivo_txt.write(f'={self.dlg_flow_rout.le_3_pg1.text()}')

    def read_from_project(self, function, directory):
        '''Obtem as informacoes a partir projeto .hpx enviado pelo usuario
        Function: Indica qual funcao a pagina pertence
                function == 1: Flow travel time;
                function == 2: Excess rainfall;
                function == 3: Flow routing
        '''
        # Seleciona o arquivo enviado pelo usuario
        while True:
            options = QFileDialog.Options()
            file_, _ = QFileDialog.getOpenFileName(
                None, caption="Select a file!", directory=directory, filter="Hidropixel project (*.hpx)", options=options)

            if file_:
                if function == 1:
                    # Ler as informacoes da pagina 1: configuration
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                        # Armazena as informacoes do arquivo enviado em uma lista
                        cabecalho = arquivo_txt.readline().split(":")[1]
                        values = []
                        tif_val = [None]
                        shp_val = [None]
                        for line in arquivo_txt:
                            if '=' in line:
                                value_ = line.split("=")[1].strip()
                                values.append(value_)
                                if '.tif' in line:
                                    tif_file = line.split("=")[1].strip()
                                    tif_val.append(tif_file)
                                if '.shp' in line:
                                    shp_file = line.split("=")[1].strip()
                                    shp_val.append(shp_file)

                    # Adiciona as informacoes lidas nas suas respectivas
                    self.dlg_flow_tt.le_12_pg2.setText(
                        cabecalho)
                    self.dlg_flow_tt.le_1_pg3.setText(
                        cabecalho)
                    self.dlg_flow_tt.le_12_pg4.setText(
                        cabecalho)

                    # General informations
                    self.dlg_flow_tt.le_1_pg1.setText(str(values[0]))
                    self.dlg_flow_tt.le_3_pg1.setText(str(values[1]))
                    self.dlg_flow_tt.le_4_pg1.setText(str(values[2]))

                    # Flow dir
                    self.dlg_flow_tt.le_5_pg1.setText(str(values[3]))
                    self.dlg_flow_tt.le_6_pg1.setText(str(values[4]))
                    self.dlg_flow_tt.le_7_pg1.setText(str(values[5]))
                    self.dlg_flow_tt.le_8_pg1.setText(str(values[6]))
                    self.dlg_flow_tt.le_9_pg1.setText(str(values[7]))
                    self.dlg_flow_tt.le_10_pg1.setText(str(values[8]))
                    self.dlg_flow_tt.le_11_pg1.setText(str(values[9]))
                    self.dlg_flow_tt.le_12_pg1.setText(str(values[10]))

                    # River channels without cross sectional data
                    self.dlg_flow_tt.le_14_pg1.setText(str(values[11]))
                    self.dlg_flow_tt.le_15_pg1.setText(str(values[12]))

                    # Regional curve
                    self.dlg_flow_tt.groupBox_3.setChecked(
                        str(values[13]) == 'True')
                    self.dlg_flow_tt.le_16_pg1.setText(str(values[14]))
                    self.dlg_flow_tt.le_17_pg1.setText(str(values[15]))
                    self.dlg_flow_tt.le_18_pg1.setText(str(values[16]))
                    self.dlg_flow_tt.le_19_pg1.setText(str(values[17]))

                    # ---Input data---

                    # Adiciona as informacoes lidas a seus respectivos campos
                    self.add_file_to_project(
                        values[18], self.dlg_flow_tt.cb_1_pg2)

                    if values[19] != '':
                        self.add_file_to_project(
                            values[19], self.dlg_flow_tt.cb_8_pg2, shp=True)
                    else:
                        self.dlg_flow_tt.cb_8_pg2.setCurrentIndex(-1)

                    self.add_file_to_project(
                        values[20], self.dlg_flow_tt.cb_2_pg2)

                    self.add_file_to_project(
                        values[21], self.dlg_flow_tt.cb_3_pg2)

                    self.add_file_to_project(
                        values[22], self.dlg_flow_tt.cb_4_pg2)

                    if values[23] != '':
                        self.add_file_to_project(
                            values[23], self.dlg_flow_tt.cb_5_pg2)
                    else:
                        self.dlg_flow_tt.cb_5_pg2.setCurrentIndex(-1)

                    self.add_file_to_project(
                        values[24], self.dlg_flow_tt.cb_6_pg2)

                    self.add_file_to_project(
                        values[26], self.dlg_flow_tt.cb_7_pg2)

                    # Atribui os valores do arquivo enviado a tabela em questao
                    self.dlg_flow_tt.le_8_pg2.setText(str(values[25]))
                    if str(values[25]) != '':
                        self.read_tb_from_file_2(
                            self.dlg_flow_tt.tbw_1_pg2, values[25], 1, 2)

                    # Atribui os valores do arquivo enviado a tabela em questao
                    self.dlg_flow_tt.le_10_pg2.setText(str(values[27]))
                    if str(values[27]) != '':
                        self.read_tb_from_file_2(
                            self.dlg_flow_tt.tbw_2_pg2, values[27], 1, 1)

                    self.dlg_flow_tt.le_11_pg2.setText(str(values[28]))

                    # Ler arquivos pagina 4 - run
                    # Adiciona as informacoes lidas a seus respectivos campos
                    self.dlg_flow_tt.le_6_pg4.setText(str(values[29]))
                    self.dlg_flow_tt.ch_6_pg4.setChecked(
                        str(values[30]) == 'True')
                    self.dlg_flow_tt.ch_17_pg4.setChecked(
                        str(values[31]) == 'True')

                    self.dlg_flow_tt.le_7_pg4.setText(str(values[32]))
                    self.dlg_flow_tt.ch_7_pg4.setChecked(
                        str(values[33]) == 'True')
                    self.dlg_flow_tt.ch_18_pg4.setChecked(
                        str(values[34]) == 'True')

                    self.dlg_flow_tt.le_8_pg4.setText(str(values[35]))
                    self.dlg_flow_tt.ch_8_pg4.setChecked(
                        str(values[36]) == 'True')

                    self.dlg_flow_tt.le_9_pg4.setText(str(values[37]))
                    self.dlg_flow_tt.ch_9_pg4.setChecked(
                        str(values[38]) == 'True')
                    self.dlg_flow_tt.ch_20_pg4.setChecked(
                        str(values[39]) == 'True')

                    self.dlg_flow_tt.le_10_pg4.setText(str(values[40]))
                    self.dlg_flow_tt.ch_10_pg4.setChecked(
                        str(values[41]) == 'True')
                    self.dlg_flow_tt.ch_21_pg4.setChecked(
                        str(values[42]) == 'True')

                    self.dlg_flow_tt.le_11_pg4.setText(str(values[43]))
                    self.dlg_flow_tt.ch_11_pg4.setChecked(
                        str(values[44]) == 'True')
                    self.dlg_flow_tt.ch_22_pg4.setChecked(
                        str(values[45]) == 'True')

                    self.dlg_flow_tt.le_13_pg4.setText(str(values[46]))
                    self.dlg_flow_tt.ch_12_pg4.setChecked(
                        str(values[47]) == 'True')

                    self.dlg_flow_tt.le_21_pg1.setText(str(values[48]))
                    break

                elif function == 2:
                    # Le os dados do arquivo e extrai as linhas que contenham o caractere "="
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                        cabecalho = arquivo_txt.readline().split(":")[1]
                        values = []
                        tif_val2 = [None]
                        for line in arquivo_txt:
                            if '=' in line:
                                # Remove o caractere "=" e espacos em branco no inicio/fim da linha
                                value = line.replace('=', '').strip()
                                values.append(value)
                                if '.tif' in line:
                                    tif_file = line.split("=")[1].strip()
                                    tif_val2.append(tif_file)

                    self.dlg_exc_rain.le_6_pg_ri.setText(
                        cabecalho)
                    self.dlg_exc_rain.le_5_pg2.setText(
                        cabecalho)
                    self.dlg_exc_rain.le_1_pg3.setText(
                        cabecalho)
                    self.dlg_exc_rain.le_7_pg4.setText(
                        cabecalho)

                    # Secao: Excess Rainfall - Configuration page
                    self.dlg_exc_rain.le_1_pg1.setText(str(values[0]))
                    self.dlg_exc_rain.rb_1_pg1.setChecked(
                        str(values[1]) == 'True')
                    self.dlg_exc_rain.rb_2_pg1.setChecked(
                        str(values[2]) == 'True')

                    # Secao: Excess Rainfall - Rainfall interpolation
                    self.add_file_to_project(
                        str(values[3]), self.dlg_exc_rain.cb_1_pg_ri)
                    self.dlg_exc_rain.le_2_pg_ri.setText(
                        os.path.basename(str(values[4])))
                    self.dlg_exc_rain.le_3_pg_ri.setText(
                        os.path.basename(str(values[5])))
                    self.dlg_exc_rain.le_4_pg_ri.setText(
                        os.path.basename(str(values[6])))
                    self.dlg_exc_rain.le_5_pg_ri.setText(
                        os.path.basename(str(values[7])))

                    # Secao: Excess Rainfall - Input Data
                    self.add_file_to_project(
                        str(values[8]), self.dlg_exc_rain.cb_1_pg2)
                    self.add_file_to_project(
                        str(values[9]), self.dlg_exc_rain.cb_2_pg2)

                    # Se o rb_1_pg1 estiver marcado, usa um campo; senao, usa o outro
                    if self.dlg_exc_rain.rb_1_pg1.isChecked():
                        self.dlg_exc_rain.le_3_pg2.setText(str(values[10]))
                    else:
                        self.dlg_exc_rain.le_4_pg2.setText(str(values[10]))

                    # Secao: Excess Rainfall - Run page
                    self.dlg_exc_rain.le_1_pg4.setText(str(values[11]))
                    self.dlg_exc_rain.ch_1_pg4.setChecked(
                        str(values[12]) == 'True')
                    self.dlg_exc_rain.ch_7_pg4.setChecked(
                        str(values[13]) == 'True')

                    self.dlg_exc_rain.le_2_pg4.setText(str(values[14]))
                    self.dlg_exc_rain.ch_2_pg4.setChecked(
                        str(values[15]) == 'True')
                    self.dlg_exc_rain.ch_8_pg4.setChecked(
                        str(values[16]) == 'True')

                    self.dlg_exc_rain.le_3_pg4.setText(str(values[17]))
                    self.dlg_exc_rain.ch_3_pg4.setChecked(
                        str(values[18]) == 'True')
                    self.dlg_exc_rain.ch_9_pg4.setChecked(
                        str(values[19]) == 'True')

                    self.dlg_exc_rain.le_4_pg4.setText(str(values[20]))
                    self.dlg_exc_rain.ch_4_pg4.setChecked(
                        str(values[21]) == 'True')
                    self.dlg_exc_rain.ch_10_pg4.setChecked(
                        str(values[22]) == 'True')

                    self.dlg_exc_rain.le_5_pg4.setText(str(values[23]))
                    self.dlg_exc_rain.ch_5_pg4.setChecked(
                        str(values[24]) == 'True')
                    self.dlg_exc_rain.ch_11_pg4.setChecked(
                        str(values[25]) == 'True')

                    self.dlg_exc_rain.le_6_pg4.setText(str(values[26]))
                    self.dlg_exc_rain.ch_6_pg4.setChecked(
                        str(values[27]) == 'True')

                    self.dlg_exc_rain.le_3_pg1.setText(str(values[28]))
                    break

                elif function == 3:
                    # Le os arquivos da primeira pagina
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                        cabecalho = arquivo_txt.readline().split(":")[1]
                        # Armazenara os valores das linhas
                        values = []
                        tif_val3 = [None]
                        for line in arquivo_txt:
                            if '=' in line:
                                # Substitui o identificador =por uma string fazia e retira os espacos da linha
                                value = line.replace('=', '').strip()
                                values.append(value)
                                if '.tif' in line:
                                    tif_file = line.split("=")[1].strip()
                                    tif_val3.append(tif_file)

                        # Adiciona project name a gui
                        self.dlg_flow_rout.le_6_pg2.setText(
                            cabecalho)

                        self.dlg_flow_rout.le_1_pg3.setText(
                            cabecalho)

                        self.dlg_flow_rout.le_8_pg4.setText(
                            cabecalho)

                    # Parametros
                    self.dlg_flow_rout.rb_2_pg1.setChecked(
                        str(values[0]) == 'True')
                    self.dlg_flow_rout.rb_3_pg1.setChecked(
                        str(values[1]) == 'True')
                    self.dlg_flow_rout.le_5_pg1.setText(str(values[2]))
                    self.dlg_flow_rout.le_2_pg1.setText(str(values[3]))

                    # Le os arquivos Input data
                    self.add_file_to_project(
                        str(values[4]), self.dlg_flow_rout.cb_1_pg2)
                    self.add_file_to_project(
                        str(values[5]), self.dlg_flow_rout.cb_3_pg2)
                    self.dlg_flow_rout.le_3_pg2.setText(str(values[6]))
                    self.dlg_flow_rout.le_4_pg2.setText(str(values[7]))
                    self.add_file_to_project(
                        str(values[8]), self.dlg_flow_rout.cb_5_pg2)
                    if values[9] == "True":
                        self.dlg_flow_rout.groupBox_2.setChecked(True)
                        self.add_file_to_project(
                            str(values[10]), self.dlg_flow_rout.cb_4_pg2)
                    else:
                        self.dlg_flow_rout.groupBox_2.setChecked(False)
                        self.dlg_flow_rout.cb_4_pg2.setCurrentIndex(-1)

                    # Le os arquivos Run

                    # Output1
                    # self.dlg_flow_rout.le_1_pg4.setText(str(values[11]))
                    # self.dlg_flow_rout.ch_1_pg4.setChecked(
                    #     str(values[12]) == 'True')
                    # self.dlg_flow_rout.ch_7_pg4.setChecked(
                    #     str(values[13]) == 'True')
                    # # Escolha da unidade (m³/a ou L/s)
                    # self.dlg_flow_rout.rb_1_pg4.setChecked(
                    #     str(values[14]) == 'True')
                    # self.dlg_flow_rout.rb_2_pg4.setChecked(
                    #     str(values[15]) == 'True')
                    # # Output2
                    # self.dlg_flow_rout.le_2_pg4.setText(str(values[16]))
                    # self.dlg_flow_rout.ch_2_pg4.setChecked(
                    #     str(values[17]) == 'True')
                    # self.dlg_flow_rout.ch_8_pg4.setChecked(
                    #     str(values[18]) == 'True')
                    # # Output3
                    # self.dlg_flow_rout.le_3_pg4.setText(str(values[19]))
                    # self.dlg_flow_rout.ch_3_pg4.setChecked(
                    #     str(values[20]) == 'True')
                    # self.dlg_flow_rout.ch_9_pg4.setChecked(
                    #     str(values[21]) == 'True')

                    # Output4
                    self.dlg_flow_rout.le_4_pg4.setText(str(values[22]))
                    self.dlg_flow_rout.ch_4_pg4.setChecked(
                        str(values[23]) == 'True')
                    self.dlg_flow_rout.ch_10_pg4.setChecked(
                        str(values[24]) == 'True')
                    # Escolha da unidade (m³/a ou L/s)
                    self.dlg_flow_rout.rb_3_pg4.setChecked(
                        bool(values[25]))
                    self.dlg_flow_rout.rb_4_pg4.setChecked(
                        bool(values[26]))
                    # Output5
                    self.dlg_flow_rout.le_5_pg4.setText(str(values[27]))
                    self.dlg_flow_rout.ch_5_pg4.setChecked(
                        str(values[28]) == 'True')
                    self.dlg_flow_rout.ch_11_pg4.setChecked(
                        str(values[29]) == 'True')
                    # Output6
                    self.dlg_flow_rout.le_6_pg4.setText(str(values[30]))
                    self.dlg_flow_rout.ch_6_pg4.setChecked(
                        str(values[31]) == 'True')
                    self.dlg_flow_rout.ch_12_pg4.setChecked(
                        str(values[32]) == 'True')

                    # hidrograma observado
                    if self.dlg_flow_rout.ch_12_pg4.isChecked():
                        self.dlg_flow_rout.le_7_pg4.setText(str(values[33]))
                        self.dlg_flow_rout.le_9_pg4.setText(str(values[34]))
                        self.dlg_flow_rout.ch_13_pg4.setChecked(
                            str(values[35]) == 'True')
                        self.dlg_flow_rout.le_3_pg1.setText(str(values[36]))
                        break

                    else:
                        self.dlg_flow_rout.le_9_pg4.setText(str(values[33]))
                        self.dlg_flow_rout.ch_13_pg4.setChecked(
                            str(values[34]) == 'True')
                        self.dlg_flow_rout.le_3_pg1.setText(str(values[35]))
                        break

            else:
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(
                    None, "No file selected", result, QMessageBox.Ok)
                if reply == QMessageBox.Ok:
                    break

    def save_table_to_file_btn(self, table):
        '''Esta funcao le as informacoes adicionadas as tabelas e as armazena em um arquivo apos o usuario clicar no botao de salvar
            table == 1: a tabela de referencia e a tabelea das caracteristicas da rede de drenagem
            table == 2 referencia a tabela das classes e coeficientes de manning.'''
        while True:
            if table == 1:
                # Solicita um local de salvamento para o usuario
                file_name, _ = QFileDialog.getSaveFileName(
                    None, "Save the file", "RDN_classes", "Text (*.txt)")
                if file_name:
                    self.dlg_flow_tt.le_8_pg2.setText(file_name)
                    # seleciona as dimensoes da tabela
                    nlin_tb1 = self.dlg_flow_tt.tbw_1_pg2.rowCount()
                    ncol_tb1 = self.dlg_flow_tt.tbw_1_pg2.columnCount()

                    # Escreve o arquivo de saida
                    with open(file_name, 'w', encoding='utf-8') as arquivo_txt_csv:
                        arquivo_txt_csv.write(f'Trecho,Rh (m),n,S (m/m)\n')
                        # Adicionando as informacoes das linhas e colunas ao arquivo de saida
                        for lin in range(nlin_tb1):
                            for col in range(ncol_tb1):
                                item = self.dlg_flow_tt.tbw_1_pg2.item(
                                    lin, col)
                                # Verifica se o item existe
                                if item is not None and item != '':
                                    if col != 3:
                                        arquivo_txt_csv.write(
                                            f'{item.text()},')
                                    else:
                                        arquivo_txt_csv.write(f'{item.text()}')
                            arquivo_txt_csv.write('\n')
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(
                        None, "No file selected", result, QMessageBox.Ok)
                    if reply == QMessageBox.Ok:
                        break

            elif table == 2:
                file_name, _ = QFileDialog.getSaveFileName(
                    None, "Save the file", "Manning_roughness_coef_for_each_LULC", "Text (*.txt)")
                if file_name:
                    self.dlg_flow_tt.le_10_pg2.setText(file_name)
                    # seleciona as dimensoes da tabela
                    nlin_tb1 = self.dlg_flow_tt.tbw_2_pg2.rowCount()
                    ncol_tb1 = self.dlg_flow_tt.tbw_2_pg2.columnCount()

                    # Escreve o arquivo de saida
                    with open(file_name, 'w', encoding='utf-8') as arquivo_txt_csv:
                        arquivo_txt_csv.write(
                            'Land Cover Type Code,Land Cover Type Name,Manning (Sheet Flow),Coefficient k (Shallow concentrated flow)\n')
                        # Adicionando as informacoes das linhas e colunas ao arquivo de saida
                        for lin in range(nlin_tb1):
                            for col in range(ncol_tb1):
                                item = self.dlg_flow_tt.tbw_2_pg2.item(
                                    lin, col)
                                # Verifica se o item existe
                                if item is not None and item != '':
                                    if col != 3:
                                        arquivo_txt_csv.write(
                                            f'{item.text()},')
                                    else:
                                        arquivo_txt_csv.write(f'{item.text()}')
                            arquivo_txt_csv.write('\n')
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(
                        None, "No file selected", result, QMessageBox.Ok)
                    if reply == QMessageBox.Ok:
                        break

    def save_table_to_file(self, table):
        '''Esta funcao le as informacoes adicionadas as tabelas e as armazena em um arquivo, sendo essas para leitura do visual basic
            table == 1: a tabela de referencia e a tabelea das caracteristicas da rede de drenagem
            table == 2 referencia a tabela das classes e coeficientes de manning.'''

        if table == 1:
            # Solicita um local de salvamento para o usuario
            self.file_name_tb1 = self.diretorio_atual + \
                r'\temp' + r'\segment_characteristics.txt'
            if self.file_name_tb1:
                # seleciona as dimensoes da tabela
                nlin_tb1 = self.dlg_flow_tt.tbw_1_pg2.rowCount()
                ncol_tb1 = self.dlg_flow_tt.tbw_1_pg2.columnCount()

                # Escreve o arquivo de saida
                with open(self.file_name_tb1, 'w', encoding='utf-8') as arquivo_txt_csv:
                    arquivo_txt_csv.write(f'Trecho,Rh (m),n,S (m/m)\n')
                    # Adicionando as informacoes das linhas e colunas ao arquivo de saida
                    for lin in range(nlin_tb1):
                        for col in range(ncol_tb1):
                            item = self.dlg_flow_tt.tbw_1_pg2.item(lin, col)
                            # Verifica se o item existe
                            if col <= 3:
                                if item is not None and item != '' and col < 3:
                                    arquivo_txt_csv.write(f'{item.text()},')
                                if col == 3:
                                    arquivo_txt_csv.write(f'{item.text()}')
                        arquivo_txt_csv.write('\n')

        elif table == 2:
            self.file_name_tb2 = self.diretorio_atual + r'\temp' + r'\surface_roughness.txt'
            if self.file_name_tb2:
                # seleciona as dimensoes da tabela
                nlin_tb1 = self.dlg_flow_tt.tbw_2_pg2.rowCount()
                ncol_tb1 = self.dlg_flow_tt.tbw_2_pg2.columnCount()

                # Escreve o arquivo de saida
                with open(self.file_name_tb2, 'w', encoding='utf-8') as arquivo_txt_csv:
                    arquivo_txt_csv.write(
                        'Land Cover Type Code,Land Cover Type Name,Manning (Sheet Flow),Coefficient k (Shallow concentrated flow)\n')
                    # Adicionando as informacoes das linhas e colunas ao arquivo de saida
                    for lin in range(nlin_tb1):
                        for col in range(ncol_tb1):
                            item = self.dlg_flow_tt.tbw_2_pg2.item(lin, col)
                            if col <= 3:
                                # Verifica se o item existe
                                if item is not None and item != '' and col < 3:
                                    arquivo_txt_csv.write(f'{item.text()},')
                                if col == 3:
                                    arquivo_txt_csv.write(f'{item.text()}')
                        arquivo_txt_csv.write('\n')

    def read_tb_from_file(self, table, lineEdit, table_ordem):
        '''Esta funcao adiciona os valores do arquivo enviado pelo usuario a respectiva tabela
            table == 1: a tabela de referencia e a tabelea das caracteristicas da rede de drenagem
            table == 2 referencia a tabela das classes e coeficientes de manning.'''

        # Seleciona o arquivo enviado pelo usuario
        options = QFileDialog.Options()
        directory = self.dlg_flow_tt.le_21_pg1.text()
        # Atualiza a flag para leitura dos dados da tabela
        self.flag = 1
        self.flag_1 = 1

        while True:
            # Solicita o arquivo
            file_, _ = QFileDialog.getOpenFileName(
                None, caption="Select a file!", directory=directory, filter="Text or CSV Files (*.txt *.csv)", options=options)

            if file_:
                # Configura a primeira tabela
                if table_ordem == 1:
                    lineEdit.setText(file_)
                    # Abre o arquivo e processa as linhas
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                        # Le a linha e o cabecalho
                        arquivo_txt_csv.readline()

                        # Inicializa as listas para armazenamento das informacoes
                        id_class_list = []
                        Sclasse_list = []
                        Mannclasse_list = []
                        Rhclasse_list = []

                        # Iterando sobre as linhas do arquivo
                        for line in arquivo_txt_csv:
                            info = line.strip().split(',')
                            # Armazenando os valores das linhas nas suas respectivas variaveis
                            if info[0] != '' and info[1] != '' and info[2] != '' and info[3]:
                                indice = info[0]
                                Scla = info[1]
                                Mann = info[2]
                                Rh = info[3]
                                # Adiciona os valores as listas
                                id_class_list.append(indice)
                                Sclasse_list.append(Scla)
                                Mannclasse_list.append(Mann)
                                Rhclasse_list.append(Rh)

                    # Atualiza no numero de linhas da tabela (recebe o numero de classes dos rios da bacia hidrografica)
                    table.setRowCount(len(Mannclasse_list))

                    # Coleta as dimensoes da tabela
                    n_row = table.rowCount()
                    n_column = table.columnCount()

                    # Itera sobre os elementos da tabela
                    for lin in range(n_row):
                        for col in range(n_column):

                            if col == 0:
                                # Adiciona a coluna do id
                                item = QTableWidgetItem(
                                    str(int(id_class_list[lin])))
                                table.setItem(lin, col, item)
                            elif col == 1:
                                # Adiciona a coluna da declividade
                                item = QTableWidgetItem(str(Sclasse_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 2:
                                # Adiciona a coluna do coef de Manning
                                item = QTableWidgetItem(
                                    str(Mannclasse_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 3:
                                # Adiciona a coluna do raio hidraulico
                                item = QTableWidgetItem(
                                    str(Rhclasse_list[lin]))
                                table.setItem(lin, col, item)
                    break

                # Configura a segunda tabela
                else:

                    # Criando variavel extra, para armazenar os tipos de uso e coeficente de Manning
                    lineEdit.setText(file_)
                    # Criando variavel extra, para armazenar os tipos de uso e coeficente de Manning
                    class_id = 0
                    class_val = []
                    class_name_val = []
                    coef_maning = []
                    coef_K = []
                    uso_manning_val = {}
                    coef_maning_val = []
                    coef_K_val = []

                    # Abrindo o arquivo que contem o coeficiente de Manning para os diferentes usos do solo
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                        # Amazena a linha do cabecalho
                        firt_line = arquivo_txt_csv.readline().strip()

                        # Le as informacoes de uso do solo e coeficiente de Manning
                        for line in arquivo_txt_csv:
                            # Coletando as informacoes de cada linha
                            info = line.strip().split(',')
                            # Armazenando os valores das linhas nas suas respectivas variaveis
                            if info[0] != '' and info[1] != '' and info[2] != '' and info[3]:
                                classe_id_key = int(info[0])
                                classe_name = str(info[1])
                                coef_maning = float(info[2])
                                coef_K = float(info[3])

                                # Adicionando os valores nas variaveis destinadas
                                coef_maning_val = np.append(
                                    coef_maning_val, coef_maning)
                                class_name_val = np.append(
                                    class_name_val, classe_name)
                                class_val = np.append(class_val, classe_id_key)
                                coef_K_val = np.append(coef_K_val, coef_K)
                                uso_manning_val[classe_id_key] = class_id
                                class_id += 1

                    # Atualiza no numero de linhas da tabela (recebe o numero de classes dos rios da bacia hidrografica)
                    table.setRowCount(len(uso_manning_val))

                    # Coleta as dimensoes da tabela
                    n_row = table.rowCount()
                    n_column = table.columnCount()

                    # Adiciona as informacoes a tabela
                    for col in range(n_column):
                        for lin in range(n_row):
                            if col == 0:
                                # Adiciona a coluna class Id
                                item = QTableWidgetItem(
                                    str(int(class_val[lin])))
                                table.setItem(lin, col, item)
                            elif col == 1:
                                # Adiciona a coluna class Name
                                item = QTableWidgetItem(
                                    str(class_name_val[lin]))
                                table.setItem(lin, col, item)
                            elif col == 2:
                                # Adiciona a coluna do coef de Manning
                                item = QTableWidgetItem(
                                    str(coef_maning_val[lin]))
                                table.setItem(lin, col, item)
                            elif col == 3:
                                # Adiciona a coluna do coef K (shallow concentreted flow)
                                item = QTableWidgetItem(str(coef_K_val[lin]))
                                table.setItem(lin, col, item)

                    break

            else:
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(
                    None, "No file selected", result, QMessageBox.Ok)
                if reply == QMessageBox.Ok:
                    break

    def read_tb_from_file_2(self, table, line_edit, table_ordem, tb2):
        '''Esta funcao adiciona os valores do arquivo enviado pelo usuario a tabela quando se clica no botao READ FROM FILE (da pagina 2)
            table == 1: a tabela de referencia e a tabelea das caracteristicas da rede de drenagem
            table == 2: referencia a tabela das classes e coeficientes de manning. 
            '''
        # Atribui os valores do arquivo enviado a tabela das caracteristicas
        file_ = str(line_edit)
        if table_ordem == 1:
            # Abre o arquivo e processa as linhas
            with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                # Le a linha e o cabecalho
                arquivo_txt_csv.readline()

                # Inicializa as listas para armazenamento das informacoes
                id_class_list = []
                Sclasse_list = []
                Mannclasse_list = []
                Rhclasse_list = []

                # Iterando sobre as linhas do arquivo
                for line in arquivo_txt_csv:
                    info = line.strip().split(',')
                    # Armazenando os valores das linhas nas suas respectivas variaveis
                    if info[0] != '' and info[1] != '' and info[2] != '' and info[3]:
                        if tb2 != 1:
                            indice = int(info[0])
                            Scla = float(info[1])
                            Mann = float(info[2])
                            Rh = float(info[3])

                        if tb2 == 1:
                            indice = int(info[0])
                            Scla = (info[1])
                            Mann = float(info[2])
                            Rh = float(info[3])

                        # Adiciona os valores as listas
                        id_class_list.append(indice)
                        Sclasse_list.append(Scla)
                        Mannclasse_list.append(Mann)
                        Rhclasse_list.append(Rh)

            # Atualiza no numero de linhas da tabela (recebe o numero de classes dos rios da bacia hidrografica)
            table.setRowCount(len(Mannclasse_list))

            # Coleta as dimensoes da tabela
            n_row = table.rowCount()
            n_column = table.columnCount()

            # Itera sobre os elementos da tabela
            for lin in range(n_row):
                for col in range(n_column):

                    if col == 0:
                        # Adiciona a coluna do id
                        item = QTableWidgetItem(str(int(id_class_list[lin])))
                        table.setItem(lin, col, item)
                    elif col == 1:
                        # Adiciona a coluna da declividade
                        item = QTableWidgetItem(str(Sclasse_list[lin]))
                        table.setItem(lin, col, item)
                    elif col == 2:
                        # Adiciona a coluna do coef de Manning
                        item = QTableWidgetItem(str(Mannclasse_list[lin]))
                        table.setItem(lin, col, item)
                    elif col == 3:
                        # Adiciona a coluna do raio hidraulico
                        item = QTableWidgetItem(str(Rhclasse_list[lin]))
                        table.setItem(lin, col, item)

        # Configura a segunda tabela
        else:
            # nao sei o motivo de nao ter funcionado para a segunda tabela. mas funcionou e deixei assim
            a = True

    def leh_geotiff_escreve_ascii(self, arquivo, arquivo2, int_float, mapa_classes='n'):
        '''Esta funcao realiza a leitura do arquivo .tif enviado pelo user e o converte em .rst tipo ascii para leitura no visual basic
            arquivo1 = diretorio do arquivo arquivo raster tiff
            arquivo2 = arquivo raster tipo rst ascii (sera criado)'''

        # Le o arquivo .tiff enviado
        raster_enviado = gdal.Open(arquivo)

        # Lendo os dados raster como um array
        dados_lidos = raster_enviado.GetRasterBand(1).ReadAsArray()

        # Tratamento de erro: verifica se o arquivo foi aberto corretamente
        if raster_enviado is not None:
            # Obtencao da dimensao da imagem raster
            self.rdc_vars.nlin = raster_enviado.RasterYSize
            self.rdc_vars.ncol = raster_enviado.RasterXSize
            self.rdc_vars.geotransform = raster_enviado.GetGeoTransform()
            self.rdc_vars.projection = raster_enviado.GetProjection()

            self.rdc_vars.resolucao = self.rdc_vars.geotransform[1]

            # Coordenadas da celula lin = 0, col = 0
            self.x_min = self.rdc_vars.geotransform[0]
            self.y_max = self.rdc_vars.geotransform[3]

            # Captura resolucoes espaciais da imagem (sentido vertical e horizontal)
            self.dx = self.rdc_vars.geotransform[1]
            self.dy = self.rdc_vars.geotransform[5]

            # Coordenadas do canto inferior direito
            self.x_max = self.x_min + (self.rdc_vars.ncol * self.dx)
            self.y_min = self.y_max + (self.rdc_vars.nlin * self.dy)

        # Leitura do arquivo ascii
        if int_float == 'int':
            with open(arquivo2, 'w') as arquivo_ascii:
                for lin in range(0, self.rdc_vars.nlin):
                    for col in range(0, self.rdc_vars.ncol):
                        arquivo_ascii.write(
                            f'{str(int(dados_lidos[lin,col]))}\n')

        elif int_float == 'float':
            with open(arquivo2, 'w') as arquivo_ascii:
                for lin in range(self.rdc_vars.nlin):
                    for col in range(self.rdc_vars.ncol):
                        arquivo_ascii.write(
                            f'{str(float(dados_lidos[lin,col]))}\n')

        arquivo2_doc = arquivo2.replace('.rst', '.rdc')
        with open(arquivo2_doc, 'w', encoding='utf-8') as arquivo_rdc:
            arquivo_rdc.write('Raster Informations\n')
            arquivo_rdc.write(f'Rows,{self.rdc_vars.nlin}\n')
            arquivo_rdc.write(f'Columns,{self.rdc_vars.ncol}\n')
            arquivo_rdc.write(
                f'resolution,{np.abs(self.rdc_vars.resolucao)}\n')
            arquivo_rdc.write(f'resolution (X),{self.dx}\n')
            arquivo_rdc.write(f'resolution (Y),{self.dy}\n')
            arquivo_rdc.write(f'Min_X,{self.x_min}\n')
            arquivo_rdc.write(f'Max_X,{self.x_max}\n')
            arquivo_rdc.write(f'Min_Y,{self.y_min}\n')
            arquivo_rdc.write(f'Max_Y,{self.y_max}\n')
            if mapa_classes == 'y':
                # Determina quantidade de classes
                qtd_classes = len(np.unique(dados_lidos[dados_lidos != 0]))
                arquivo_rdc.write(f'watershed_classes,{qtd_classes}\n')

    def leh_rst_escreve_geotiff(self, arquivo1, arquivo2, file_type):
        '''Esta funcao le os arquivos processados nas rotinas em visual basic, no formato .rst(ascii) e os escreve em geotiff (no diretorio informado)
            arquivo1 = diretorio do arquivo raster tipo rst ascii
            arquivo2 = arquivo raster tiff (sera criado)'''

        # Convertendo arquivo ascii para geotiff
        rst_to_raster = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))

        # Leitura do arquivo ascii
        if file_type == 'int':
            with open(arquivo1, 'r') as arquivo_ascii:
                for lin in range(self.rdc_vars.nlin):
                    for col in range(self.rdc_vars.ncol):
                        rst_to_raster[lin, col] = int(arquivo_ascii.readline())

        elif file_type == 'float':
            with open(arquivo1, 'r') as arquivo_ascii:
                for lin in range(self.rdc_vars.nlin):
                    for col in range(self.rdc_vars.ncol):
                        rst_to_raster[lin, col] = float(
                            arquivo_ascii.readline())

        # Define os dados a serem escritos
        if file_type == 'int':
            tipo_dados = gdalconst.GDT_Int32
        elif file_type == 'float':
            tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver para escrita do arquivo em GeoTiff
        fn_geotiff = arquivo2
        driver = gdal.GetDriverByName('GTiff')

        # Cria arquivo final
        dataset = driver.Create(
            fn_geotiff, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(rst_to_raster)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

    def leh_asc_to_np_array(self, arquivo1):
        '''Esta funcao le os arquivos processados nas rotinas em visual basic, no formato .rst(ascii) e os escreve em geotiff (no diretorio informado)
            arquivo1 = diretorio do arquivo raster tipo rst ascii
            arquivo2 = arquivo raster tiff (sera criado)'''
        # Convertendo arquivo ascii para um array numpy
        rst_to_raster = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        bobo = [0 for x in range(6)]

        # Leitura do arquivo ascii
        with open(arquivo1, 'r') as arquivo_ascii:
            for i in range(6):
                bobo[i] = arquivo_ascii.readline()
            for lin in range(self.rdc_vars.nlin):
                for col in range(self.rdc_vars.ncol):
                    rst_to_raster[lin, col] = float(arquivo_ascii.readline())

        return rst_to_raster

    def add_new_row(self, table):
        '''Esta funcao adiciona uma linha a uma tabela relecionada'''
        last_row = table.rowCount()
        table.insertRow(last_row)

    def delete_row(self, table):
        '''Esta funcao deleta uma linha de uma referida tabela'''
        selected_row = table.currentRow()
        if selected_row >= 0:
            table.removeRow(selected_row)
        else:
            QMessageBox.warning(None, "Warning", "You did not select any row.")

    def close_gui(self, function):
        '''Esta funcao e usada para torna nulo (limpar) as informacoes adicionadas nos diferentes objetos das funcoes do Q-Hidropixel
           - Function = 1 : Flow travel time
           - Function = 2 : Excess rainfall
           - Function = 3 : Flow routing'''

        if function == 1:
            self.dlg_flow_tt.close()
            self.save_result = False

        elif function == 2:
            self.save_result = False
            self.dlg_exc_rain.close()

        elif function == 3:
            self.save_result = False
            self.dlg_flow_rout.close()

    def clear_table(self, table, lineEdit):
        '''Esta funcao limpa os valores armazenados na respectiva tabela'''
        # Limpando as informacoes armazenadas: tables widgets
        nlin_tb1 = table.rowCount()
        ncol_tb1 = table.columnCount()

        # Reinicia a respectiva tabela
        for lin in range(nlin_tb1):
            for col in range(ncol_tb1):
                item = table.item(lin, col)
                if item is not None:
                    item.setText('')
        table.setRowCount(0)

        # Limpa a lineEdit
        lineEdit.clear()

    def adiciona_layer(self, file_path):
        '''Esta funcao adiciona um arquivo enviado as layers do atual projeto do usuario no QGIS'''
        # Adiciona o arquivo raster ao projeto do QGIS
        file_name = os.path.basename(file_path)
        layer = QgsRasterLayer(file_path, 'gdal')
        layer.setName(file_name)
        QgsProject.instance().addMapLayer(layer)

        # Atualiza a tela do QGIS
        self.iface.layerTreeView().refreshLayerSymbology(layer.id())

    def reginal_curve_condition(self):
        """Define estado dos outputs que depende do metodo das curvas regionais"""

        if self.dlg_flow_tt.groupBox_3.isChecked() == True:
            # River cros-sectional area
            self.dlg_flow_tt.ch_9_pg4.setEnabled(True)
            self.dlg_flow_tt.label_87.setEnabled(True)
            self.dlg_flow_tt.le_9_pg4.setEnabled(True)
            self.dlg_flow_tt.ch_20_pg4.setEnabled(True)
            self.dlg_flow_tt.tbtn_pg4_9.setEnabled(True)
            self.dlg_flow_tt.label_86.setEnabled(True)

            # River bankfull width
            self.dlg_flow_tt.ch_10_pg4.setEnabled(True)
            self.dlg_flow_tt.label_89.setEnabled(True)
            self.dlg_flow_tt.le_10_pg4.setEnabled(True)
            self.dlg_flow_tt.tbtn_pg4_10.setEnabled(True)
            self.dlg_flow_tt.label_88.setEnabled(True)
            self.dlg_flow_tt.ch_21_pg4.setEnabled(True)

        else:
            # River cros-sectional area
            self.dlg_flow_tt.ch_9_pg4.setEnabled(False)
            self.dlg_flow_tt.label_87.setEnabled(False)
            self.dlg_flow_tt.le_9_pg4.setEnabled(False)
            self.dlg_flow_tt.ch_20_pg4.setEnabled(False)
            self.dlg_flow_tt.tbtn_pg4_9.setEnabled(False)
            self.dlg_flow_tt.label_86.setEnabled(False)

            # River bankfull width
            self.dlg_flow_tt.ch_10_pg4.setEnabled(False)
            self.dlg_flow_tt.label_89.setEnabled(False)
            self.dlg_flow_tt.le_10_pg4.setEnabled(False)
            self.dlg_flow_tt.tbtn_pg4_10.setEnabled(False)
            self.dlg_flow_tt.label_88.setEnabled(False)
            self.dlg_flow_tt.ch_21_pg4.setEnabled(False)

    def rain_def_condition(self, rain_condition):
        '''Esta funcao verifica a condicao da variavel precipitacao para execucao da rotina Excess rainfall
           - rain_condition == 1 : areal averaged
           - rain_condition == 2 : spatiallu distributed'''

        if rain_condition == 1:
            # Objetos ligado a opcao de precipitacao media na area da baica ficam ativos
            self.dlg_exc_rain.le_3_pg2.setEnabled(True)
            self.dlg_exc_rain.label_31.setEnabled(True)
            self.dlg_exc_rain.tbtn_pg2_3.setEnabled(True)
            self.dlg_exc_rain.label_35.setEnabled(True)

            # Objetos ligado a opcao de precipitacao distribuida espacialmente ficam inativos
            self.dlg_exc_rain.le_4_pg2.setEnabled(False)
            self.dlg_exc_rain.label_32.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_4.setEnabled(False)
            self.dlg_exc_rain.label_36.setEnabled(False)

        elif rain_condition == 2:
            # Objetos ligado a opcao de precipitacao distribuida espacialmente ficam ativos
            self.dlg_exc_rain.le_4_pg2.setEnabled(True)
            self.dlg_exc_rain.label_32.setEnabled(True)
            self.dlg_exc_rain.tbtn_pg2_4.setEnabled(True)
            self.dlg_exc_rain.label_36.setEnabled(True)

            # Objetos ligado a opcao de precipitacao media na area da baica ficam inativos
            self.dlg_exc_rain.le_3_pg2.setEnabled(False)
            self.dlg_exc_rain.label_31.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_3.setEnabled(False)
            self.dlg_exc_rain.label_35.setEnabled(False)

    def cancel_log_page(self, text_edit, pg_parameters, pg_logge):
        '''Esta funcao configura o botao de cancelar da pagina de log'''
        mensagem_log1 = None
        # Cria texto formatado para adicionar ao text edit? mensagem de aviso
        mensagem_log1 = '<font>\nATTENTION: stopping FLOW TRAVEL TIME process...</font>'

        # Adiciona o texto formatado no QTextEdit
        text_edit.insertHtml(mensagem_log1)

        # Reativa a pagina de parametros
        pg_parameters.setEnabled(True)

        # Desativa a pagina de logge
        pg_logge.setEnabled(False)

    def cancel_rainfall_interpol(self):
        '''Esta configura o botao cancel da pagina run da funcao rainfall interpolation'''
        # Adiciona mensagem de cancelamento do processo
        self.dlg_rain_interpl_run.te_rain_int(
            'BREAKING THE RAINFALL INTERPOLATION PROCESSING...')
        self.dlg_rain_interpl_run.close()

    def apaga_arquivos_temp(self):
        '''Esta funcao exclui os arquivos temporarios criados durante a execucao do plugin'''
        # Muda para o diretorio temp
        os.chdir(self.diretorio_atual + r'\temp')
        # Obtem todos os arquivos com a extensao .txt, .rst, .rdc
        arquivos_txt = glob.glob('*.txt')
        arquivos_rst = glob.glob('*.rst')
        arquivos_rdc = glob.glob('*.rdc')
        arquivos_tif = glob.glob('*.tif')
        arquivos_bin = glob.glob('*.bin')

        # Apaga todos os arquivos
        for txt in arquivos_txt:
            os.remove(txt)

        for rst in arquivos_rst:
            os.remove(rst)

        for rdc in arquivos_rdc:
            os.remove(rdc)

        for tif in arquivos_tif:
            os.remove(tif)

        for bin in arquivos_bin:
            os.remove(bin)

    def apaga_arquivos_tv(self):
        '''Esta funcao exclui os arquivos temporarios criados durante a execucao do plugin'''
        # Muda para o diretorio temp
        os.chdir(self.diretorio_atual + r'\temp\tv_for_each_poi')
        # Obtem todos os arquivos com a extensao .txt, .rst, .rdc
        arquivos_rst = glob.glob('*.rst')
        arquivos_tif = glob.glob('*.tif')

        # Apaga todos os arquivos
        for rst in arquivos_rst:
            os.remove(rst)

        for tif in arquivos_tif:
            os.remove(tif)

    def apaga_arquivos_maps(self):
        '''Esta funcao exclui os arquivos temporarios criados durante a execucao do plugin'''
        # Muda para o diretorio temp
        os.chdir(self.diretorio_atual + r'\temp\maps')
        # Obtem todos os arquivos com a extensao .txt, .rst, .rdc
        arquivos_rst = glob.glob('*.rst')
        arquivos_txt = glob.glob('*.txt')
        arquivos_asc = glob.glob('*.asc')

        # Apaga todos os arquivos
        for rst in arquivos_rst:
            os.remove(rst)

        for txt in arquivos_txt:
            os.remove(txt)

        for asc in arquivos_asc:
            os.remove(asc)

    def apaga_arquivos_hydrographs(self):
        '''Esta funcao exclui os arquivos temporarios criados durante a execucao do plugin'''
        # Muda para o diretorio temp
        os.chdir(self.diretorio_atual + r'\temp\hydrographs')
        # Obtem todos os arquivos com a extensao .txt, .rst, .rdc
        arquivos_txt = glob.glob('*.txt')
        arquivos_tif = glob.glob('*.tif')

        # Apaga todos os arquivos
        for txt in arquivos_txt:
            os.remove(txt)

    def apaga_arquivos_tv_for_each_poi(self):
        '''Esta funcao exclui os arquivos temporarios criados durante a execucao do plugin'''
        # Muda para o diretorio temp
        os.chdir(self.diretorio_atual + r'\temp\tv_for_each_poi')
        # Obtem todos os arquivos com a extensao .txt, .rst, .rdc
        arquivos_txt = glob.glob('*.txt')
        arquivos_rdc = glob.glob('*.rdc')
        arquivos_rst = glob.glob('*.rst')
        arquivos_hpx = glob.glob('*.hpx')

        # Apaga todos os arquivos
        for txt in arquivos_txt:
            os.remove(txt)
        for rdc in arquivos_rdc:
            os.remove(rdc)
        for rst in arquivos_rst:
            os.remove(rst)
        for hpx in arquivos_hpx:
            os.remove(hpx)

    def replace_tif_rst(self, arquivo1):
        '''Esta funcao modifica a extensao do parametro de .tif para .rst'''
        arquivo2 = arquivo1.replace('.tif', '.rst')
        return arquivo2

    def is_basename_only(self, path_or_name):
        return path_or_name == os.path.basename(path_or_name)

    def caminho_completo(self, working_folder, lineEditVal):
        is_basename = self.is_basename_only(lineEditVal)
        if is_basename:
            return os.path.join(working_folder, lineEditVal)
        return lineEditVal

    def define_extensao_hpx(self, caminho):
        base, ext = os.path.splitext(caminho)
        if ext == '':
            caminho = caminho + '.hpx'
        return caminho

    def run_process_rainfall_interpol(self):
        """Esta funcao configura a execucao da rotina Rainfall Interpolation do vb.net, gerando os arquivos necessarios a execucao daquela"""
        # Captura diretorio dos arquivo txt (pasta temp)
        direct_temp = self.diretorio_atual + r'\temp'

        # Chama funcoes para tranformacao do raster em geotiff para rst tipo ascii
        bacia_file = direct_temp + r'\Watershed.rst'
        self.leh_geotiff_escreve_ascii(
            self.dlg_exc_rain.cb_1_pg_ri.currentLayer().source(), bacia_file, 'int')

        # Cria uma copia dos arquivos para a pasta temp: evita erros relacionados aos caracteries especiais
        rain_gauges = direct_temp + r'\rain_gauges.txt'
        shutil.copy(self.dlg_exc_rain.le_2_pg_ri.text(), rain_gauges)

        rainfall_data = direct_temp + r'\rainfall_data.txt'
        shutil.copy(self.dlg_exc_rain.le_3_pg_ri.text(), rainfall_data)

        # Escreve arquivo txt com os diretorios e nome dos inputs enviados pelo user
        direct_in_files = direct_temp + r'\input_files_config_rain_inte.txt'
        with open(direct_in_files, 'w', encoding='utf-8') as arquivo_txt:
            # Escreve cabecalho
            arquivo_txt.write("Selected input file directory\n")
            arquivo_txt.write(f"watershed,{bacia_file}\n")
            arquivo_txt.write(f"rain_gauges,{rain_gauges}\n")
            arquivo_txt.write(f"rainfall_data,{rainfall_data}\n")
            arquivo_txt.write(f"map_condiction,{self.map_cond}")

        # Organiza os caminhos dos arquivos de saida enviados pelo user: modifica a extensao de .tif para .rst
        self.output1_ri = direct_temp + r'\rainfall_interpolated.bin'
        map_output_path = direct_temp + r'\maps'

        # Escreve aquivo txt contendo o diretorio informado pelo user: sera fornecido para a rotina em visual basic
        direct_out_files = direct_temp + r'\output_files_config_rain_inte.txt'
        with open(direct_out_files, 'w', encoding='utf-8') as arquivo_txt:
            arquivo_txt.write("Select output file directory\n")
            arquivo_txt.write(
                f"rainfall_interpolated_file,{self.output1_ri}\n")
            arquivo_txt.write(
                f"rainfall_interpolated_maps_path,{map_output_path}")

    def run_rainfall_interpolation(self, condicao):
        """Esta estrutura a ordem de execucao da rontina que gera a chuva interpolada por pixel da bacia hidrografica"""
        self.map_cond = condicao
        self.run_process_rainfall_interpol()
        self.apaga_arquivos_maps()
        # Chama executavel vb para iniciar o processamento
        rainfall_interpol_vb = self.diretorio_atual + r'\temp\rainfall_interpolation.exe'
        rainfall_iterp_exe = subprocess.run([rainfall_interpol_vb])

        # verifica se houve algum erro no processamento das rotinas no vb ou se o usuario clicou em cancelar
        # Caso nao, a execucao continua no python
        if rainfall_iterp_exe.returncode == 0:

            # Se o usuario escolheu a opcao para gerar o arquivo da chuva interpolada em txt, ele sera salvo no caminho fornecido
            if self.map_cond == 0 and os.path.isfile(self.output1_ri) == True:
                output_fin = self.caminho_completo(
                    self.dlg_exc_rain.le_3_pg1.text(), self.dlg_exc_rain.le_4_pg_ri.text())
                shutil.move(self.output1_ri,
                            output_fin)

                QMessageBox.information(
                    None, "Information", "Operation completed successfully!", )

            # Se o usuario escolheu para gerar os mapas da precipitacao interpolada, eles serao enviados para a pasta informada
            elif self.map_cond == 1:
                # Chama funcao para gerar o video a partir dos mapas gerados
                # create_precip_video(input_dir=self.diretorio_atual + r'\temp\maps',
                #                     output_path=self.dlg_exc_rain.le_5_pg_ri.text())

                QMessageBox.information(
                    None, "Information", "Operation completed successfully!", )

            else:
                QMessageBox.information(
                    None, "Information", "The Hidropixel process has been canceled!", )

        else:
            QMessageBox.information(
                None, "Information", "There was an inconsistency, please verify if all files were sent!", )

    def processa_arquivo_chuva_med(self, input_file, output_file):
        # Le todo o conteudo do arquivo
        with open(input_file, 'r', encoding='utf-8') as f:
            linhas = f.readlines()

        # Verifica se o arquivo nao esta vazio
        if not linhas:
            raise Exception("Arquivo vazio!")

        # A primeira linha e o cabecalho
        cabecalho = linhas[0].strip()

        # Linhas de dados (excluindo o cabecalho)
        dados = [linha.strip() for linha in linhas[1:] if linha.strip()]

        # Numero de linhas de dados
        num_linhas = len(dados)

        # Calcula o delta_t a partir das duas primeiras linhas de dados
        # Supondo que o arquivo esteja formatado como "Time(min),Rainfall(mm)"
        if num_linhas >= 2:
            primeiro_valor = float(dados[0].split(',')[0])
            segundo_valor = float(dados[1].split(',')[0])
            delta_t = segundo_valor - primeiro_valor
        else:
            delta_t = 0  # ou lanca excecao, caso seja necessario

        # Escreve o novo arquivo com a primeira linha contendo "num_linhas,delta_t"
        with open(output_file, 'w', encoding='utf-8') as f_out:
            f_out.write(f"{num_linhas},{int(delta_t)}\n")
            f_out.write(cabecalho + "\n")
            for linha in dados:
                f_out.write(linha + "\n")

    def gera_exu_shp_txt(self):
        """Esta funcao le o arquivo shp com os POIs e gera a linha e coluna de cada ponto com base na matriz da bacia hidrografica"""
        # Abrir shapefile
        ds_shp = ogr.Open(
            self.dlg_flow_tt.cb_8_pg2.currentLayer().source())
        layer = ds_shp.GetLayer()
        gt = self.rdc_vars.geotransform

        # Resultado
        exutorios_pix = {}

        for feature in layer:
            id_exu = feature.GetField("id")
            geom = feature.GetGeometryRef()
            x, y = geom.GetX(), geom.GetY()

            # Conversao considerando centro do pixel
            col = int((x - gt[0]) / gt[1])
            lin = int((y - gt[3]) / gt[5])

            exutorios_pix[id_exu] = (lin, col)
        # Exibir resultado
        exutorio_txt = self.diretorio_atual + r'\temp' + r'\exutorios.txt'
        with open(exutorio_txt, 'w') as file:
            file.write(str(len(exutorios_pix))+"\n")
            file.write("lin,col\n")
            for id_exu, (lin, col) in exutorios_pix.items():
                file.write(f"{lin},{col}\n")

    def converte_tv_sub_POI_tif(self):
        """Converte os arquivos ascii com o TV e sub-bacia para cada POI. A funcao tambem salva os arquivos na pasta envia pelo user"""
        exu_path = self.diretorio_atual + r'\temp' + r'\tv_for_each_poi'
        os.chdir(exu_path)
        tvs = glob.glob('*.rst')
        rst_to_raster = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        cont = 0
        for tv in tvs:
            tv_basename = os.path.basename(tv)
            tv_tif = self.dlg_flow_tt.le_13_pg4.text() + f"\{tv_basename}.tif"
            # Chama funcao que leh rst e escreve geotif
            if 'travel' in tv_basename:
                self.leh_rst_escreve_geotiff(tv, tv_tif, 'float')
            else:
                self.leh_rst_escreve_geotiff(tv, tv_tif, 'int')

    def run_process_excess_rainfall(self):
        """Esta funcao organiza os arquivos enviados pelo user e os configura para serem lidos nas rotinas em visual basic"""
        # Captura diretorio dos arquivo txt (pasta temp)
        direct_temp = self.diretorio_atual + r'\temp'

        # Chama funcoes para tranformacao do raster em geotiff para rst tipo ascii

        # leh bacia tif gera bacia rst ascii
        bacia_file = direct_temp + r'\Watershed.rst'
        self.leh_geotiff_escreve_ascii(
            self.dlg_exc_rain.cb_1_pg2.currentLayer().source(), bacia_file, 'int')

        # leh cn map tif gera cn map rst ascii
        cn_file = direct_temp + r'\CN_map.rst'
        self.leh_geotiff_escreve_ascii(
            self.dlg_exc_rain.cb_2_pg2.currentLayer().source(), cn_file, 'float')

        # move arquivo da precipitacao para a pasta temp
        if self.dlg_exc_rain.rb_1_pg1.isChecked():
            chuva_media = direct_temp + r'\Areal_averaged_rainfall.txt'
            self.processa_arquivo_chuva_med(
                self.dlg_exc_rain.le_3_pg2.text(), chuva_media)

        if self.dlg_exc_rain.rb_2_pg1.isChecked():
            chuva_distribuida = direct_temp + r'\Spatially_distributed_rainfall.bin'
            shutil.copy(self.dlg_exc_rain.le_4_pg2.text(), chuva_distribuida)

        # Escreve arquivos de parametros
        direct_parameters = direct_temp + r'\parameters_exc_rainf.txt'
        with open(direct_parameters, 'w', encoding='utf-8') as arquivo_txt:
            arquivo_txt.write(
                f"Initial abstraction (λ),{self.dlg_exc_rain.le_1_pg1.text()}")

        # gera arquivo contendo os diretorios dos inputs
        direct_in_files = direct_temp + r'\input_files_config_exc_rainf.txt'
        with open(direct_in_files, 'w', encoding='utf-8') as arquivo_txt:
            # Escreve cabecalho
            arquivo_txt.write("Selected input file directory\n")
            arquivo_txt.write(
                f'{1 if self.dlg_exc_rain.cb_1_pg2.currentText() !="" else 0},watershed,{bacia_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_exc_rain.cb_2_pg2.currentText() !="" else 0},curve_number_map,{cn_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_exc_rain.le_3_pg2.text() !="" else 0},Areal_averaged_rainfall,{chuva_media if self.dlg_exc_rain.rb_1_pg1.isChecked() == True else ""}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_exc_rain.le_4_pg2.text() !="" else 0},Spatially_distributed_rainfall,{chuva_distribuida if self.dlg_exc_rain.rb_2_pg1.isChecked() == True else ""}\n')
            arquivo_txt.write(f'{1},parameters,{direct_parameters}\n')

        # Escreve aquivos de saida
        self.output1_exec_rain = direct_temp + r'\Map_of_watershed_pixels_ID.rst'
        self.output2_exec_rain = direct_temp + \
            r'\Map_of_maximum_potential_retention.rst'
        self.output3_exec_rain = direct_temp + r'\Map_of_initial_abstraction.rst'
        self.output4_exec_rain = direct_temp + r'\Map_of_total_rainfall.rst'
        self.output5_exec_rain = direct_temp + r'\Map_of_total_excess_rainfall.rst'
        self.output6_exec_rain = direct_temp + r'\Excess_hyetographs_per_pixel.bin'

        direct_out_files = direct_temp + r'\output_files_config_exc_rainf.txt'
        with open(direct_out_files, "w", encoding="utf-8") as arquivo_txt:
            arquivo_txt.write("Select output file directory\n")
            arquivo_txt.write(
                f"{1 if self.dlg_exc_rain.ch_1_pg4.isChecked() == True else 0},Map of watershed pixels ID,{self.output1_exec_rain}\n")
            arquivo_txt.write(
                f"{1 if self.dlg_exc_rain.ch_2_pg4.isChecked() == True else 0},Map of maximum potential retention (mm),{self.output2_exec_rain}\n")
            arquivo_txt.write(
                f"{1 if self.dlg_exc_rain.ch_3_pg4.isChecked() == True else 0},Map of initial abstraction (mm),{self.output3_exec_rain}\n")
            arquivo_txt.write(
                f"{1 if self.dlg_exc_rain.ch_4_pg4.isChecked() == True else 0},Map of total rainfall (mm),{self.output4_exec_rain}\n")
            arquivo_txt.write(
                f"{1 if self.dlg_exc_rain.ch_5_pg4.isChecked() == True else 0},Map of total excess rainfall (mm),{self.output5_exec_rain}\n")
            arquivo_txt.write(
                f"{1 if self.dlg_exc_rain.ch_6_pg4.isChecked() == True else 0},Excess hyetographs per pixel (mm),{self.output6_exec_rain}")

    def run_excess_rainfall(self):
        '''Esta funcao ativa a pagina de log e configura a ordem de execucao das funcoes para o calculo da chuva excedente'''
        # Ativiva a pagina de log e limpa as informacoes passadas no text_edit
        mensagem_log1 = None
        self.dlg_exc_rain.tabWidget.setCurrentIndex(1)
        self.dlg_exc_rain.pg_log_exc_rain.setEnabled(True)
        self.dlg_exc_rain.te_logg.clear()

        # Configura a progressbar
        self.dlg_exc_rain.progressBar.setRange(0, 100)
        self.dlg_exc_rain.progressBar.setValue(0)
        self.dlg_exc_rain.progressBar.setValue(5)

        # Validation gate: require data validation to be executed and passed
        try:
            if not ensure_validations_pass(self, module=2, parent=self.dlg_exc_rain):
                # revert UI state and abort
                self.dlg_exc_rain.progressBar.setValue(0)
                self.dlg_exc_rain.pg_log_exc_rain.setEnabled(False)
                return
        except Exception:
            # If validation gate fails unexpectedly, block execution
            self.dlg_exc_rain.progressBar.setValue(0)
            self.dlg_exc_rain.pg_log_exc_rain.setEnabled(False)
            QMessageBox.critical(self.dlg_exc_rain, 'Validation Gate',
                                 'Unexpected error while checking validations.')
            return

        # Configura as informacoes do textEdit da referida pagina
        font = QFont()
        font.setPointSize(11)
        version_info = {
            "QGIS Version": '3.28.0-Firenze',
            "Qt Version": '5.15.3',
            "Python Version": '3.9.5',
            "GDAL Version": '3.8.0'}

        datatime_started = datetime.now().isoformat()
        mensagem_log1 = "The plugin was developed with:\n"
        mensagem_log1 += f"QGIS Version: {version_info['QGIS Version']}\n"
        mensagem_log1 += f"Qt Version: {version_info['Qt Version']}\n"
        mensagem_log1 += f"Python Version: {version_info['Python Version']}\n"
        mensagem_log1 += f"GDAL Version: {version_info['GDAL Version']}\n"
        mensagem_log1 += "--------------------------------------------------------\n"
        mensagem_log1 += f"Algorithm started at: {datatime_started}\n"
        mensagem_log1 += "--------------------------------------------------------\n"
        self.dlg_exc_rain.progressBar.setValue(10)
        # Cria condicao de parada da execucao: se o usuario clicar no botao cancel da pagina de log
        while True:
            # Metodo usado para permitir a iteracao do usuario enquanto o programa esta em execucao
            QApplication.processEvents()
            self.dlg_exc_rain.btn_cancel_log.clicked.connect(lambda: self.cancel_log_page(
                self.dlg_exc_rain.te_logg, self.dlg_exc_rain.pg_par_exc_rain, self.dlg_exc_rain.pg_log_exc_rain))

            # Se nao existir erros nas informacoes enviadas, sera mostrada a pagina de log e o programa sera executado
            self.dlg_exc_rain.pg_par_exc_rain.setEnabled(False)

            # Adiciona as mensagem de log ao text edit e configura a funcao run
            self.dlg_exc_rain.te_logg.append(mensagem_log1)
            for cont in range(1, 26):
                self.dlg_exc_rain.progressBar.setValue(cont)

            # Chama funcao que cria arquivos necessarios as rotinas em vb
            self.run_process_excess_rainfall()
            self.dlg_exc_rain.progressBar.setValue(40)

            # Chama executavel vb para iniciar o processamento
            exc_rain_vb = self.diretorio_atual + r'\temp\excess_rainfall.exe'
            exc_rain_exe = subprocess.run([exc_rain_vb])

            # verifica se houve algum erro no processamento das rotinas no vb ou se o usuario clicou em cancelar
            # Caso nao, a execucao continua no python
            if exc_rain_exe.returncode == 0:
                self.dlg_exc_rain.progressBar.setValue(60)

                # move o arquivo txt contendo o hietograma de chuva excedente para o diretorio informado
                if self.dlg_exc_rain.ch_6_pg4.isChecked() and os.path.isfile(self.output6_exec_rain) == True:
                    # Verifica se o user enviou o diretorio do arquivo ou apenas o nome (nesse caso, working folder != '')
                    is_basename = self.is_basename_only(
                        self.dlg_exc_rain.le_6_pg4.text())

                    # Se for apenas basename, concatena working folder com valor informado (deve ter extensao)
                    if is_basename == True:
                        output_file = os.path.join(
                            self.dlg_exc_rain.le_3_pg1.text(), self.dlg_exc_rain.le_6_pg4.text())
                        shutil.move(self.output6_exec_rain, output_file)
                    else:
                        shutil.move(self.output6_exec_rain,
                                    self.dlg_exc_rain.le_6_pg4.text())

                    # Converte arquivos de saida de .rst ascii para geotif
                    if os.path.isfile(self.output4_exec_rain) == True and os.path.isfile(self.output5_exec_rain) == True:
                        if self.dlg_exc_rain.ch_1_pg4.isChecked():
                            output_path = self.caminho_completo(
                                self.dlg_exc_rain.le_3_pg1.text(), self.dlg_exc_rain.le_1_pg4.text())
                            self.leh_rst_escreve_geotiff(
                                self.output1_exec_rain, output_path, 'int')

                        if self.dlg_exc_rain.ch_2_pg4.isChecked():
                            output_path = self.caminho_completo(
                                self.dlg_exc_rain.le_3_pg1.text(), self.dlg_exc_rain.le_2_pg4.text())
                            self.leh_rst_escreve_geotiff(
                                self.output2_exec_rain, output_path, 'float')

                        if self.dlg_exc_rain.ch_3_pg4.isChecked():
                            output_path = self.caminho_completo(
                                self.dlg_exc_rain.le_3_pg1.text(), self.dlg_exc_rain.le_3_pg4.text())
                            self.leh_rst_escreve_geotiff(
                                self.output3_exec_rain, output_path, 'float')

                        if self.dlg_exc_rain.ch_4_pg4.isChecked():
                            output_path = self.caminho_completo(
                                self.dlg_exc_rain.le_3_pg1.text(), self.dlg_exc_rain.le_4_pg4.text())
                            self.leh_rst_escreve_geotiff(
                                self.output4_exec_rain, output_path, 'float')

                        if self.dlg_exc_rain.ch_5_pg4.isChecked():
                            output_path = self.caminho_completo(
                                self.dlg_exc_rain.le_3_pg1.text(), self.dlg_exc_rain.le_5_pg4.text())
                            self.leh_rst_escreve_geotiff(
                                self.output5_exec_rain, output_path, 'float')

                        # Atualiza progressBar
                        self.dlg_exc_rain.progressBar.setValue(80)

                        # Adiciona layers ao QGIS
                        if self.dlg_exc_rain.ch_7_pg4.isChecked():
                            layer_path = self.caminho_completo(
                                self.dlg_exc_rain.le_3_pg1.text(), self.dlg_exc_rain.le_1_pg4.text())
                            self.adiciona_layer(layer_path)

                        if self.dlg_exc_rain.ch_8_pg4.isChecked():
                            layer_path = self.caminho_completo(
                                self.dlg_exc_rain.le_3_pg1.text(), self.dlg_exc_rain.le_2_pg4.text())
                            self.adiciona_layer(layer_path)

                        if self.dlg_exc_rain.ch_9_pg4.isChecked():
                            layer_path = self.caminho_completo(
                                self.dlg_exc_rain.le_3_pg1.text(), self.dlg_exc_rain.le_3_pg4.text())
                            self.adiciona_layer(layer_path)

                        if self.dlg_exc_rain.ch_10_pg4.isChecked():
                            layer_path = self.caminho_completo(
                                self.dlg_exc_rain.le_3_pg1.text(), self.dlg_exc_rain.le_4_pg4.text())
                            self.adiciona_layer(layer_path)

                        if self.dlg_exc_rain.ch_11_pg4.isChecked():
                            layer_path = self.caminho_completo(
                                self.dlg_exc_rain.le_3_pg1.text(), self.dlg_exc_rain.le_5_pg4.text())
                            self.adiciona_layer(layer_path)

                        # Adiciona as informacao ao text edit
                        self.dlg_exc_rain.te_logg.append(
                            'Operation completed successfully!')
                        QMessageBox.information(
                            None, "Information", "Operation completed successfully!", )
                        self.dlg_exc_rain.progressBar.setValue(100)
                        self.dlg_exc_rain.pg_log_exc_rain.setEnabled(False)
                        self.dlg_exc_rain.pg_par_exc_rain.setEnabled(True)
                        self.dlg_exc_rain.te_logg.clear()
                        break
                else:
                    # Finaliza execucao do programa e elimina os arquivos temporarios criados
                    self.apaga_arquivos_temp()
                    self.dlg_exc_rain.progressBar.setValue(0)
                    self.dlg_exc_rain.te_logg.clear()
                    self.dlg_exc_rain.pg_par_exc_rain.setEnabled(True)
                    self.dlg_exc_rain.pg_log_exc_rain.setEnabled(False)
                    end_msg = "The Hidropixel process has been canceled... Take a breath and go back to work!"
                    self.dlg_exc_rain.te_logg.append(end_msg)
                    break

    def run_process_flow_tt(self):
        """Esta funcao configura a escrita dos arquivos txt para integracao com a linguagem visual basic"""

        # Captura diretorio dos arquivo txt (pasta temp)
        direct_temp = self.diretorio_atual + r'\temp'

        # Escreve txt contendo codigo de direcoes de fluxo
        flow_directions_code = direct_temp + r'\flow_directions_code.txt'
        with open(flow_directions_code, 'w', encoding='utf-8') as arquivo_txt:
            # Escreve cabecalho
            arquivo_txt.write('Flow Directions Code\n')
            arquivo_txt.write(f'A,{self.dlg_flow_tt.le_5_pg1.text()}\n')
            arquivo_txt.write(f'B,{self.dlg_flow_tt.le_6_pg1.text()}\n')
            arquivo_txt.write(f'C,{self.dlg_flow_tt.le_7_pg1.text()}\n')
            arquivo_txt.write(f'D,{self.dlg_flow_tt.le_8_pg1.text()}\n')
            arquivo_txt.write(f'E,{self.dlg_flow_tt.le_9_pg1.text()}\n')
            arquivo_txt.write(f'F,{self.dlg_flow_tt.le_10_pg1.text()}\n')
            arquivo_txt.write(f'G,{self.dlg_flow_tt.le_11_pg1.text()}\n')
            arquivo_txt.write(f'H,{self.dlg_flow_tt.le_12_pg1.text()}')

        # Escreve arquivo txt contento os parametros do modelo
        parameters_file = direct_temp + r'\parameters_flow_tt.txt'
        with open(parameters_file, 'w', encoding='utf-8') as arquivo_txt:
            arquivo_txt.write('Regional curve method is checked,')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.groupBox_3.isChecked() == True else 0}\n')
            arquivo_txt.write(
                f'Manning coefficient for river segments without cross-section information,{self.dlg_flow_tt.le_14_pg1.text()}\n')
            arquivo_txt.write(f'Sheet flow lenght (m),30.48\n')
            arquivo_txt.write(
                f'P24 - Rainfall depth for 24-hour duration and 2-year return period (mm),{self.dlg_flow_tt.le_11_pg2.text()}\n')
            arquivo_txt.write(f'Mean depth of lake or reservoir (m),5\n')
            arquivo_txt.write(
                f'Regional curve coefficient c,{self.dlg_flow_tt.le_16_pg1.text()}\n')
            arquivo_txt.write(
                f'Regional curve coefficient d,{self.dlg_flow_tt.le_17_pg1.text()}\n')
            arquivo_txt.write(
                f'Regional curve coefficient g,{self.dlg_flow_tt.le_18_pg1.text()}\n')
            arquivo_txt.write(
                f'Regional curve coefficient h,{self.dlg_flow_tt.le_19_pg1.text()}\n')
            arquivo_txt.write(
                f'Maximum river segment lenght for river segments without cross-section information (m),{self.dlg_flow_tt.le_15_pg1.text()}\n')
            arquivo_txt.write(
                f'Minimum slope,{self.dlg_flow_tt.le_1_pg1.text()}')

        # Escreve arquivos contendo as informacoes das tabelas referentes aos segmentos homogeneos da rede de drenagem e das caracteristicas do uso e cobertura do solo
        if self.dlg_flow_tt.le_8_pg2.text() != '' or self.dlg_flow_tt.tbw_1_pg2.rowCount() != 0:
            self.save_table_to_file(1)

        self.save_table_to_file(2)

        # Chama funcoes para tranformacao do raster em geotiff para rst tipo ascii
        bacia_file = direct_temp + r'\Watershed.rst'
        self.leh_geotiff_escreve_ascii(
            self.dlg_flow_tt.cb_1_pg2.currentLayer().source(), bacia_file, 'int')

        dem_file = direct_temp + r'\DEM.rst'
        self.leh_geotiff_escreve_ascii(
            self.dlg_flow_tt.cb_2_pg2.currentLayer().source(), dem_file, 'float')

        Flow_Dir_file = direct_temp + r'\Flow_dir.rst'
        self.leh_geotiff_escreve_ascii(
            self.dlg_flow_tt.cb_3_pg2.currentLayer().source(), Flow_Dir_file, 'int')

        drainage_file = direct_temp + r'\drainage.rst'
        self.leh_geotiff_escreve_ascii(
            self.dlg_flow_tt.cb_4_pg2.currentLayer().source(), drainage_file, 'int')

        if self.dlg_flow_tt.cb_5_pg2.currentText() != '':
            river_segments_file = direct_temp + r'\river_segments.rst'
            self.leh_geotiff_escreve_ascii(
                self.dlg_flow_tt.cb_5_pg2.currentLayer().source(), river_segments_file, 'int')
        else:
            river_segments_file = 'No file'

        DA_km2_file = direct_temp + r'\DA_km2.rst'
        self.leh_geotiff_escreve_ascii(
            self.dlg_flow_tt.cb_6_pg2.currentLayer().source(), DA_km2_file, 'float')

        LULC_file = direct_temp + r'\LULC.rst'
        self.leh_geotiff_escreve_ascii(
            self.dlg_flow_tt.cb_7_pg2.currentLayer().source(), LULC_file, 'int')

        # Escreve arquivo txt com os diretorios e nome dos inputs enviados pelo user
        direct_in_files = direct_temp + r'\input_files_config_flow_tt.txt'
        with open(direct_in_files, 'w', encoding='utf-8') as arquivo_txt:
            # Escreve cabecalho
            arquivo_txt.write("Selected input file directory\n")
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_1_pg2.currentText() !="" else 0},watershed,{bacia_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_2_pg2.currentText() !="" else 0},DEM,{dem_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_3_pg2.currentText() !="" else 0},Flow_Dir,{Flow_Dir_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_6_pg2.currentText() !="" else 0},DA_km2,{DA_km2_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_4_pg2.currentText() !="" else 0},drainage,{drainage_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_5_pg2.currentText() !=""  else 0},river_segments,{river_segments_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_5_pg2.currentText() !="" else 0},segment_characteristics,{self.file_name_tb1}\n')
            # Arquivo obrigatorio, condicao apenas para manter o padrao e controle
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_7_pg2.currentText() !="" else 0},LULC,{LULC_file}\n')
            # Arquivo obrigatorio, condicao apenas para manter o padrao e controle
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.cb_1_pg2.currentText() !="" else 0},surface_roughness,{self.file_name_tb2}\n')
            arquivo_txt.write(f'{0},reservoirs,\n')
            # Arquivo obrigatorio, condicao apenas para manter o padrao e controle
            arquivo_txt.write(f'{1},parameters,{parameters_file}')

        # Funcao que gera txt com os as coodenadas (lin,col) dos POIs
        if (self.dlg_flow_tt.cb_8_pg2.currentText() != '' or self.dlg_flow_tt.cb_8_pg2.currentText() != None) and self.dlg_flow_tt.ch_12_pg4.isChecked() == True:
            self.gera_exu_shp_txt()
        else:
            with open(direct_temp + r'\exutorios.txt', 'w') as file:
                file.write("0")

        # Organiza os caminhos dos arquivos de saida enviados pelo user: modifica a extensao de .tif para .rst
        self.output1_flow_tt = direct_temp + r'\Slope.rst'
        self.output2_flow_tt = direct_temp + r'\river_segments.rst'
        self.output3_flow_tt = direct_temp + r'\Hydraulic_radius-roughness_and_slope.txt'
        self.output4_flow_tt = direct_temp + r'\River_cross-sectional_area.rst'
        self.output5_flow_tt = direct_temp + r'\River_bankfull_width.rst'
        self.output6_flow_tt = direct_temp + r'\Flow_travel_time.rst'

        # Escreve aquivo txt contendo o diretorio informado pelo user: sera fornecido para a rotina em visual basic
        direct_out_files = direct_temp + r'\output_files_config_flow_tt.txt'
        with open(direct_out_files, 'w', encoding='utf-8') as arquivo_txt:
            arquivo_txt.write("Select output file directory\n")
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.ch_6_pg4.isChecked() == True else 0},Slope,{self.output1_flow_tt}\n')  # rst
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.ch_7_pg4.isChecked() == True else 0},river_segments,{self.output2_flow_tt}\n')  # rst
            # txt: gerado diretamente nas rotinas vb
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.ch_8_pg4.isChecked() == True else 0},Hydraulic_radius-roughness_and_slope,{self.output3_flow_tt}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.ch_9_pg4.isChecked() == True else 0},River_cross-sectional_area,{self.output4_flow_tt}\n')  # rst
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.ch_10_pg4.isChecked() == True else 0},River_bankfull_width,{self.output5_flow_tt}\n')  # rst
            arquivo_txt.write(
                f'{1 if self.dlg_flow_tt.ch_11_pg4.isChecked() == True else 0},Flow_travel_time,{self.output6_flow_tt}')  # rst

    def run_flow_tt(self):
        '''Esta funcao ativa a pagina de log e configura a ordem de execucao das funcoes para o calculo do tempo de viagem'''
        # Ativiva a pagina de log e limpa as informacoes passadas no text_edit
        mensagem_log1 = None
        self.dlg_flow_tt.tabWidget.setCurrentIndex(1)
        self.dlg_flow_tt.pg_log_ftt.setEnabled(True)
        self.dlg_flow_tt.te_logg.clear()

        # Configura a progressbar
        self.dlg_flow_tt.progressBar.setRange(0, 100)
        self.dlg_flow_tt.progressBar.setValue(0)
        self.dlg_flow_tt.progressBar.setValue(5)

        # Validation gate: require data validation to be executed and passed
        try:
            if not ensure_validations_pass(self, module=1, parent=self.dlg_flow_tt):
                # revert UI state and abort
                self.dlg_flow_tt.progressBar.setValue(0)
                self.dlg_flow_tt.pg_log_ftt.setEnabled(False)
                return
        except Exception:
            self.dlg_flow_tt.progressBar.setValue(0)
            self.dlg_flow_tt.pg_log_ftt.setEnabled(False)
            QMessageBox.critical(self.dlg_flow_tt, 'Validation Gate',
                                 'Unexpected error while checking validations.')
            return

        # Configura as informacoes do textEdit da referida pagina
        font = QFont()
        font.setPointSize(11)
        version_info = {
            "QGIS Version": '3.28.0-Firenze',
            "Qt Version": '5.15.3',
            "Python Version": '3.9.5',
            "GDAL Version": '3.8.0'}

        datatime_started = datetime.now().isoformat()
        mensagem_log1 = "The plugin was developed with:\n"
        mensagem_log1 += f"QGIS Version: {version_info['QGIS Version']}\n"
        mensagem_log1 += f"Qt Version: {version_info['Qt Version']}\n"
        mensagem_log1 += f"Python Version: {version_info['Python Version']}\n"
        mensagem_log1 += f"GDAL Version: {version_info['GDAL Version']}\n"
        mensagem_log1 += "--------------------------------------------------------\n"
        mensagem_log1 += f"Algorithm started at: {datatime_started}\n"
        mensagem_log1 += "--------------------------------------------------------\n"
        self.dlg_flow_tt.progressBar.setValue(10)

        # Cria condicao de parada da execucao: se o usuario clicar no botao cancel da pagina de log
        while True:
            # Metodo usado para permitir a iteracao do usuario enquanto o programa esta em execucao
            QApplication.processEvents()
            self.dlg_flow_tt.btn_cancel_log.clicked.connect(lambda: self.cancel_log_page(
                self.dlg_flow_tt.te_logg, self.dlg_flow_tt.pg_par_ftt, self.dlg_flow_tt.pg_log_ftt))

            # Verifica a existencia de incoerencias nas informacoes (direcoes de fluxo) fornecidas pelo usuario
            list_line_edit_value_pg1 = [self.dlg_flow_tt.le_5_pg1.text(),
                                        self.dlg_flow_tt.le_6_pg1.text(),
                                        self.dlg_flow_tt.le_7_pg1.text(),
                                        self.dlg_flow_tt.le_8_pg1.text(),
                                        self.dlg_flow_tt.le_9_pg1.text(),
                                        self.dlg_flow_tt.le_10_pg1.text(),
                                        self.dlg_flow_tt.le_11_pg1.text(),
                                        self.dlg_flow_tt.le_12_pg1.text()
                                        ]
            duplicate = []
            # Verifica se ha duplicatas no codigo
            for i in range(len(list_line_edit_value_pg1)):
                for j in range(i+1, len(list_line_edit_value_pg1)):
                    if list_line_edit_value_pg1[i] == list_line_edit_value_pg1[j]:
                        # Para os elementos iguais, armazena eles em uma lista
                        duplicate.append(list_line_edit_value_pg1[i])

            if any(item == '' for item in duplicate):
                self.dlg_flow_tt.pages_flow_tt.setCurrentIndex(0)
                # Vefica se os codigos das difercoes de drenagem foram corretamente enviados
                QMessageBox.warning(self.dlg_flow_tt, 'Warning',
                                    "Direction codes might not None.")
                return

            elif duplicate and all(item != '' for item in duplicate):
                self.dlg_flow_tt.pages_flow_tt.setCurrentIndex(0)
                # O usuario enviou 2 valores semelhantes, sera mostrado uma mensagem de erro
                QMessageBox.warning(
                    self.dlg_flow_tt, 'Warning', f"The value(s) '{duplicate}' is(are) (a) duplicate(s)! Direction codes do not accept duplicates.")
                return

            else:
                # Se nao existir erros nas informacoes enviadas, sera mostrada a pagina de log e o programa sera executado
                self.dlg_flow_tt.pg_par_ftt.setEnabled(False)

                # Adiciona as mensagem de log ao text edit e configura a funcao run
                self.dlg_flow_tt.te_logg.append(mensagem_log1)
                for cont in range(1, 26):
                    self.dlg_flow_tt.progressBar.setValue(cont)

                self.run_process_flow_tt()
                self.dlg_flow_tt.progressBar.setValue(40)

                # Chama executavel vb para iniciar o processamento
                travel_time_vb = self.diretorio_atual + r'\temp\travel_time.exe'
                flow_tt_exe = subprocess.run([travel_time_vb])

                # verifica se houve algum erro no processamento das rotinas no vb ou se o usuario clicou em cancelar
                # Caso nao, a execucao continua no python
                if flow_tt_exe.returncode == 0:
                    self.dlg_flow_tt.progressBar.setValue(60)

                    # Move e renomeia arquivo txt com as caracteristicas dos trechos de rios semelhantes
                    if self.dlg_flow_tt.ch_8_pg4.isChecked() == True and os.path.isfile(self.output3_flow_tt) == True:

                        # Verifica se o user enviou o diretorio do arquivo ou apenas o nome (nesse caso, working folder != '')
                        is_basename = self.is_basename_only(
                            self.dlg_flow_tt.le_8_pg4.text())

                        # Se for apenas basename, concatena working folder com valor informado (deve ter extensao)
                        if is_basename == True:
                            output_file_1 = os.path.join(
                                self.dlg_flow_tt.le_21_pg1.text(), self.dlg_flow_tt.le_8_pg4.text())
                            shutil.copy(self.output3_flow_tt,
                                        output_file_1)
                        else:
                            shutil.copy(self.output3_flow_tt,
                                        self.dlg_flow_tt.le_8_pg4.text())

                    if os.path.isfile(self.output6_flow_tt) == True:
                        # Define parametros da funcao que transforma .rst(ascii) para geotiff: Cria arquivos de saida no diretorio fornecido pelo user
                        # Slope
                        if self.dlg_flow_tt.ch_6_pg4.isChecked():
                            output_path = self.caminho_completo(self.dlg_flow_tt.le_21_pg1.text(),
                                                                self.dlg_flow_tt.le_6_pg4.text())
                            self.leh_rst_escreve_geotiff(
                                self.output1_flow_tt, output_path, 'float')

                        # River segments
                        if self.dlg_flow_tt.ch_7_pg4.isChecked():
                            output_path = self.caminho_completo(self.dlg_flow_tt.le_21_pg1.text(),
                                                                self.dlg_flow_tt.le_7_pg4.text())
                            self.leh_rst_escreve_geotiff(
                                self.output2_flow_tt, output_path, 'int')

                        # River cross-sectional area
                        if self.dlg_flow_tt.ch_9_pg4.isChecked():
                            output_path = self.caminho_completo(self.dlg_flow_tt.le_21_pg1.text(),
                                                                self.dlg_flow_tt.le_9_pg4.text())
                            self.leh_rst_escreve_geotiff(
                                self.output4_flow_tt, output_path, 'float')

                        # River bankfull width
                        if self.dlg_flow_tt.ch_10_pg4.isChecked():
                            output_path = self.caminho_completo(self.dlg_flow_tt.le_21_pg1.text(),
                                                                self.dlg_flow_tt.le_10_pg4.text())
                            self.leh_rst_escreve_geotiff(
                                self.output5_flow_tt, output_path, 'float')

                        # Flow travel time
                        if self.dlg_flow_tt.ch_11_pg4.isChecked():
                            output_path = self.caminho_completo(self.dlg_flow_tt.le_21_pg1.text(),
                                                                self.dlg_flow_tt.le_11_pg4.text())
                            self.leh_rst_escreve_geotiff(
                                self.output6_flow_tt, output_path, 'float')

                        # Salva tvs e sub-bacias para cada POI
                        if (self.dlg_flow_tt.cb_8_pg2.currentText() != '' or self.dlg_flow_tt.cb_8_pg2.currentText() != None) and self.dlg_flow_tt.ch_12_pg4.isChecked() == True:
                            self.converte_tv_sub_POI_tif()
                            self.apaga_arquivos_tv()

                        # Atualiza progressBar
                        self.dlg_flow_tt.progressBar.setValue(80)

                        # Adiciona arquivos ao QGIS
                        if self.dlg_flow_tt.ch_17_pg4.isChecked():
                            self.adiciona_layer(self.caminho_completo(
                                self.dlg_flow_tt.le_21_pg1.text(), self.dlg_flow_tt.le_6_pg4.text()))

                        if self.dlg_flow_tt.ch_18_pg4.isChecked():
                            self.adiciona_layer(self.caminho_completo(
                                self.dlg_flow_tt.le_21_pg1.text(), self.dlg_flow_tt.le_7_pg4.text()))

                        if self.dlg_flow_tt.ch_20_pg4.isChecked():
                            self.adiciona_layer(self.caminho_completo(
                                self.dlg_flow_tt.le_21_pg1.text(), self.dlg_flow_tt.le_9_pg4.text()))

                        if self.dlg_flow_tt.ch_21_pg4.isChecked():
                            self.adiciona_layer(self.caminho_completo(
                                self.dlg_flow_tt.le_21_pg1.text(), self.dlg_flow_tt.le_10_pg4.text()))

                        if self.dlg_flow_tt.ch_22_pg4.isChecked():
                            self.adiciona_layer(self.caminho_completo(
                                self.dlg_flow_tt.le_21_pg1.text(), self.dlg_flow_tt.le_11_pg4.text()))

                        # Adiciona as informacao ao text edit
                        self.dlg_flow_tt.te_logg.append(
                            'Operation completed successfully!')
                        QMessageBox.information(
                            None, "Information", "Operation completed successfully!", )
                        self.dlg_flow_tt.progressBar.setValue(100)
                        self.dlg_flow_tt.pg_log_ftt.setEnabled(False)
                        self.dlg_flow_tt.pg_par_ftt.setEnabled(True)
                        self.dlg_flow_tt.te_logg.clear()
                        break
                else:
                    # Finaliza execucao do programa e elimina os arquivos temporarios criados
                    self.dlg_flow_tt.te_logg.clear()
                    self.dlg_flow_tt.progressBar.setValue(0)
                    self.dlg_flow_tt.pg_par_ftt.setEnabled(True)
                    self.dlg_flow_tt.pg_log_ftt.setEnabled(False)
                    end_msg = "The Hidropixel process has been canceled... Take a breath and go back to work!"
                    self.dlg_flow_tt.te_logg.append(end_msg)
                    self.apaga_arquivos_temp()
                    break

            # Finaliza execucao do programa e elimina os arquivos temporarios criados
            self.dlg_flow_tt.te_logg.clear()
            self.dlg_flow_tt.progressBar.setValue(0)
            self.dlg_flow_tt.pg_par_ftt.setEnabled(True)
            self.dlg_flow_tt.pg_log_ftt.setEnabled(False)
            end_msg = "The Hidropixel process has been canceled... Take a breath and go back to work!"
            self.dlg_flow_tt.te_logg.append(end_msg)
            self.apaga_arquivos_temp()
            break

    def move_hidrograma_POI(self):
        """Esta funcao organiza o envio dos hidrogramas gerados para cada POI para o diretorio informado pelo user"""
        try:
            if (self.dlg_flow_rout.le_3_pg2.text() != '' or self.dlg_flow_rout.le_3_pg2.text() != None) and self.dlg_flow_rout.ch_13_pg4.isChecked() == True:
                hydrograohs_dir = self.diretorio_atual + r'\temp\hydrographs'
                os.chdir(hydrograohs_dir)

                arquivos_tif = glob.glob('*.txt')

                # Move cada hidrograma para a pasta indicada
                for file in arquivos_tif:
                    file_base_name = os.path.basename(file)
                    new_file_dir = os.path.join(
                        self.dlg_flow_rout.le_9_pg4.text(), file_base_name)
                    shutil.copy2(file, new_file_dir)

        except OSError as e:
            if e.winerror == 123:  # Caminho invalido ou sintaxe incorreta
                QMessageBox.critical(
                    self.dlg_flow_rout,
                    "Invalid Directory",
                    "Provide a valid directory containing the travel times for each POI."
                )
                return False
            else:
                # Caso seja outro tipo de erro de sistema
                QMessageBox.critical(
                    self.dlg_flow_rout,
                    "System Error",
                    f"Unexpected system error:\n{str(e)}"
                )
                return False

    def run_process_flow_rout(self):
        """Esta funcao organiza os arquivos de entrada para as rotinas em vb apartir do plugin qgis"""
        # Captura diretorio dos arquivo txt (pasta temp)
        direct_temp = self.diretorio_atual + r'\temp'

        # Logica para conexao com VB
        try:
            if (self.dlg_flow_rout.le_3_pg2.text() != '' or self.dlg_flow_rout.le_3_pg2.text() != None) and self.dlg_flow_rout.ch_13_pg4.isChecked() == True:
                self.apaga_arquivos_tv()
                os.chdir(self.dlg_flow_rout.le_3_pg2.text())

                arquivos_tif = glob.glob('*.tif')
                cont = 0

                # Converte para .rst e move para a pasta tv_for_each_poi
                for file in arquivos_tif:
                    file_basename = os.path.basename(file)
                    tv_file = direct_temp + \
                        fr"\tv_for_each_poi\{file_basename.replace('.tif', '.rst')}"
                    self.leh_geotiff_escreve_ascii(file, tv_file, "float")

        except OSError as e:
            if e.winerror == 123:  # Caminho invalido ou sintaxe incorreta
                QMessageBox.critical(
                    self.dlg_flow_rout,
                    "Invalid Directory",
                    "Provide a valid directory containing the travel times for each POI."
                )
                return False
            else:
                # Caso seja outro tipo de erro de sistema
                QMessageBox.critical(
                    self.dlg_flow_rout,
                    "System Error",
                    f"Unexpected system error:\n{str(e)}"
                )
                return False

        # Escreve arquivos de parametros
        parameters_flow_rout = direct_temp + r'\parameters_flow_rout.txt'
        with open(parameters_flow_rout, 'w', encoding='utf-8') as arquivo_txt:
            arquivo_txt.write(
                f"Rainfall time step (min),{self.dlg_flow_rout.le_2_pg1.text()}\n")
            arquivo_txt.write(
                f"Parameter β,{self.dlg_flow_rout.le_5_pg1.text()}\n")
            arquivo_txt.write(
                f"L/s,{1 if self.dlg_flow_rout.rb_3_pg4.isChecked() == True else 0}\n")
            arquivo_txt.write(
                f"m3/s,{1 if self.dlg_flow_rout.rb_4_pg4.isChecked() == True else 0}")

        # Chama funcoes para tranformacao do raster em geotiff para rst tipo ascii
        bacia_file = direct_temp + r'\Watershed.rst'
        self.leh_geotiff_escreve_ascii(
            self.dlg_flow_rout.cb_1_pg2.currentLayer().source(), bacia_file, 'int')

        # Versao TUH
        # pixels_id_file = direct_temp + r'\map_pixels_id.rst'
        # self.leh_geotiff_escreve_ascii(
        #     self.dlg_flow_rout.le_2_pg2.text(), pixels_id_file, 'int')

        flow_tt_file = direct_temp + r'\flow_tt.rst'
        self.leh_geotiff_escreve_ascii(
            self.dlg_flow_rout.cb_3_pg2.currentLayer().source(), flow_tt_file, 'float')

        hietograma_file = direct_temp + r'\excess_hyetographs.bin'
        shutil.copy2(self.dlg_flow_rout.le_4_pg2.text(), hietograma_file)

        total_exc_rain_file = direct_temp + r'\total_excess_rainfall.rst'
        self.leh_geotiff_escreve_ascii(
            self.dlg_flow_rout.cb_5_pg2.currentLayer().source(), total_exc_rain_file, 'float')

        if self.dlg_flow_rout.groupBox_2.isChecked() == True:
            watershed_into_classes = direct_temp + r'\watershed_into_classes.rst'
            self.leh_geotiff_escreve_ascii(
                self.dlg_flow_rout.cb_4_pg2.currentLayer().source(), watershed_into_classes, 'int', mapa_classes='y')
        else:
            watershed_into_classes = ""

        # Escreve txt contendo codigo de direcoes de fluxo
        flow_directions_code = direct_temp + r'\input_files_config_flow_rout.txt'
        with open(flow_directions_code, 'w', encoding='utf-8') as arquivo_txt:
            arquivo_txt.write("Selected input files directory\n")
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.cb_1_pg2.currentText() !="" else 0},watershed,{bacia_file}\n')
            # Versao TUH
            # arquivo_txt.write(
            #     f'{1 if self.dlg_flow_rout.le_2_pg2.text() !="" else 0},map_pixels_id,{pixels_id_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.cb_3_pg2.currentText() !="" else 0},flow_travel_time,{flow_tt_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.le_4_pg2.text() !="" else 0},excess_hyetographs,{hietograma_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.cb_5_pg2.currentText() !="" else 0},total_excess_rainfall,{total_exc_rain_file}\n')
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.cb_4_pg2.currentText() !="" else 0},watershed_into_classes,{watershed_into_classes}\n')
            arquivo_txt.write(f'{1},parameters,{parameters_flow_rout}')

        self.output1_flow_rout = direct_temp + r'\map_of_resulting_peak_discharge.rst'
        self.output2_flow_rout = direct_temp + r'\map_of_resulting_runoff_volume.rst'
        self.output3_flow_rout = direct_temp + r'\resulting_watershed_hydrograph.txt'

        # Escreve aquivo txt contendo o diretorio informado pelo user: sera fornecido para a rotina em visual basic
        direct_out_files = direct_temp + r'\output_files_config_flow_rout.txt'
        with open(direct_out_files, 'w', encoding='utf-8') as arquivo_txt:
            arquivo_txt.write("Selected output files directory\n")
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.ch_4_pg4.isChecked() == True else 0},map_of_resulting_peak_discharge,{self.output1_flow_rout}\n')  # rst
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.ch_5_pg4.isChecked() == True else 0},map_of_resulting_runoff_volume,{self.output2_flow_rout}\n')  # rst
            arquivo_txt.write(
                f'{1 if self.dlg_flow_rout.ch_6_pg4.isChecked() == True else 0},resulting_watershed_hydrograph,{self.output3_flow_rout}')  # txt

    def plot_hidrogramas_e_metricas(self):
        """Esta funcao gera o hidrograma calculado vs observado e adiciona as metricas de comparacao"""

        # leh hidrograma observado
        cont = 0
        # Plota, se marcado, o hidrograma calculado e o observado e calcula as metricas
        if self.dlg_flow_rout.ch_12_pg4.isChecked() == True and self.dlg_flow_rout.le_6_pg4.text() != '' and self.dlg_flow_rout.le_7_pg4.text() != '':
            hidrograma_obs = self.caminho_completo(
                self.dlg_flow_rout.le_3_pg1.text(), self.dlg_flow_rout.le_7_pg4.text())
            hidrograma_calc = self.output3_flow_rout

            # Leitura do hidrograma observado
            with open(hidrograma_obs, 'r', encoding='ISO-8859-1') as f:
                header_obs = f.readline().strip().split(',')
                nomes_obs = header_obs[1:]  # descarta o tempo
                data_obs = np.loadtxt(f, delimiter=',')
            tempos_obs = data_obs[:, 0]
            vazoes_obs = data_obs[:, 1:]  # pode ter varias colunas

            # Leitura do hidrograma calculado
            with open(hidrograma_calc, 'r', encoding='ISO-8859-1') as f:
                header_calc = f.readline().strip().split(',')
                nomes_calc = header_calc[1:]
                data_calc = np.loadtxt(f, delimiter=',')
            tempos_calc = data_calc[:, 0]
            vazoes_calc = data_calc[:, 1:]

            # reshape caso o usuario envie um arquivo com dimensao maior
            n_obs = vazoes_obs.shape[0]
            n_calc = vazoes_calc.shape[0]
            n = min(n_obs, n_calc)

            vazoes_obs = vazoes_obs[:n]
            tempos_obs = tempos_obs[:n]

            vazoes_calc = vazoes_calc[:n]
            tempos_calc = tempos_calc[:n]

            #  Calculo de delta_t
            delta_t = tempos_obs[1] - tempos_obs[0]

            # Plotagem
            plt.figure(figsize=(8, 6))
            plt.gcf().canvas.manager.window.setWindowTitle('Resulting Watershed Hydrograph')
            plt.title('HYDROGRAPH')

            # Observado (primeira coluna de vazoes observadas) em preto
            plt.plot(tempos_obs, vazoes_obs[:, 0], color='black',
                     linestyle='-', label='Observed Runoff')

            # Calculado total (primeira coluna de vazoes calculadas) em vermelho
            plt.plot(tempos_calc, vazoes_calc[:, 0], color='red',
                     linestyle='-', label='Calculated Runoff')

            plt.xlabel('time (min)')
            plt.ylabel('Q(m³/s)')

            # legenda no canto superior direito, vertical e fonte reduzida
            plt.legend(loc='upper right', fontsize='small')

            plt.grid()

            # Metricas de comparacao
            q_obs = vazoes_obs[:, 0]
            q_calc = vazoes_calc[:, 0]
            er_vazao_pico = (np.max(q_calc) - np.max(q_obs)) / \
                np.max(q_obs) * 100
            er_tempo_pico = ((tempos_calc[np.argmax(
                q_calc)] - tempos_obs[np.argmax(q_obs)]) / tempos_obs[np.argmax(q_obs)]) * 100
            nse = 1 - (np.sum((q_calc - q_obs)**2) /
                       np.sum((q_obs - np.mean(q_obs))**2))
            rmse = np.sqrt(np.mean((q_calc - q_obs)**2))
            vol_obs = np.sum(q_obs) * delta_t
            vol_calc = np.sum(q_calc) * delta_t
            er_vol = (vol_calc - vol_obs) / vol_obs * 100

            # mantem as posicoes originais das metricas
            plt.figtext(0.1, 0.25, f'RMSE: {rmse:.2f}m³/s', fontsize=10)
            plt.figtext(0.1, 0.20, f'NS coefficient: {nse:.2f}', fontsize=10)
            plt.figtext(
                0.1, 0.15, f'relative peak error: {er_vazao_pico:.2f}%', fontsize=10)
            plt.figtext(
                0.1, 0.10, f'relative time to peak error: {er_tempo_pico:.2f}%', fontsize=10)
            plt.figtext(
                0.1, 0.05, f'relative volume error: {er_vol:.2f}%', fontsize=10)

            plt.subplots_adjust(bottom=0.40)
            plt.show()

        else:
            hidrograma_calc = self.output3_flow_rout

            with open(hidrograma_calc, 'r', encoding='ISO-8859-1') as f:
                header = f.readline().strip().split(',')

            # Armazena a legenda do grafico
            header[1] = 'Calculated Runoff'

            # Carrega as vazoes (pula a primeira linha, usa virgula como separador)
            data = np.loadtxt(hidrograma_calc, skiprows=1, delimiter=',')

            # A primeira coluna e o tempo
            tempos = data[:, 0]

            # Determinacao do delta
            if len(tempos) > 1:
                delta_t = tempos[1] - tempos[0]
            else:
                delta_t = 0

            # Cria grafico e delimita tamanho de exibicao
            plt.figure(figsize=(8, 6))
            plt.gcf().canvas.manager.window.setWindowTitle('Resulting Watershed Hydrograph')
            plt.title('HYDROGRAPH')

            # Plot dos hidrogramas calculados
            plt.plot(tempos, data[:, 1], label=header[1].strip(), color='red')
            plt.xlabel('time (min)')
            plt.ylabel('Q (m³/s)')
            plt.legend()
            plt.grid()
            plt.show()

    def run_flow_routing(self):
        '''Esta funcao ativa a pagina de log e configura a ordem de execucao das funcoes para o calculo do tempo de viagem'''
        # Ativiva a pagina de log e limpa as informacoes passadas no text_edit
        mensagem_log1 = None
        self.dlg_flow_rout.tabWidget.setCurrentIndex(1)
        self.dlg_flow_rout.pg_log_f_rout.setEnabled(True)
        self.dlg_flow_rout.te_logg.clear()

        # Configura a progressbar
        self.dlg_flow_rout.progressBar.setRange(0, 100)
        self.dlg_flow_rout.progressBar.setValue(0)
        self.dlg_flow_rout.progressBar.setValue(5)

        # Validation gate: require data validation to be executed and passed
        try:
            if not ensure_validations_pass(self, module=3, parent=self.dlg_flow_rout):
                # revert UI state and abort
                self.dlg_flow_rout.progressBar.setValue(0)
                self.dlg_flow_rout.pg_log_f_rout.setEnabled(False)
                return
        except Exception:
            self.dlg_flow_rout.progressBar.setValue(0)
            self.dlg_flow_rout.pg_log_f_rout.setEnabled(False)
            QMessageBox.critical(self.dlg_flow_rout, 'Validation Gate',
                                 'Unexpected error while checking validations.')
            return

        # Configura as informacoes do textEdit da referida pagina
        font = QFont()
        font.setPointSize(11)
        version_info = {
            "QGIS Version": '3.28.0-Firenze',
            "Qt Version": '5.15.3',
            "Python Version": '3.9.5',
            "GDAL Version": '3.8.0'}

        datatime_started = datetime.now().isoformat()
        mensagem_log1 = "The plugin was developed with:\n"
        mensagem_log1 += f"QGIS Version: {version_info['QGIS Version']}\n"
        mensagem_log1 += f"Qt Version: {version_info['Qt Version']}\n"
        mensagem_log1 += f"Python Version: {version_info['Python Version']}\n"
        mensagem_log1 += f"GDAL Version: {version_info['GDAL Version']}\n"
        mensagem_log1 += "--------------------------------------------------------\n"
        mensagem_log1 += f"Algorithm started at: {datatime_started}\n"
        mensagem_log1 += "--------------------------------------------------------\n"
        self.dlg_flow_rout.progressBar.setValue(10)
        # Cria condicao de parada da execucao: se o usuario clicar no botao cancel da pagina de log
        while True:
            # Metodo usado para permitir a iteracao do usuario enquanto o programa esta em execucao
            QApplication.processEvents()
            self.dlg_flow_rout.btn_cancel_log.clicked.connect(lambda: self.cancel_log_page(
                self.dlg_flow_rout.te_logg, self.dlg_flow_rout.pg_par_f_rout, self.dlg_flow_rout.pg_log_f_rout))
            self.dlg_flow_rout.pg_par_f_rout.setEnabled(False)

            # Adiciona as mensagem de log ao text edit e configura a funcao run
            self.dlg_flow_rout.te_logg.append(mensagem_log1)
            for cont in range(1, 26):
                self.dlg_flow_rout.progressBar.setValue(cont)

            run = self.run_process_flow_rout()

            if run == False:
                self.dlg_flow_rout.te_logg.clear()
                self.dlg_flow_rout.progressBar.setValue(0)
                self.dlg_flow_rout.pg_par_f_rout.setEnabled(True)
                self.dlg_flow_rout.pg_log_f_rout.setEnabled(False)
                end_msg = "The Hidropixel process has been canceled... Take a breath and go back to work!"
                self.dlg_flow_rout.te_logg.append(end_msg)
                self.apaga_arquivos_temp()
                break

            self.dlg_flow_rout.progressBar.setValue(40)

            # Chama executavel vb para iniciar o processamento
            flow_rout_vb = self.diretorio_atual + r'\temp\flow_routing.exe'
            flow_rout_exe = subprocess.run([flow_rout_vb])

            # verifica se houve algum erro no processamento das rotinas no vb ou se o usuario clicou em cancelar
            # Caso nao, a execucao continua no python
            if flow_rout_exe.returncode == 0:
                self.dlg_flow_rout.progressBar.setValue(60)

                # Copia e renomeia arquivo txt do hidrograma final
                if self.dlg_flow_rout.ch_6_pg4.isChecked() == True and os.path.isfile(self.output3_flow_rout) == True:

                    # Define parametros da funcao que transforma .rst(ascii) para geotiff: Cria arquivos de saida no diretorio fornecido pelo user
                    # Peak discharge
                    if self.dlg_flow_rout.ch_4_pg4.isChecked():
                        output_path = self.caminho_completo(
                            self.dlg_flow_rout.le_3_pg1.text(), self.dlg_flow_rout.le_4_pg4.text())
                        self.leh_rst_escreve_geotiff(
                            self.output1_flow_rout, output_path, 'float')

                    # Runoff volume
                    if self.dlg_flow_rout.ch_5_pg4.isChecked():
                        output_path = self.caminho_completo(
                            self.dlg_flow_rout.le_3_pg1.text(), self.dlg_flow_rout.le_5_pg4.text())
                        self.leh_rst_escreve_geotiff(
                            self.output2_flow_rout, output_path, 'float')

                    # Adicao dos arquivos gerados ao QGIS
                    if self.dlg_flow_rout.ch_10_pg4.isChecked():
                        layer_path = self.caminho_completo(
                            self.dlg_flow_rout.le_3_pg1.text(), self.dlg_flow_rout.le_4_pg4.text())
                        self.adiciona_layer(layer_path)

                    if self.dlg_flow_rout.ch_11_pg4.isChecked():
                        layer_path = self.caminho_completo(
                            self.dlg_flow_rout.le_3_pg1.text(), self.dlg_flow_rout.le_5_pg4.text())
                        self.adiciona_layer(layer_path)

                    # Verifica se o user enviou o diretorio do arquivo ou apenas o nome (nesse caso, working folder != '')
                    is_basename = self.is_basename_only(
                        self.dlg_flow_rout.le_6_pg4.text())

                    # Se for apenas basename, concatena working folder com valor informado (deve ter extensao)
                    if is_basename == True:
                        output_file_1 = os.path.join(
                            self.dlg_flow_rout.le_3_pg1.text(), self.dlg_flow_rout.le_6_pg4.text())
                        shutil.copy2(self.output3_flow_rout, output_file_1)

                    else:
                        shutil.copy2(self.output3_flow_rout,
                                     self.dlg_flow_rout.le_6_pg4.text())

                    # Chama funcao para plot dos hidrogramas se opcao for selecionada
                    if self.dlg_flow_rout.ch_12_pg4.isChecked() == True:
                        self.plot_hidrogramas_e_metricas()

                    # move hidrogramas por POI para a pasta indicada pelo user
                    self.move_hidrograma_POI()

                    # Adiciona as informacao ao text edit
                    self.dlg_flow_rout.te_logg.append(
                        'Operation completed successfully!')
                    QMessageBox.information(
                        None, "Information", "Operation completed successfully!", )
                    self.dlg_flow_rout.progressBar.setValue(100)
                    self.dlg_flow_rout.pg_log_f_rout.setEnabled(False)
                    self.dlg_flow_rout.pg_par_f_rout.setEnabled(True)
                    self.dlg_flow_rout.te_logg.clear()
                    break

                else:
                    # Caso nenhuma das condicoes acima sejam verdadeira, libera a interface grafica e limpa os arquivos
                    self.dlg_flow_rout.te_logg.clear()
                    self.dlg_flow_rout.progressBar.setValue(0)
                    self.dlg_flow_rout.pg_par_f_rout.setEnabled(True)
                    self.dlg_flow_rout.pg_log_f_rout.setEnabled(False)
                    end_msg = "The Hidropixel process has been canceled... Take a breath and go back to work!"
                    self.dlg_flow_rout.te_logg.append(end_msg)
                    self.apaga_arquivos_temp()
                    break

            # Caso nenhuma das condicoes acima sejam verdadeira, libera a interface grafica e limpa os arquivos
            self.dlg_flow_rout.te_logg.clear()
            self.dlg_flow_rout.progressBar.setValue(0)
            self.dlg_flow_rout.pg_par_f_rout.setEnabled(True)
            self.dlg_flow_rout.pg_log_f_rout.setEnabled(False)
            end_msg = "The Hidropixel process has been canceled... Take a breath and go back to work!"
            self.dlg_flow_rout.te_logg.append(end_msg)
            self.apaga_arquivos_temp()
            break

    def ativa_objetos_run_ftt(self):
        """Esta funcao ativia objetos da pagina run do modulo flow travel time se o usuario selecionar a opcao correspondente."""
        if self.dlg_flow_tt.ch_6_pg4.isChecked():
            # ouput 1
            self.dlg_flow_tt.label_63.setEnabled(True)
            self.dlg_flow_tt.le_6_pg4.setEnabled(True)
            self.dlg_flow_tt.tbtn_pg4_6.setEnabled(True)
            self.dlg_flow_tt.ch_17_pg4.setEnabled(True)

        else:
            # ouput 1
            self.dlg_flow_tt.label_63.setEnabled(False)
            self.dlg_flow_tt.le_6_pg4.setEnabled(False)
            self.dlg_flow_tt.tbtn_pg4_6.setEnabled(False)
            self.dlg_flow_tt.ch_17_pg4.setEnabled(False)

        if self.dlg_flow_tt.ch_7_pg4.isChecked():
            # ouput 2
            self.dlg_flow_tt.label_83.setEnabled(True)
            self.dlg_flow_tt.le_7_pg4.setEnabled(True)
            self.dlg_flow_tt.tbtn_pg4_7.setEnabled(True)
            self.dlg_flow_tt.ch_18_pg4.setEnabled(True)

        else:
            # ouput 2
            self.dlg_flow_tt.label_83.setEnabled(False)
            self.dlg_flow_tt.le_7_pg4.setEnabled(False)
            self.dlg_flow_tt.tbtn_pg4_7.setEnabled(False)
            self.dlg_flow_tt.ch_18_pg4.setEnabled(False)

        if self.dlg_flow_tt.ch_8_pg4.isChecked():
            # ouput 3
            self.dlg_flow_tt.label_85.setEnabled(True)
            self.dlg_flow_tt.le_8_pg4.setEnabled(True)
            self.dlg_flow_tt.tbtn_pg4_8.setEnabled(True)

        else:
            # ouput 3
            self.dlg_flow_tt.label_85.setEnabled(False)
            self.dlg_flow_tt.le_8_pg4.setEnabled(False)
            self.dlg_flow_tt.tbtn_pg4_8.setEnabled(False)

        if self.dlg_flow_tt.ch_12_pg4.isChecked():
            # ouput 6
            self.dlg_flow_tt.label_73.setEnabled(True)
            self.dlg_flow_tt.le_13_pg4.setEnabled(True)
            self.dlg_flow_tt.tbtn_pg4_12.setEnabled(True)

        else:
            # ouput 6
            self.dlg_flow_tt.label_73.setEnabled(False)
            self.dlg_flow_tt.le_13_pg4.setEnabled(False)
            self.dlg_flow_tt.tbtn_pg4_12.setEnabled(False)

    def ativiva_objetos_run_exc_rainf(self):
        """Esta funcao ativia objetos da pagina run do modulo excess rainfall se o usuario selecionar a opcao correspondente."""
        if self.dlg_exc_rain.ch_1_pg4.isChecked():
            # ouput 1
            self.dlg_exc_rain.label_57.setEnabled(True)
            self.dlg_exc_rain.le_1_pg4.setEnabled(True)
            self.dlg_exc_rain.tbtn_pg4_1.setEnabled(True)
            self.dlg_exc_rain.ch_7_pg4.setEnabled(True)

        else:
            # ouput 1
            self.dlg_exc_rain.label_57.setEnabled(False)
            self.dlg_exc_rain.le_1_pg4.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg4_1.setEnabled(False)
            self.dlg_exc_rain.ch_7_pg4.setEnabled(False)

        if self.dlg_exc_rain.ch_2_pg4.isChecked():
            # ouput 2
            self.dlg_exc_rain.label_58.setEnabled(True)
            self.dlg_exc_rain.le_2_pg4.setEnabled(True)
            self.dlg_exc_rain.tbtn_pg4_2.setEnabled(True)
            self.dlg_exc_rain.ch_8_pg4.setEnabled(True)

        else:
            # ouput 2
            self.dlg_exc_rain.label_58.setEnabled(False)
            self.dlg_exc_rain.le_2_pg4.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg4_2.setEnabled(False)
            self.dlg_exc_rain.ch_8_pg4.setEnabled(False)

        if self.dlg_exc_rain.ch_3_pg4.isChecked():
            # ouput 3
            self.dlg_exc_rain.label_59.setEnabled(True)
            self.dlg_exc_rain.le_3_pg4.setEnabled(True)
            self.dlg_exc_rain.tbtn_pg4_3.setEnabled(True)
            self.dlg_exc_rain.ch_9_pg4.setEnabled(False)

        else:
            # ouput 3
            self.dlg_exc_rain.label_59.setEnabled(False)
            self.dlg_exc_rain.le_3_pg4.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg4_3.setEnabled(False)
            self.dlg_exc_rain.ch_9_pg4.setEnabled(False)

        if self.dlg_exc_rain.ch_4_pg4.isChecked():
            # ouput 4
            self.dlg_exc_rain.label_72.setEnabled(True)
            self.dlg_exc_rain.le_4_pg4.setEnabled(True)
            self.dlg_exc_rain.tbtn_pg4_4.setEnabled(True)
            self.dlg_exc_rain.ch_10_pg4.setEnabled(False)

        else:
            # ouput 3
            self.dlg_exc_rain.label_72.setEnabled(False)
            self.dlg_exc_rain.le_4_pg4.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg4_4.setEnabled(False)
            self.dlg_exc_rain.ch_10_pg4.setEnabled(False)

    def ativiva_objetos_run_flow_rout(self):
        """Ativa objetos da pagina run do modulo flow routing e ajusta extensoes sugeridas."""

        if self.dlg_flow_rout.ch_4_pg4.isChecked():
            # ouput 1
            self.dlg_flow_rout.label_61.setEnabled(True)
            self.dlg_flow_rout.le_4_pg4.setEnabled(True)
            self.dlg_flow_rout.tbtn_pg4_4.setEnabled(True)
            self.dlg_flow_rout.ch_10_pg4.setEnabled(True)
            self.dlg_flow_rout.label_6.setEnabled(True)
            self.dlg_flow_rout.rb_3_pg4.setEnabled(True)
            self.dlg_flow_rout.rb_4_pg4.setEnabled(True)

        else:
            # ouput 1
            self.dlg_flow_rout.label_61.setEnabled(False)
            self.dlg_flow_rout.le_4_pg4.setEnabled(False)
            self.dlg_flow_rout.tbtn_pg4_4.setEnabled(False)
            self.dlg_flow_rout.ch_10_pg4.setEnabled(False)
            self.dlg_flow_rout.label_6.setEnabled(False)
            self.dlg_flow_rout.rb_3_pg4.setEnabled(False)
            self.dlg_flow_rout.rb_4_pg4.setEnabled(False)

        if self.dlg_flow_rout.ch_5_pg4.isChecked():
            # ouput 2
            self.dlg_flow_rout.label_71.setEnabled(True)
            self.dlg_flow_rout.le_5_pg4.setEnabled(True)
            self.dlg_flow_rout.tbtn_pg4_5.setEnabled(True)
            self.dlg_flow_rout.ch_11_pg4.setEnabled(True)

        else:
            # ouput 2
            self.dlg_flow_rout.label_71.setEnabled(False)
            self.dlg_flow_rout.le_5_pg4.setEnabled(False)
            self.dlg_flow_rout.tbtn_pg4_5.setEnabled(False)
            self.dlg_flow_rout.ch_11_pg4.setEnabled(False)

        if self.dlg_flow_rout.ch_13_pg4.isChecked():
            # ouput 3
            self.dlg_flow_rout.label_74.setEnabled(True)
            self.dlg_flow_rout.le_9_pg4.setEnabled(True)
            self.dlg_flow_rout.tbtn_pg4_8.setEnabled(True)

        else:
            # ouput 3
            self.dlg_flow_rout.label_74.setEnabled(False)
            self.dlg_flow_rout.le_9_pg4.setEnabled(False)
            self.dlg_flow_rout.tbtn_pg4_8.setEnabled(False)

    def SsButoes(self, active_button, instancia, page=0):
        """Esta funcao configura o estilo dos botoes das diferentes paginas do plugin. Aquele que estiver em destaque representara a pagina autal
        page = 1 representa o form Excess Rainfall
        page = 0 representa os outros forms"""

        # Defina os estilos para o botao ativo e o padrao
        default_style = ""
        self.highlighted_style = "background-color: rgb(173, 216, 230)"

        # Significa que o form atual e o excess rainfall
        if page == 1:
            # Lista dos botoes
            buttons = [
                instancia.btn_config,
                instancia.btn_rain_int,
                instancia.btn_input_data,
                instancia.btn_data_va_tool,
                instancia.btn_run
            ]
        else:
            buttons = [
                instancia.btn_config,
                instancia.btn_input_data,
                instancia.btn_data_va_tool,
                instancia.btn_run
            ]
        # Aplica o estilo ativo ao botao clicado e o estilo padrao aos outros
        for btn in buttons:
            if btn == active_button:
                btn.setStyleSheet(self.highlighted_style)
            else:
                btn.setStyleSheet(default_style)

    def atualizaVazaoObs(self):
        if self.dlg_flow_rout.ch_12_pg4.isChecked():
            self.dlg_flow_rout.label_64.setEnabled(True)
            self.dlg_flow_rout.le_7_pg4.setEnabled(True)
            self.dlg_flow_rout.tbtn_pg4_7.setEnabled(True)
            self.dlg_flow_rout.label_55.setEnabled(True)
        else:
            self.dlg_flow_rout.label_64.setEnabled(False)
            self.dlg_flow_rout.le_7_pg4.setEnabled(False)
            self.dlg_flow_rout.tbtn_pg4_7.setEnabled(False)
            self.dlg_flow_rout.label_55.setEnabled(False)

    def CondicaoRunFlowTT(self):
        """Esta funcao verifica se para cada etapa do hidropixel ao menos o output recomendado foi selecionado, caso sim, o botao RUN sera liberado; do contrario, nao."""
        if self.dlg_flow_tt.le_11_pg4.text() != '':
            self.run_flow_tt()

        else:
            result = r'Provide a valid directory for the outputs!'
            QMessageBox.warning(None, "Invalid directory provided", result)

    def CondicaoRunRainfall_inter(self, map_out):
        """Esta funcao verifica se para cada etapa do hidropixel ao menos o output recomendado foi selecionado, caso sim, o botao RUN sera liberado; do contrario, nao."""
        if self.dlg_exc_rain.cb_1_pg_ri.currentText() != '' and self.dlg_exc_rain.le_2_pg_ri.text() != '' and self.dlg_exc_rain.le_3_pg_ri.text() != '':
            self.run_rainfall_interpolation(map_out)

        else:
            result = 'Provide a valid directory for the outputs!'
            QMessageBox.warning(None, "Invalid directory provided", result)

    def condicaoRunExcessRainfall(self):
        """Esta funcao verifica se para cada etapa do hidropixel ao menos o output recomendado foi selecionado, caso sim, o botao RUN sera liberado; do contrario, nao."""
        if self.dlg_exc_rain.le_5_pg4.text() != '' and self.dlg_exc_rain.le_6_pg4.text() != '':
            self.run_excess_rainfall()

        else:
            result = 'Provide a valid directory for the outputs!'
            QMessageBox.warning(None, "Invalid directory provided", result)

    def condicaoRunFlowRouting(self):
        """Esta funcao verifica se para cada etapa do hidropixel ao menos o output recomendado foi selecionado, caso sim, o botao RUN sera liberado; do contrario, nao."""
        if self.dlg_flow_rout.le_6_pg4.text() != '':
            self.run_flow_routing()

        else:
            result = 'Provide a valid directory for the outputs!'
            QMessageBox.warning(None, "Invalid directory provided", result)

    def get_project_dir(self, interface):
        """Solicita diretorio para armazenar projeto do Hidropixel"""
        while True:
            file_name, _ = QFileDialog.getSaveFileName(
                None, "Save the project!", interface.le_1_pg1.text(), "Hidropixel project (*.hpx)")

            if not file_name:
                result = "Wait! You did not select any directory."
                reply = QMessageBox.warning(
                    None, "No file selected", result, QMessageBox.Ok)
                if reply == QMessageBox.Ok:
                    break

            else:
                interface.le_2_pg1.setText(file_name)
                break

    def parameters_mask(self):
        """Aplica mascara aos com os parametros para aceitar apenas valores numericos"""
        # define validatos
        int_validator = QIntValidator()
        float_validadator = QDoubleValidator()

        # Flow Travel Time
        self.dlg_flow_tt.le_1_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_3_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_4_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_5_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_6_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_7_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_8_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_9_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_10_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_11_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_12_pg1.setValidator(int_validator)
        self.dlg_flow_tt.le_14_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_15_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_16_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_17_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_18_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_19_pg1.setValidator(float_validadator)
        self.dlg_flow_tt.le_11_pg2.setValidator(float_validadator)

        # Excess Rainfall
        self.dlg_exc_rain.le_1_pg1.setValidator(float_validadator)

        # Flow Routing
        self.dlg_flow_rout.le_5_pg1.setValidator(float_validadator)
        self.dlg_flow_rout.le_2_pg1.setValidator(float_validadator)

    def run_save_project(self, interface, function):
        """Organiza logica de execucao da rotina que salva projeto .hpx"""
        # So salva se nome e diretorio do projeto for fornecido
        if interface.le_1_pg1.text() != '' and interface.le_2_pg1.text() != '':

            txt2 = interface.le_2_pg1.text()

            if os.path.isdir(txt2):
                file_name = os.path.join(txt2, interface.le_1_pg1.text())
                file_name = self.define_extensao_hpx(file_name)

            else:
                file_name = txt2
                # Se nao tiver extensao, adiciona
                file_name = self.define_extensao_hpx(file_name)

            self.save_to_project(function, file_name)

            QMessageBox.information(
                None, "Project saved", "Operation completed successfully", QMessageBox.Ok)
        else:
            result = "Provide a valid project name and directory!"
            QMessageBox.warning(
                None, "Invalid information provided", result, QMessageBox.Ok)
            return

    def populate_combobox_with_tifs(self, combo):
        """Limpa um QComboBox do tipo QgsMapLayerComboBox e adiciona apenas rasters .tif (por nome da camada)."""
        combo.clear()
        for layer in QgsProject.instance().mapLayers().values():
            # confirma ser raster e que a fonte aponta para .tif
            if isinstance(layer, QgsRasterLayer):
                src = layer.source().lower()
                # alguns providers têm '.../file.tif' na source; verificamos endswith
                if src.endswith('.tif') or src.endswith('.tiff'):
                    combo.addItem(layer.name())

    def set_filters(self):
        """Esta funcao aplica os filtros nos comboboxes das diferentes rotinas do plugin"""

        # Flow Travel Time
        self.dlg_flow_tt.cb_1_pg2.setFilters(
            QgsMapLayerProxyModel.RasterLayer)
        self.dlg_flow_tt.cb_2_pg2.setFilters(
            QgsMapLayerProxyModel.RasterLayer)
        self.dlg_flow_tt.cb_3_pg2.setFilters(
            QgsMapLayerProxyModel.RasterLayer)
        self.dlg_flow_tt.cb_4_pg2.setFilters(
            QgsMapLayerProxyModel.RasterLayer)
        self.dlg_flow_tt.cb_5_pg2.setFilters(
            QgsMapLayerProxyModel.RasterLayer)
        self.dlg_flow_tt.cb_6_pg2.setFilters(
            QgsMapLayerProxyModel.RasterLayer)
        self.dlg_flow_tt.cb_7_pg2.setFilters(
            QgsMapLayerProxyModel.RasterLayer)
        self.dlg_flow_tt.cb_8_pg2.setFilters(
            QgsMapLayerProxyModel.VectorLayer)

        # Excess Rainfall
        self.dlg_exc_rain.cb_1_pg_ri.setFilters(
            QgsMapLayerProxyModel.RasterLayer)
        self.dlg_exc_rain.cb_1_pg2.setFilters(
            QgsMapLayerProxyModel.RasterLayer)
        self.dlg_exc_rain.cb_2_pg2.setFilters(
            QgsMapLayerProxyModel.RasterLayer)

        # Flow Routing
        self.dlg_flow_rout.cb_1_pg2.setFilters(
            QgsMapLayerProxyModel.RasterLayer)
        self.dlg_flow_rout.cb_3_pg2.setFilters(
            QgsMapLayerProxyModel.RasterLayer)
        self.dlg_flow_rout.cb_4_pg2.setFilters(
            QgsMapLayerProxyModel.RasterLayer)
        self.dlg_flow_rout.cb_5_pg2.setFilters(
            QgsMapLayerProxyModel.RasterLayer)

    def conf_rdn_data_validation_tool(self):
        """Configura os elementos da rede de drenagem na pagina data validation tool.
        Se o usuario nao informar a rede de drenagem classificada, os botões de validacao serao desativados."""

        if self.dlg_flow_tt.cb_5_pg2.currentText() is not None and self.dlg_flow_tt.tbw_1_pg2.rowCount() > 0:
            self.dlg_flow_tt.label_111.setEnabled(True)
            self.dlg_flow_tt.btn13_pg3.setEnabled(True)
            self.dlg_flow_tt.label_112.setEnabled(True)
        else:
            self.dlg_flow_tt.label_111.setEnabled(False)
            self.dlg_flow_tt.btn13_pg3.setEnabled(False)
            self.dlg_flow_tt.label_112.setEnabled(False)

    def open_pdf_help(self):
        # Caminho absoluto do PDF dentro do plugin
        pdf_path = os.path.join(self.plugin_dir, "docs",
                                "Q-Hidropixel_user_manual.pdf")

        if not os.path.exists(pdf_path):
            self.iface.messageBar().pushWarning(
                "File not found",
            )
            return

        # Abre o PDF usando o visualizador padrão do sistema
        QDesktopServices.openUrl(QUrl.fromLocalFile(pdf_path))

    def run(self):
        """Esta e a funcao principal do plugin, todas as funcionalidades propostas anteriormente serao efetivadas na funcao run"""
        # Ensure DPI scaling attributes are set (safe to call repeatedly)
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
        QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)

        # If the dialog already exists and is visible, just bring it to front and give it focus
        if hasattr(self, 'dlg_hidropixel') and self.dlg_hidropixel is not None and self.dlg_hidropixel.isVisible():
            try:
                self.dlg_hidropixel.raise_()
                self.dlg_hidropixel.activateWindow()
            except Exception:
                # best-effort: ignore focus errors
                pass
            return

        # Create the dialog only once. If already created but hidden, reuse it.
        if not hasattr(self, 'dlg_hidropixel') or self.dlg_hidropixel is None:
            self.dlg_hidropixel = HidropixelDialog()
            # mark that initial UI wiring still needs to run
            self._hidropixel_initialized = False

        # At this point the dialog exists but may be hidden; show it and process events
        # Add logo and perform one-time initialization when needed
        # Adiciona logo Hidropixel na pagina incial
        caminho_icon = os.path.abspath(
            self.diretorio_atual + r"/icons/logo_menu.png")
        pixmap = QPixmap(caminho_icon)
        # Configurando a imagem na QLabel
        try:
            self.dlg_hidropixel.label_2.setPixmap(pixmap)
            self.dlg_hidropixel.label_2.setScaledContents(True)
        except Exception:
            # ignore if label not present for some reason
            pass

        # Show the dialog (reuse if already created)
        self.dlg_hidropixel.show()
        QApplication.processEvents()

        # One-time initialization: connect signals, set filters and masks, set styles
        if not getattr(self, '_hidropixel_initialized', False):
            # Desativa a pagina de log, so sera ativada apos clicar no botao run
            try:
                self.dlg_flow_tt.pg_log_ftt.setEnabled(False)
            except Exception:
                pass

            # Cria as flags para configurar a leitura dos dados da tabela
            self.flag = 0
            self.flag_1 = 0

            # Configura botao about
            try:
                self.dlg_hidropixel.btn_flow_about.clicked.connect(
                    lambda: self.dlg_about.show())
            except Exception:
                pass

            # Chama funcao que aplica mascara para todos os parametros das diferentes rotinas
            try:
                self.parameters_mask()
                self.set_filters()
            except Exception:
                pass

            # Configura botoes do menu do hidropixel e estilo dos botoes da configuration page
            try:
                self.dlg_hidropixel.btn_flow_trav.clicked.connect(
                    lambda: self.dlg_flow_tt.show())
                self.dlg_flow_tt.btn_config.setStyleSheet(
                    self.highlighted_style)

                self.dlg_hidropixel.btn_exes_rain.clicked.connect(
                    lambda: self.dlg_exc_rain.show())
                self.dlg_exc_rain.btn_config.setStyleSheet(
                    self.highlighted_style)

                self.dlg_hidropixel.btn_flow_rout.clicked.connect(
                    lambda: self.dlg_flow_rout.show())
                self.dlg_flow_rout.btn_config.setStyleSheet(
                    self.highlighted_style)
                self.dlg_hidropixel.btn_help.clicked.connect(
                    lambda: self.open_pdf_help())
            except Exception:
                pass

            # The rest of the UI wiring (tables, buttons, pages, save dialogs, etc.)
            # should also be connected only once. Wrap in try/except to avoid
            # breaking if partial UI is unavailable.
            try:
                # configura tabelas para inicar sem linhas: condicao para verificar altercao nas tabelas
                self.dlg_flow_tt.tbw_1_pg2.setRowCount(0)
                self.dlg_flow_tt.tbw_2_pg2.setRowCount(0)

                # Chama paginas da GUI e funcao de mudanca de estilo dos botoes
                self.dlg_flow_tt.btn_config.clicked.connect(
                    lambda: self.SsButoes(self.dlg_flow_tt.btn_config, self.dlg_flow_tt))
                self.dlg_flow_tt.btn_config.clicked.connect(
                    lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg1_config))

                self.dlg_flow_tt.btn_input_data.clicked.connect(
                    lambda: self.SsButoes(self.dlg_flow_tt.btn_input_data, self.dlg_flow_tt))
                self.dlg_flow_tt.btn_input_data.clicked.connect(
                    lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg2_in_data))

                self.dlg_flow_tt.btn_data_va_tool.clicked.connect(
                    lambda: self.SsButoes(self.dlg_flow_tt.btn_data_va_tool, self.dlg_flow_tt))
                self.dlg_flow_tt.btn_data_va_tool.clicked.connect(
                    lambda: self.conf_rdn_data_validation_tool())
                self.dlg_flow_tt.btn_data_va_tool.clicked.connect(
                    lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg3_data_val_tool))

                self.dlg_flow_tt.btn_run.clicked.connect(
                    lambda: self.SsButoes(self.dlg_flow_tt.btn_run, self.dlg_flow_tt))
                self.dlg_flow_tt.btn_run.clicked.connect(
                    lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg4_run))

                # (other signal wiring omitted here for brevity but kept in original file)
                # We rely on the existing file to contain the remaining connections
            except Exception:
                # ignore wiring errors so dialog still shows
                pass

            # mark initialized so we don't reconnect signals on subsequent runs
            self._hidropixel_initialized = True
            # self.dlg_hidropixel.btn_help.clicked.connect()
            '''Configura os botoes da pagina da rotina do flow travel time'''
            # configura tabelas para inicar sem linhas: condicao para verificar altercao nas tabelas
            self.dlg_flow_tt.tbw_1_pg2.setRowCount(0)
            self.dlg_flow_tt.tbw_2_pg2.setRowCount(0)

            # Chama paginas da GUI e funcao de mudanca de estilo dos botoes
            self.dlg_flow_tt.btn_config.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_tt.btn_config, self.dlg_flow_tt))
            self.dlg_flow_tt.btn_config.clicked.connect(
                lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg1_config))

            self.dlg_flow_tt.btn_input_data.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_tt.btn_input_data, self.dlg_flow_tt))
            self.dlg_flow_tt.btn_input_data.clicked.connect(
                lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg2_in_data))

            self.dlg_flow_tt.btn_data_va_tool.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_tt.btn_data_va_tool, self.dlg_flow_tt))

            self.dlg_flow_tt.btn_data_va_tool.clicked.connect(
                lambda: self.conf_rdn_data_validation_tool())

            self.dlg_flow_tt.btn_data_va_tool.clicked.connect(
                lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg3_data_val_tool))

            self.dlg_flow_tt.btn_run.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_tt.btn_run, self.dlg_flow_tt))
            self.dlg_flow_tt.btn_run.clicked.connect(
                lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg4_run))

            # Configura os botoes da pagina configuration: flow travel time
            self.dlg_flow_tt.tbtn_pg1_1.clicked.connect(
                lambda: self.carrega_work_folder(self.dlg_flow_tt.le_21_pg1))

            # Configura comboboxes para receber rasters do projeto QGIS

            # self.dlg_flow_tt.cb_1_pg1.toggled.connect(lambda: self.sheet_flow_status(self.dlg_flow_tt.cb_1_pg1.isChecked()))

            # Configura os botoes da pagina input data : flow travel time
            self.dlg_flow_tt.tbtn_pg2_1.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_1_pg2))
            self.dlg_flow_tt.tbtn_pg2_2.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_2_pg2))
            self.dlg_flow_tt.tbtn_pg2_3.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_3_pg2))
            self.dlg_flow_tt.tbtn_pg2_4.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_4_pg2))
            self.dlg_flow_tt.tbtn_pg2_5.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_5_pg2))
            self.dlg_flow_tt.tbtn_pg2_6.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_7_pg2))
            self.dlg_flow_tt.tbtn_pg2_7.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_8_pg2, file_type='shp'))
            self.dlg_flow_tt.tbtn_pg2_9.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_tt.cb_6_pg2))

            # Configura os botoes da pagina run page: flow travel time
            self.dlg_flow_tt.tbtn_pg4_6.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_tt.le_6_pg4))
            self.dlg_flow_tt.tbtn_pg4_7.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_tt.le_7_pg4))
            self.dlg_flow_tt.tbtn_pg4_8.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_tt.le_8_pg4, file_type='text'))
            self.dlg_flow_tt.tbtn_pg4_9.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_tt.le_9_pg4))
            self.dlg_flow_tt.tbtn_pg4_10.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_tt.le_10_pg4))
            self.dlg_flow_tt.tbtn_pg4_11.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_tt.le_11_pg4))
            self.dlg_flow_tt.tbtn_pg4_12.clicked.connect(
                lambda: self.carrega_POI_path(0, self.dlg_flow_tt.le_13_pg4))

            # configura botoes de salvar e salvar para um arquivo: flow travel time
            # Chama funcao para definir valor de path da GUI save to project
            self.dlg_flow_tt.btn_save_file_pg1.clicked.connect(
                lambda: self.project_path())
            self.dlg_flow_tt.btn_save_file_pg1.clicked.connect(
                lambda: self.dlg_save_project_flow_tt.show())

            self.dlg_flow_tt.btn_save_file_pg2.clicked.connect(
                lambda: self.project_path())
            self.dlg_flow_tt.btn_save_file_pg2.clicked.connect(
                lambda: self.dlg_save_project_flow_tt.show())

            self.dlg_flow_tt.btn_save_file_pg4.clicked.connect(
                lambda: self.project_path())
            self.dlg_flow_tt.btn_save_file_pg4.clicked.connect(
                lambda: self.dlg_save_project_flow_tt.show())

            # Configura logica dos outputs ligados ao metodo das curvas regionais
            # River cros-sectional area
            self.dlg_flow_tt.ch_9_pg4.setEnabled(False)
            self.dlg_flow_tt.label_87.setEnabled(False)
            self.dlg_flow_tt.le_9_pg4.setEnabled(False)
            self.dlg_flow_tt.ch_20_pg4.setEnabled(False)
            self.dlg_flow_tt.tbtn_pg4_9.setEnabled(False)
            self.dlg_flow_tt.label_86.setEnabled(False)

            # River bankfull width
            self.dlg_flow_tt.ch_10_pg4.setEnabled(False)
            self.dlg_flow_tt.label_89.setEnabled(False)
            self.dlg_flow_tt.le_10_pg4.setEnabled(False)
            self.dlg_flow_tt.tbtn_pg4_10.setEnabled(False)
            self.dlg_flow_tt.label_88.setEnabled(False)
            self.dlg_flow_tt.ch_21_pg4.setEnabled(False)
            self.dlg_flow_tt.groupBox_3.toggled.connect(
                lambda: self.reginal_curve_condition())

            # configura gui save to project para criar projeto da flow travel time
            self.dlg_save_project_flow_tt.tbtn_path.clicked.connect(
                lambda: self.get_project_dir(self.dlg_save_project_flow_tt))
            self.dlg_save_project_flow_tt.btn_save_project.clicked.connect(
                lambda: self.run_save_project(self.dlg_save_project_flow_tt, 1))

            # Configura botao para ler informacoes de um arquivo enviado : flow travel time
            self.dlg_flow_tt.btn_read_pg1.clicked.connect(
                lambda: self.read_from_project(1, self.dlg_flow_tt.le_21_pg1.text()))
            self.dlg_flow_tt.btn_read_pg2.clicked.connect(
                lambda: self.read_from_project(1, self.dlg_flow_tt.le_21_pg1.text()))
            self.dlg_flow_tt.btn_read_pg4.clicked.connect(
                lambda: self.read_from_project(1, self.dlg_flow_tt.le_21_pg1.text()))

            # Configura botoes das tabelas : flow travel time
            self.dlg_flow_tt.btn_read_t1.clicked.connect(lambda: self.read_tb_from_file(
                self.dlg_flow_tt.tbw_1_pg2, self.dlg_flow_tt.le_8_pg2, 1))
            self.dlg_flow_tt.btn_read_t2.clicked.connect(lambda: self.read_tb_from_file(
                self.dlg_flow_tt.tbw_2_pg2, self.dlg_flow_tt.le_10_pg2, 2))
            self.dlg_flow_tt.btn_save_file_t1.clicked.connect(
                lambda: self.save_table_to_file_btn(1))
            self.dlg_flow_tt.btn_save_file_t2.clicked.connect(
                lambda: self.save_table_to_file_btn(2))
            self.dlg_flow_tt.btn_add_row_1.clicked.connect(
                lambda: self.add_new_row(self.dlg_flow_tt.tbw_1_pg2))
            self.dlg_flow_tt.btn_add_row_2.clicked.connect(
                lambda: self.add_new_row(self.dlg_flow_tt.tbw_2_pg2))
            self.dlg_flow_tt.btn_del_row_1.clicked.connect(
                lambda: self.delete_row(self.dlg_flow_tt.tbw_1_pg2))
            self.dlg_flow_tt.btn_del_row_2.clicked.connect(
                lambda: self.delete_row(self.dlg_flow_tt.tbw_2_pg2))

            # Configura os botoes de limpeza das variaveis : flow travel time
            self.dlg_flow_tt.btn_clear_1.clicked.connect(lambda: self.clear_table(
                self.dlg_flow_tt.tbw_1_pg2, self.dlg_flow_tt.le_8_pg2))
            self.dlg_flow_tt.btn_clear_2.clicked.connect(lambda: self.clear_table(
                self.dlg_flow_tt.tbw_2_pg2, self.dlg_flow_tt.le_10_pg2))

            # configura botoes da pagina run : flow travel time
            self.dlg_flow_tt.ch_6_pg4.toggled.connect(
                lambda: self.ativa_objetos_run_ftt())
            self.dlg_flow_tt.ch_7_pg4.toggled.connect(
                lambda: self.ativa_objetos_run_ftt())
            self.dlg_flow_tt.ch_8_pg4.toggled.connect(
                lambda: self.ativa_objetos_run_ftt())
            self.dlg_flow_tt.ch_9_pg4.toggled.connect(
                lambda: self.ativa_objetos_run_ftt())
            self.dlg_flow_tt.ch_10_pg4.toggled.connect(
                lambda: self.ativa_objetos_run_ftt())
            self.dlg_flow_tt.ch_12_pg4.toggled.connect(
                lambda: self.ativa_objetos_run_ftt())

            self.dlg_flow_tt.btn_close_pg4.clicked.connect(
                lambda: self.close_gui(1))

            # Configura run button : flow travel time
            # Configura condicao para chamar rotinas em vb
            self.dlg_flow_tt.btn_run_2.clicked.connect(
                lambda: self.CondicaoRunFlowTT())

            # Configura botao que salva projeto da rotina flow travel time
            # Configura botoes pagina de log: flow travel time
            self.dlg_flow_tt.btn_close_log.clicked.connect(
                lambda: self.close_gui(1))

            '''Configura os botoes da pagina da rotina excess rainfall'''
            # Configura botoes gerais das paginas da rotina excess rainfall e a funcao de mudanca de estilo
            self.dlg_exc_rain.btn_config.clicked.connect(lambda: self.SsButoes(
                self.dlg_exc_rain.btn_config, self.dlg_exc_rain, page=1))
            self.dlg_exc_rain.btn_config.clicked.connect(
                lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg1_config))

            self.dlg_exc_rain.btn_rain_int.clicked.connect(lambda: self.SsButoes(
                self.dlg_exc_rain.btn_rain_int, self.dlg_exc_rain, page=1))
            self.dlg_exc_rain.btn_rain_int.clicked.connect(
                lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg2_rain_int))

            self.dlg_exc_rain.btn_input_data.clicked.connect(lambda: self.SsButoes(
                self.dlg_exc_rain.btn_input_data, self.dlg_exc_rain, page=1))
            self.dlg_exc_rain.btn_input_data.clicked.connect(
                lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg3_in_data))

            self.dlg_exc_rain.btn_data_va_tool.clicked.connect(lambda: self.SsButoes(
                self.dlg_exc_rain.btn_data_va_tool, self.dlg_exc_rain, page=1))

            self.dlg_exc_rain.btn_data_va_tool.clicked.connect(
                lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg4_data_val_tool))

            self.dlg_exc_rain.btn_run.clicked.connect(lambda: self.SsButoes(
                self.dlg_exc_rain.btn_run, self.dlg_exc_rain, page=1))
            self.dlg_exc_rain.btn_run.clicked.connect(
                lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg5_run))

            # Configura botoes da pagina de configuration: excess rainfall
            self.dlg_exc_rain.tbtn_pg1_1.clicked.connect(
                lambda: self.carrega_work_folder(self.dlg_exc_rain.le_3_pg1))

            # Condicao: usuario escolhe precipitacao media (na bacia) ou destribuida (na bacia)
            self.dlg_exc_rain.le_4_pg2.setEnabled(False)
            self.dlg_exc_rain.label_32.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_4.setEnabled(False)
            self.dlg_exc_rain.label_36.setEnabled(False)
            self.dlg_exc_rain.le_3_pg2.setEnabled(False)
            self.dlg_exc_rain.label_31.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_3.setEnabled(False)
            self.dlg_exc_rain.label_35.setEnabled(False)

            # Se o usuario escolher a opcao para chuva media
            self.dlg_exc_rain.rb_1_pg1.toggled.connect(
                lambda: self.rain_def_condition(1))
            self.dlg_exc_rain.rb_2_pg1.toggled.connect(
                lambda: self.rain_def_condition(2))

            # Configura os botoes da pagina input data : excess rainfall
            self.dlg_exc_rain.tbtn_pg2_1.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_exc_rain.cb_1_pg2))
            self.dlg_exc_rain.tbtn_pg2_2.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_exc_rain.cb_2_pg2))
            self.dlg_exc_rain.tbtn_pg2_3.clicked.connect(
                lambda: self.carregaArquivos(self.dlg_exc_rain.le_3_pg2, 0, file_type='text'))
            self.dlg_exc_rain.tbtn_pg2_4.clicked.connect(
                lambda: self.carregaArquivos(self.dlg_exc_rain.le_4_pg2, 0, file_type='bin'))

            # Chama funcao para definir valor de path da GUI save to project
            self.dlg_exc_rain.btn_save_file_pg1.clicked.connect(
                lambda: self.project_path())
            self.dlg_exc_rain.btn_save_file_pg1.clicked.connect(
                lambda: self.dlg_save_project_exc_rain.show())

            self.dlg_exc_rain.btn_save_file_pg_ri.clicked.connect(
                lambda: self.project_path())
            self.dlg_exc_rain.btn_save_file_pg_ri.clicked.connect(
                lambda: self.dlg_save_project_exc_rain.show())

            self.dlg_exc_rain.btn_save_file_pg2.clicked.connect(
                lambda: self.project_path())
            self.dlg_exc_rain.btn_save_file_pg2.clicked.connect(
                lambda: self.dlg_save_project_exc_rain.show())

            self.dlg_exc_rain.btn_save_file_pg4.clicked.connect(
                lambda: self.project_path())
            self.dlg_exc_rain.btn_save_file_pg4.clicked.connect(
                lambda: self.dlg_save_project_exc_rain.show())

            # configura gui save to project para criar projeto da excess rainfall
            self.dlg_save_project_exc_rain.tbtn_path.clicked.connect(
                lambda: self.get_project_dir(self.dlg_save_project_exc_rain))
            self.dlg_save_project_exc_rain.btn_save_project.clicked.connect(
                lambda: self.run_save_project(self.dlg_save_project_exc_rain, 2))

            # Configura botao para ler informacoes de uma arquivo enviado : excess rainfall
            self.dlg_exc_rain.btn_read_pg1.clicked.connect(
                lambda: self.read_from_project(2, self.dlg_exc_rain.le_3_pg1.text()))

            self.dlg_exc_rain.btn_read_pg_ri.clicked.connect(
                lambda: self.read_from_project(2, self.dlg_exc_rain.le_3_pg1.text()))
            self.dlg_exc_rain.btn_read_pg2.clicked.connect(
                lambda: self.read_from_project(2, self.dlg_exc_rain.le_3_pg1.text()))
            self.dlg_exc_rain.btn_read_pg4.clicked.connect(
                lambda: self.read_from_project(2, self.dlg_exc_rain.le_3_pg1.text()))

            # Configura os botoes da pagina run page: excess rainfall
            self.dlg_exc_rain.ch_1_pg4.toggled.connect(
                lambda: self.ativiva_objetos_run_exc_rainf())
            self.dlg_exc_rain.ch_2_pg4.toggled.connect(
                lambda: self.ativiva_objetos_run_exc_rainf())
            self.dlg_exc_rain.ch_3_pg4.toggled.connect(
                lambda: self.ativiva_objetos_run_exc_rainf())
            self.dlg_exc_rain.ch_4_pg4.toggled.connect(
                lambda: self.ativiva_objetos_run_exc_rainf())

            self.dlg_exc_rain.tbtn_pg4_1.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_1_pg4))
            self.dlg_exc_rain.tbtn_pg4_2.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_2_pg4))
            self.dlg_exc_rain.tbtn_pg4_3.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_3_pg4))
            self.dlg_exc_rain.tbtn_pg4_4.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_4_pg4))
            self.dlg_exc_rain.tbtn_pg4_5.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_5_pg4))
            self.dlg_exc_rain.tbtn_pg4_6.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_6_pg4, file_type='bin'))

            # configura botoes da pagina run : excess rainfall
            # Configura condicao para chamar rotinas em vb
            self.dlg_exc_rain.btn_run_2.clicked.connect(
                lambda: self.condicaoRunExcessRainfall())

            self.dlg_exc_rain.btn_close_pg4.clicked.connect(
                lambda: self.close_gui(2))

            # Configura botoes da pagina rainfall interpolation
            self.dlg_exc_rain.tbtn_pg_r_1.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_exc_rain.cb_1_pg_ri))
            self.dlg_exc_rain.tbtn_pg_r_2.clicked.connect(
                lambda: self.carregaArquivos(self.dlg_exc_rain.le_2_pg_ri, 0, file_type='text'))
            self.dlg_exc_rain.tbtn_pg_r_3.clicked.connect(
                lambda: self.carregaArquivos(self.dlg_exc_rain.le_3_pg_ri, 0, file_type='text'))
            self.dlg_exc_rain.tbtn_pg_r_4.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_4_pg_ri, file_type='bin'))
            self.dlg_exc_rain.tbtn_pg_r_5.clicked.connect(
                lambda: self.save_buttons(self.dlg_exc_rain.le_5_pg_ri, file_type='vid'))
            self.dlg_exc_rain.btn_save_1_pg_ri.clicked.connect(
                lambda: self.CondicaoRunRainfall_inter(0))
            # self.dlg_exc_rain.btn_save_2_pg_ri.clicked.connect(
            #     lambda: self.CondicaoRunRainfall_inter(1))

            '''Configura os botoes da pagina da rotina flow routing'''
            # Configura botoes das paginas da flow routing assim como a funcao de mudanca de estilo
            self.dlg_flow_rout.btn_config.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_rout.btn_config, self.dlg_flow_rout))
            self.dlg_flow_rout.btn_config.clicked.connect(
                lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg1_config))

            self.dlg_flow_rout.btn_input_data.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_rout.btn_input_data, self.dlg_flow_rout))
            self.dlg_flow_rout.btn_input_data.clicked.connect(
                lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg2_in_data))

            self.dlg_flow_rout.btn_data_va_tool.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_rout.btn_data_va_tool, self.dlg_flow_rout))
            self.dlg_flow_rout.btn_data_va_tool.clicked.connect(
                lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg3_data_val_tool))

            self.dlg_flow_rout.btn_run.clicked.connect(
                lambda: self.SsButoes(self.dlg_flow_rout.btn_run, self.dlg_flow_rout))
            self.dlg_flow_rout.btn_run.clicked.connect(
                lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg4_run))

            # Configura botoes da pagina de configuration: flow routing
            self.dlg_flow_rout.tbtn_pg1_1.clicked.connect(
                lambda: self.carrega_work_folder(self.dlg_flow_rout.le_3_pg1))

            # Configura os botoes da pagina input data : flow routing
            self.dlg_flow_rout.tbtn_pg2_1.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_rout.cb_1_pg2))
            self.dlg_flow_rout.tbtn_pg2_3.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_rout.cb_3_pg2))
            self.dlg_flow_rout.tbtn_pg2_2.clicked.connect(
                lambda: self.carrega_POI_path(1, self.dlg_flow_rout.le_3_pg2))
            self.dlg_flow_rout.tbtn_pg2_4.clicked.connect(
                lambda: self.carregaArquivos(self.dlg_flow_rout.le_4_pg2, 0, file_type='bin'))
            self.dlg_flow_rout.tbtn_pg2_5.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_rout.cb_5_pg2))
            self.dlg_flow_rout.tbtn_pg2_6.clicked.connect(
                lambda: self.carregaArquivos(0, self.dlg_flow_rout.cb_4_pg2))

            # configura botoes de salvar e salvar para um arquivo: flow travel time
            self.dlg_flow_rout.btn_save_file_pg1.clicked.connect(
                lambda: self.project_path())
            self.dlg_flow_rout.btn_save_file_pg1.clicked.connect(
                lambda: self.dlg_save_project_flow_rout.show())

            self.dlg_flow_rout.btn_save_file_pg2.clicked.connect(
                lambda: self.project_path())
            self.dlg_flow_rout.btn_save_file_pg2.clicked.connect(
                lambda: self.dlg_save_project_flow_rout.show())

            self.dlg_flow_rout.btn_save_file_pg4.clicked.connect(
                lambda: self.project_path())
            self.dlg_flow_rout.btn_save_file_pg4.clicked.connect(
                lambda: self.dlg_save_project_flow_rout.show())

            # configura gui save to project para criar projeto da flow routing
            self.dlg_save_project_flow_rout.tbtn_path.clicked.connect(
                lambda: self.get_project_dir(self.dlg_save_project_flow_rout))
            self.dlg_save_project_flow_rout.btn_save_project.clicked.connect(
                lambda: self.run_save_project(self.dlg_save_project_flow_rout, 3))

            # Configura botao para ler informacoes de uma arquivo enviado : flow routing
            self.dlg_flow_rout.btn_read_pg1.clicked.connect(
                lambda: self.read_from_project(3, self.dlg_flow_rout.le_3_pg1.text()))
            self.dlg_flow_rout.btn_read_pg2.clicked.connect(
                lambda: self.read_from_project(3, self.dlg_flow_rout.le_3_pg1.text()))
            self.dlg_flow_rout.btn_read_pg4.clicked.connect(
                lambda: self.read_from_project(3, self.dlg_flow_rout.le_3_pg1.text()))

            # Configura os botoes da pagina run page: flow routing
            self.dlg_flow_rout.ch_4_pg4.toggled.connect(
                lambda: self.ativiva_objetos_run_flow_rout())
            self.dlg_flow_rout.ch_5_pg4.toggled.connect(
                lambda: self.ativiva_objetos_run_flow_rout())
            self.dlg_flow_rout.ch_13_pg4.toggled.connect(
                lambda: self.ativiva_objetos_run_flow_rout())
            self.dlg_flow_rout.tbtn_pg4_4.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_rout.le_4_pg4))
            self.dlg_flow_rout.tbtn_pg4_5.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_rout.le_5_pg4))
            self.dlg_flow_rout.tbtn_pg4_6.clicked.connect(
                lambda: self.save_buttons(self.dlg_flow_rout.le_6_pg4, file_type='text'))
            self.dlg_flow_rout.tbtn_pg4_7.clicked.connect(
                lambda: self.carregaArquivos(self.dlg_flow_rout.le_7_pg4, 0, file_type='text'))
            self.dlg_flow_rout.tbtn_pg4_8.clicked.connect(
                lambda: self.carrega_POI_path(2, self.dlg_flow_rout.le_9_pg4))

            # Configura os botoes da pagina run page: flow routing
            # pedro fr
            # self.dlg_flow_rout.btn_1_pg3.clicked.connect(
            #      lambda: self.verificar_dimensoes_rasters(
            #          paths=[
            #             self.dlg_flow_rout.cb_1_pg2.currentText(),
            #             self.dlg_flow_rout.cb_3_pg2.currentText(),
            #             self.dlg_flow_rout.cb_5_pg2.currentText(),

            #          ], modulo=3
            #      )
            #  )
            # self.dlg_flow_rout.btn_2_pg3.clicked.connect(
            #     lambda: self.validar_raster_bacia(self.dlg_flow_rout.cb_1_pg2.currentText(),modulo=3)
            # )
            # self.dlg_flow_rout.btn_3_pg3.clicked.connect(self.verificar_tempos_de_viagem)
            # self.dlg_flow_rout.btn_4_pg3.clicked.connect(self.verificar_chuva_excedente_total)
            # self.dlg_flow_rout.btn_5_pg3.clicked.connect(self.validar_hietograma_bin)
            # self.dlg_flow_rout.btn_6_pg3.clicked.connect(self.validar_regioes_interesse_raster)

            # Atualiza status dos campos da vazao observada
            self.dlg_flow_rout.ch_12_pg4.stateChanged.connect(
                lambda: self.atualizaVazaoObs())

            # configura botoes da pagina run : flow routing
            # Configura condicao para chamar rotinas em vb
            self.dlg_flow_rout.btn_run_2.clicked.connect(
                lambda: self.condicaoRunFlowRouting())

            self.dlg_flow_rout.btn_close_pg4.clicked.connect(
                lambda: self.close_gui(3))

            '''Menu Q-Hidropixel'''
            # Elimina os arquivos criados durante a execucao do hidropixel
            self.apaga_arquivos_temp()
            self.apaga_arquivos_maps()
            self.apaga_arquivos_tv()
            self.apaga_arquivos_hydrographs()
            self.apaga_arquivos_tv_for_each_poi()

            # Run the dialog event loop
            self.dlg_hidropixel.exec_()

            # Recarrega o plugin
            self.dlg_flow_tt.close()
            self.dlg_exc_rain.close()
            self.dlg_flow_rout.close()
            self.dlg_save_project_flow_tt.close()
            self.dlg_save_project_exc_rain.close()
            self.dlg_save_project_flow_rout.close()
            self.dlg_rain_interpl_run.close()
            self.dlg_about.close()
            qgis.utils.reloadPlugin('hidropixel')
