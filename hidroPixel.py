# -*- coding: utf-8 -*-
"""
/***************************************************************************
 HidroPixel
                                 A QGIS plugin
 This is just a test"
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2023 by João Vitor & Adriano Rolim
        email                : jvds@academico.ufpb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QMessageBox
from qgis.core import QgsMessageLog, Qgis
from qgis.utils import iface

# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the dialog
import os.path
import sys, os
from .hidroPixel_dialog import HidroPixelDialog
from pathlib import Path
from hidropixel.modulos_files.RDC_variables import RDCVariables
from hidropixel.modulos_files.global_variables import GlobalVariables

# Importing libs
import numpy as np
from osgeo import ogr, gdal

class HidroPixel:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'HidroPixel_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&HidroPixel')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('HidroPixel', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/hidroPixel/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'HidroPixel Plugin'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&HidroPixel'),
                action)
            self.iface.removeToolBarIcon(action)



    def carregaArquivos(self):
        """Esta função é utilizada para adicionar layers no projeto"""
        # Inicializa as variáveis
        self.abrir_arquivo = None
        self.extensao = None

        # Janela de diálogo com o Usuário
        self.abrir_arquivo,_ = QFileDialog.getOpenFileName(caption="Escolha os arquivos referentes!", filter="Text (*.txt);;Raster (*.bmp *.png *.jpg *.tif *.gif *.rst)")
        
        # Verificar se algum arquivo foi selecionado
        if self.abrir_arquivo != "":
            # Adiciona o arquivo selecionado a lineEdit
            self.dlg.lineEdit.setText(self.abrir_arquivo)
            
            # Verificando a extensão do arquivo escolhido
            self.extensao = Path(self.abrir_arquivo).suffix.lower()
            return self.abrir_arquivo
        else:
            # Caso o usuário não selecione algum arquivo
            result ="Nenhum arquivo foi selecionado!"
            QMessageBox.warning(None, "ERROR!", result)

        
    def leh_bacia(self,arquivo):
        """Esta função é utilizada para ler as informações da bacia hidrográfica (arquivo .rst)"""
        # Criando instâncias das classes
        global_vars = GlobalVariables()
        rdc_vars = RDCVariables()

        # Tratamento de erros: verifica se o arquivo foi corretamente enviado
        if arquivo:
            # Recebendo o arquivo enviado através do usuário
            file = arquivo
        else:
            # Exibe uma mensagem de erro
            result ="Nenhum arquivo foi selecionado!"
            QMessageBox.warning(None, "ERROR!", result)

        # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
        rst_file_bacia = gdal.Open(file)

        # Lendo os dados raster como um array 
        dados_lidos_bacia = rst_file_bacia.GetRasterBand(1).ReadAsArray()
        
        # Tratamento de erro: verifica se o arquivo foi aberto corretamente
        if rst_file_bacia is not None:

            # atualizando os valores das variáveis para coletar o numéro de linhas e colunas do arquivo raster lido
            rdc_vars.nlin,rdc_vars.ncol = rst_file_bacia.RasterXSize,rst_file_bacia.RasterYSize

            # Determinando o numéro de elementos contidos no arquivo raster
            num_elements_bacia = dados_lidos_bacia.size

            # Tratamento de erros: verifica se o número de elementos (pixel) do arquivo está de acordo com as dimensões da matriz da bacia hidrográfica
            if num_elements_bacia != rdc_vars.nlin * rdc_vars.ncol:
                result = f"ERROR! As dimensões do arquivo raster ({rdc_vars.nlin},{rdc_vars.ncol}) são diferentes do número total de \
                      elementos {num_elements_bacia}. Assim, não é possível ler o arquivo raster '{file}' e armazená-lo na matriz destinada."
                QMessageBox.warning(None, "ERROR!", result)
            else:
                # Reorganizando os dados lidos da bacia em uma nova matriz chamada bacia.
                # global_vars.bacia = dados_lidos_bacia
                global_vars.bacia = str(dados_lidos_bacia)
                # Fechando o dataset GDAL
                rst_file_bacia = None
        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {file}"
            QMessageBox.warning(None, "ERROR!", resulte)

        return global_vars.bacia
        
    def leh_caracteristica_dRios(self, arquivo):
        """Esta função é utilizada para ler as informações acerca da característica dos rios de uma bacia hidrográfica (texto .txt)"""
        # Criando instâncias das classes
        global_vars = GlobalVariables()

         # Tratamento de erros: verifica se o arquivo foi corretamente enviado
        if arquivo:
            # Abrindo o arquivo de texto (.txt) com as informações acerca das classes dos rios
            file = arquivo
        else:
            # Exibe uma mensagem de erro
            result ="Nenhum arquivo foi selecionado!"
            QMessageBox.warning(None, "ERROR!", result)

        # Abrindo arquivo com as características dos rios da bacia hidrográfica
        with open(file, 'r', encoding='utf-8') as arquivo_txt:
            #  Atualizando as variáveis que dependem
            arquivo_txt.readline()
            global_vars.nclasses = int(arquivo_txt.readline().strip())  # com base no arquivo fornecido, o número de classes está na segunda linha!! (X)
            arquivo_txt.readline()
            # Inicializando as listas
            j_list = []
            Sclasse_list = []
            Mannclasse_list = []
            Rhclasse_list = []

            # Iterando sobre as linhas do arquivo
            for line in arquivo_txt:
                # Divide a linha nos espaços em branco e converte para float para guardar os valores das colunas
                indice, Scla, Mann, Rh = map(float, line.split())

                # Adiciona os valores às listas
                j_list.append(indice)
                Sclasse_list.append(Scla)
                Mannclasse_list.append(Mann)
                Rhclasse_list.append(Rh)

                # Convertendo as listas em arrays e armazendo nas respectivas variáveis
                global_vars.j = np.array(j_list)
                global_vars.Sclasse = np.array(Sclasse_list)
                global_vars.Mannclasse = np.array(Mannclasse_list)
                global_vars.Rhclasse = np.array(Rhclasse_list)

        return global_vars.j, global_vars.Sclasse, global_vars.Mannclasse, global_vars.Rhclasse
    

    def leh_classes_rios(self, arquivo):
        """Esta função é utilizada para ler as informações acerca da classe dos rios da bacia hidrográfica (arquivo raster -  .rst)"""
        # Criando instâncias das classes
        global_vars = GlobalVariables()
        rdc_vars = RDCVariables()

        # Tratamento de erros: verifica se o arquivo foi corretamente enviado
        if arquivo:
            # Obtendo o arquivo referente as classes dos rios da bacia hidrográfica
            file = arquivo
        else:
            # Exibe uma mensagem de erro
            result ="Nenhum arquivo foi selecionado!"
            QMessageBox.warning(None, "ERROR!", result)

         # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
        rst_file_claRIO = gdal.Open(file)
        
        # Lendo os dados raste como um array 
        dados_lidos_raster_claRIO = rst_file_claRIO.GetRasterBand(1).ReadAsArray()

        #  Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_claRIO is not None:
            # Lendo as dimensões do arquivo raster
            rdc_vars.nlin, rdc_vars.ncol = rst_file_claRIO.RasterXSize, rst_file_claRIO.RasterYSize

            # Determinando o número de elementos (pixel) do arquivo raster
            num_elements_claRIOS = dados_lidos_raster_claRIO.size

            # Tratamento de erros: verifica se o número de elementos do arquivo raster está consoante as dimensões da matriz das classes dos rios
            if num_elements_claRIOS != rdc_vars.nlin * rdc_vars.ncol:
                result = f"ERROR! As dimensões do arquivo raster ({rdc_vars.nlin},{rdc_vars.ncol}) são diferentes do número total de \
                      de elementos {num_elements_claRIOS}. Assim, não é possível ler o arquivo raster '{file}' e armazená-lo na matriz destinada."
                QMessageBox.warning(None, "ERROR!", result)
            else:
                # Reorganizando os dados lidos em uma nova matriz, essa possui as informações sobre as classes dos rios
                global_vars.classerio = dados_lidos_raster_claRIO

                # Fechando o dataset GDAL referente ao arquivo raster
                rst_file_claRIO = None
        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {file}"
            QMessageBox.warning(None, "ERROR!", resulte)

        return global_vars.classerio

           
    def leh_direcoes_de_fluxo(self):
        """Esta função é utilizada para ler as informações acerca da direção de escoamento dos rios (arquivo raster - .rst)"""
        # Criando instâncias das classes
        global_vars = GlobalVariables()
        rdc_vars = RDCVariables()

        # Definindo a numeração das direções
        global_vars.A, global_vars.B, global_vars.C, global_vars.D = 1, 2, 4, 8
        global_vars.E, global_vars.F, global_vars.G, global_vars.H = 16, 32, 64, 128

        # Definindo a posição relativa dos pixels vizinhos
        # lin viz = lin centro + dlin(i)
        # col viz = col centro + dcol(i)
        dlin = [-1, 0, 1, 1, 1, 0, -1, 1]
        dcol = [1, 1, 1, 0, -1, -1, -1, 0]
       
        # ATENÇÃO PARA O VALOR NUMÉRICO DAS DIRECÕES
        # ---------------------------------------------------------
        # - G  H  A      ArcView:  32 64 128    MGB-IPH:  64  128  1 -
        # - F  *  B                16  *  1               32   *   2 -
        # - E  D  C                 8  4  2               16   8   4 -

        # Recebendo os arquivos necessários
        rdc_vars.nomeRST = self.carregaArquivos()
        rdc_vars.nomeRDC = self.carregaArquivo()

        # Abrindo o arquivo RDC
        file = rdc_vars.nomeRDC
        with open(file, 'r') as rdc_file:
            # Separando os dados do arquivo RDC em função das linhas que contém alguma das palavras abaixo
            k_words = ["columns", "rows", "ref. system", "ref. units", "min. X", "max. X", "min. Y", "max. Y", "resolution"]
            lines_RDC = [line.strip() for line in rdc_file.readlines() if any(word in line for word in k_words)]
            
            # Iterando sobre a lista de lines_rdc para guardas as informações das palavras da lista (k_words) nas ruas respectivas variáveis
            for line in lines_RDC:
                # Separando as linhas de acordo com o refencial (:)
                split_line = line.split(":")
                # Armazenando o primeiro valor da linha (antes do sinal ":")em uma variável 
                # e retirando os espaços (caracter) do inicio e fim da linha repartida
                key = split_line[0].strip()
                # Armazenando o segundo valor da linha (antes do sinal ":") em uma variáveis 
                # e retirando os espaços (caracter) do inicio e fim da linha repartida
                value = split_line[-1].strip()

                # Estrutura condicional para verificar quais são as informações de cada linha e armazenando elas em suas respectivas variáveis
                if key == "rows":
                    rdc_vars.nlin = int(value)
                elif key == "columns":
                    rdc_vars.ncol = int(value)
                elif key == "ref. system":
                    rdc_vars.sistemaref = value
                elif key == "ref. units":
                    rdc_vars.unidaderef3 = value
                elif key == "min. X":
                    rdc_vars.xmin = float(value)
                elif key == "max. X":
                    rdc_vars.xmax = float(value)
                elif key == "min. Y":
                    rdc_vars.ymin = float(value)
                elif key == "max. Y":
                    rdc_vars.ymax = float(value)
                elif key == "resolution":
                    rdc_vars.dx = float(value)
        
        # Atualizando algumas variáveis com as informações coletadas do arquivo RDC
        rdc_vars.dx3 = rdc_vars.dx
        rdc_vars.Xres2 = rdc_vars.dx
        rdc_vars.Xres = float(rdc_vars.Xres2)
        rdc_vars.Xres = rdc_vars.Yres

        # Abrindo o arquivo raster 
        rst_file_dir = gdal.Open(rdc_vars.nomeRST)

        # Lendo os dados raster como um array
        dados_lidos_direcoes = rst_file_dir.GetRasterBand(1).ReadAsArruy()

        # Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_dir is not None:
            # Determinando a quantidade de elementos (pixel) no arquivo raster
            num_elementos_rst_dir = dados_lidos_direcoes.size

            # Tratamento de erros: verifica se as dimensões do arquivo raster estão consoante o numéro de elementos (pixel)
            if num_elementos_rst_dir != global_vars.nlin * global_vars.ncol:
                result = f"ERROR! As dimensões do arquivo raster ({rdc_vars.nlin},{rdc_vars.ncol}) são diferentes do número total de \
                      de elementos {num_elementos_rst_dir}. Assim, não é possível ler o arquivo raster e armazená-lo na matriz destinada."
                QMessageBox.warning(None, "ERROR!", result)
            else:
                """Se os o número de elementos (pixel) estiver de acordo com as dimensões do arquivo raster, não ocorrerão erros."""
                # Reorganizando os dados lidos na matriz destinadas às informações da drenagem da bacia hidrográfica
                global_vars.dir = dados_lidos_direcoes

            # Fechando o dataset GDAL referente ao arquivo raster
            rst_file_dir = None
        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {rdc_vars.nomeRST}"
            QMessageBox.warning(None, "ERROR!", resulte)

        # Códigos de direções de fluxos
        global_vars.maxdir = -10000000

        # Iniciando a iterações com base nas linhas e colunas 
        for l in range(1, rdc_vars.nlin +1):
            for c in range(1, rdc_vars.ncol +1):
                # Verifica se o valor atual do elemento (i,j) da matriz é maior que o valor maxdir
                if global_vars.dir[l-1,c-1] > global_vars.maxdir:
                    # Atualiza a variável maxdir de acordo com o novo maior valor da matriz dir
                    global_vars.maxdir = global_vars.dir[l-1,c-1]

        # Verificação do valor da variável maxdir (?)
        if global_vars.maxdir > 128:
            # Mapeamento das direções de fluxo do tipo idrisi 
            idrisi_map = {
                45: 1,
                90: 2,
                135: 4,
                180: 8,
                225: 16,
                270: 32,
                315: 64,
                360: 128
            }

            # Atualizando os valores da matriz das direções de fluxo com base no mapeamento feito
            for lin in range(1, rdc_vars.nlin + 1):
                for col in range(1, rdc_vars.ncol + 1):
                    # Verifica se o valor atual da variável maxdir está presente no mapeamento
                    if global_vars.dir[lin - 1, col - 1] in idrisi_map:
                        # Atualiza o valor do elemento atual da matriz dir de acordo com os novos valores
                        global_vars.dir[lin - 1, col - 1] = idrisi_map[dir[lin - 1, col - 1]]
        
        # Tratamento das direções na borda
        global_vars.dir[0, :] = 128
        global_vars.dir[-1, :] = 8
        global_vars.dir[:, 0] = 32
        global_vars.dir[:, -1] = 2

        return global_vars.dir

    def leh_drenagem(self):
        """Esta função é utilizada para ler as informações acerca da drenagem dos rios (arquivo raster - .rst)"""
        # Criando instâncias das classes
        global_vars = GlobalVariables()
        rdc_vars = RDCVariables()
    
        # Obtendo o arquivo referente as calasses dos rios da bacia hidrográfica
        file = self.carregaArquivos() 

        # Abrindo o arquivo raster com as informações acerda do sistema de drenagem da bacia hidrográfica
        rst_file_drenagem = gdal.Open(file)
        
        # Lendo os dados raster como um array
        dados_lidos_drenagem = rst_file_drenagem.GetRasterBand(1).ReadAsArruy()

        # Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_drenagem is not None:
            # Lendo as dimensões do arquivo raster (linhas, colunas)
            global_vars.nlin, global_vars.ncol = rst_file_drenagem.RasteXSize, rst_file_drenagem.RasterYSize 

            # Determinando a quantidade de elementos (pixel) no arquivo raster
            num_elementos_rst_dren = dados_lidos_drenagem.size

            # Tratamento de erros: verifica se as dimensões do arquivo raster estão consoante o numéro de elementos (pixel)
            if num_elementos_rst_dren != global_vars.nlin * global_vars.ncol:
                result = f"ERROR! As dimensões do arquivo raster ({rdc_vars.nlin},{rdc_vars.ncol}) são diferentes do número total de \
                      de elementos {num_elementos_rst_dren}. Assim, não é possível ler o arquivo raster e armazená-lo na matriz destinada."
                QMessageBox.warning(None, "ERROR!", result)
            else:
                """Se os o número de elementos (pixel) estiver de acordo com as dimensões do arquivo raster, não ocorrerão erros."""
                # Reorganizando os dados lidos na matriz destinadas às informações da drenagem da bacia hidrográfica
                global_vars.dren = dados_lidos_drenagem

            # Fechando o dataset GDAl referente ao arquivo raster
            rst_file_drenagem = None
        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {file}"
            QMessageBox.warning(None, "ERROR!", resulte)

        return global_vars.dren

    def leh_modelo_numerico_dTerreno(self):
        """Esta função é utilizada para ler as informações acerca do modelo numérico do terreno (arquivo raster - .rst)"""
        # Criando instâncias das classes
        global_vars = GlobalVariables()
        rdc_vars = RDCVariables()

        # Obtendo o arquivo referente ao MDE da bacia hidrográfica
        file = self.carregaArquivos()

        # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
        rst_file_MDE = gdal.Open(file)

        # Lendo os dados raster como um array
        dados_lidos_MDE = rst_file_MDE.GetRasterBand(1).ReadAsArray()

        #  Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_MDE is not None:
            # Lendo as dimensões do arquivo raster ligado ao MDE da bacia hidrgráfica
            rdc_vars.nlin, rdc_vars.ncol = rst_file_MDE.RasterYSize, rst_file_MDE.RasterXSize

            # Determinando o número de elementos (pixel) do arquivo raster
            num_elements_MNT = dados_lidos_MDE.size

            # Tratamento de erros: verifica se o número de elementos do arquivo está de acordo com as dimensões da matriz ligada ao MNT
            if num_elements_MNT != rdc_vars.nlin * rdc_vars.ncol:
                result = f"ERROR! As dimensões do arquivo raster ({rdc_vars.nlin},{rdc_vars.ncol}) são diferentes do número total de \
                      de elementos {num_elements_MNT}. Assim, não é possível ler o arquivo raster '{file}' e armazená-lo na matriz destinada."
                QMessageBox.warning(None, "ERROR!", result)
            else:
                # Reoganizando os dados lidos em uma nova matriz que possuirá os dados ligados ao MDE da baica hidrográfica
                global_vars.MDE = dados_lidos_MDE
                
                # Fechando o dataset GDAL
                rst_file_MDE = None
        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {file}"
            QMessageBox.warning(None, "ERROR!", resulte)

        return global_vars.MDE

    def leh_precipitacao_24h(self):
        """Esta função é utilizada para ler as informações acerca da precipitação das últimas 24 horas, P24 (arquivo texto - .txt)"""
        # Criando instâncias das classes
        global_vars = GlobalVariables()
        rdc_vars = RDCVariables()

        # Coledando os arquivo fornecido
        file = self.carregaArquivos()

        # lendo os arquivos acerda da precipitação das últimas 24 horas
        with open(file, 'r') as arquivo_txt:
            dados_lidos_P24 = float(arquivo_txt.read()) # considerando que no arquivo só possui um valor de precipitação

        # Armazenando o valor da precipitação de 24 horas em uma variável específica
        global_vars.P24 = dados_lidos_P24

        return global_vars.P24

    def leh_uso_do_solo(self):
        """Esta função é utilizada para ler as informações acerca do uso do solo (arquivo raster - .rst)"""
        # Criando instâncias das classes
        global_vars = GlobalVariables()
        rdc_vars = RDCVariables()

        # Obtendo o arquivo raster referente ao uso do solo
        file = self.carregaArquivos()

        # Abrindo o arquivo raster com as informações acerda do uso do solo da bacia hidrográfica
        rst_file_usoSolo = gdal.Open(file)

        # Lendo os dados do arquivo raster como um array
        dados_lidos_usoSolo = rst_file_usoSolo.GetRasterBand(1).ReadAsArray()

        # Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_usoSolo is not None:
            # Lendo as dimensões do arquivo raster (linhas, colunas)
            rdc_vars.nlin, rdc_vars.ncol = rst_file_usoSolo.RasterXSize, rst_file_usoSolo.RasterYSize

            # Determinando a quantidade de elementos (pixel) no arquivo raster lido
            num_elementos_raster_usoSolo = dados_lidos_usoSolo.size

            # Tratamento de erros: verifica se a quantidade de elementos do arquivo raster está consoante as suas dimensões
            if num_elementos_raster_usoSolo != rdc_vars.nlin * rdc_vars.ncol:
                result = f"ERROR! As dimensões do arquivo raster ({rdc_vars.nlin},{rdc_vars.ncol}) são diferentes do número total de \
                      de elementos {num_elementos_raster_usoSolo}. Assim, não é possível ler o arquivo raster '{file}' e armazená-lo na matriz destinada."
                QMessageBox.warning(None, "ERROR!", result)  
            else:
                """Se os o número de elementos (pixel) estiver de acordo com as dimensões do arquivo raster, não ocorrerão erros."""
                # Reorganizando os dados lidos na matriz destinadas às informações da drenagem da bacia hidrográfica
                global_vars.usosolo = dados_lidos_usoSolo 

                # Inicializando as variáveis fundamentais
                global_vars.Nusomax = 0
                bacia_rst = self.leh_bacia() 

                # Inicia uma estrutura de repetição para ler os valores das linhas da matriz bacia_rst
                for l in range(1, rdc_vars.nlin + 1):
                    # Inicia uma estrutura de repetição para ler os valores das colunas da matriz bacia_rst
                    for c in range(1, rdc_vars.ncol + 1):
                        # Estrutura condicional para coletar apenas os valores maiores que zero, 
                        # ou seja, aqueles presentes na delimitação da bacia hidrográfica 
                        if bacia_rst[l-1, c-1] > 0:
                            # Determina os valores valores dos pixels da matriz com os dados do uso do solo
                            if global_vars.usosolo[l-1, c-1] > global_vars.Nusomax:
                                # Atualiza a variável que armazena os maiores valores dos pixels do uso do solo
                                global_vars.Nusomax = global_vars.usosolo[l-1, c-1]

        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {file}"
            QMessageBox.warning(None, "ERROR!", resulte)

        return global_vars.Nusomax

    def leh_uso_manning (self):
        """Esta função é utilizada para ler as informações acerca do uso do solo e o coeficiente de rugosidade de Manning (arquivo texto - .txt)"""
        # Criando instâncias das classes
        global_vars = GlobalVariables()
        rdc_vars = RDCVariables()

        # Recebendo o arquivo
        file = self.carregaArquivo()

        # Criando variável extra, para armazenar os tipos de uso e coeficente de Manning
        uso_manning = []
        coef_maning = []

        # Abrindo o arquivo que contém o coeficiente de Manning para os diferentes usos do solo
        with open(file, 'r', encoding='utf-8') as arquivo_txt:

        #  Ignora a primeira linha, pois ela contém apenas o cabeçalho
            firt_line = arquivo_txt.readline()

            # Lê as informações de uso do solo e coeficiente de Manning 
            for line in arquivo_txt:

                # Coletando as informações de cada linha
                info = line.strip().split()

                # Armazenando os valores das linhas nas suas respectivas variáveis
                global_vars.usaux = int(info[0])
                coef_maning = float(info[1])

                # Adionado cada valor as suas respectivas variáveis
                uso_manning = np.append(uso_manning,global_vars.usaux)
                global_vars.Mann = np.append(global_vars.Mann,coef_maning)
            
        return uso_manning, global_vars.Mann
    
    
    def run(self):
        """Run method that performs all the real work"""

        # Sempre inicialize self.dlg
        self.dlg = HidroPixelDialog()

        # Apenas mostra a janela se for a primeira vez que o plugin é iniciado
        if self.first_start:
            self.first_start = False

        # Conectando os radioButtons a suas respectivas funções
        self.dlg.radioButton.clicked.connect(self.carregaArquivos)
        self.dlg.radioButton_2.clicked.connect(self.carregaArquivos)
        self.dlg.radioButton_3.clicked.connect(self.carregaArquivos)
        self.dlg.radioButton_4.clicked.connect(self.carregaArquivos)

        # Dhow the dialog
        self.dlg.show()
        
        # Ativa a função que carrega o arquivo selecionado
        # self.dlg.toolButton.clicked.connect(self.carregaArquivos)

        # Run the dialog event loop
        result = self.dlg.exec_()

        # See if OK was pressed
        if result:
            # Verifica se o botão foi clicado, caso verdade, será executada a função referente a ele se o arquivo for o correto
            if self.dlg.radioButton.isChecked():
                self.leh_bacia(self.abrir_arquivo)
                self.iface.messageBar().pushMessage('Success', "Execution successful!", level=Qgis.Info)

            # Verifica se o botão foi clicado, caso verdade, será executada a função referente a ele se o arquivo for o correto
            elif self.dlg.radioButton_2.isChecked():
                self.leh_caracteristica_dRios(self.abrir_arquivo)
                self.iface.messageBar().pushMessage('Success', "Execution successful!", level=Qgis.Info)  

            # Verifica se o botão foi clicado, caso verdade, será executada a função referente a ele se o arquivo for o correto
            elif self.dlg.radioButton_3.isChecked():
                self.leh_classes_rios(self.abrir_arquivo)
                self.iface.messageBar().pushMessage('Success', "Execution successful!", level=Qgis.Info)  

            # Verifica se o botão foi clicado, caso verdade, será executada a função referente a ele se o arquivo for o correto
            elif self.dlg.radioButton_4.isChecked():
                self.leh_uso_manning(self.abrir_arquivo)
                self.iface.messageBar().pushMessage('Success', "Execution successful!", level=Qgis.Info)

            # Fecha a janela de diálogo
            self.dlg.close()
