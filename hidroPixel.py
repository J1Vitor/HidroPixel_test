# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Hidropixel
 Add the description
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2023 by João Vitor & Adriano Rolim
        email                : jvds@academico.ufpb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt import uic
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QRegularExpression
from qgis.PyQt.QtGui import QIcon, QRegExpValidator, QIntValidator, QFont
from qgis.PyQt.QtWidgets import QApplication, QMainWindow, QAction, QFileDialog, QMessageBox, QTableWidgetItem, QWidget, QStackedWidget
from qgis.core import QgsMessageLog, Qgis, QgsProject, QgsRasterLayer
from qgis.utils import iface


# Import the code for the dialog
import os.path
import sys, os
import glob
import logging
from .hidroPixel_dialog import HidroPixelDialog
from pathlib import Path
from datetime import datetime
# A importação dos módulos contendo as variáveis
from hidropixel.modulos_files.RDC_variables import RDCVariables
from hidropixel.modulos_files.global_variables import GlobalVariables

# Initialize Qt resources from file resources.py
from .resources import *

# Importing libs
import numpy as np
import subprocess
from osgeo import ogr, gdal, gdalconst
from functools import wraps

class HidroPixel:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Hidropixel_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Hidropixel')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Criando instâncias das classes: apenas para inicalizar as variáveis que não são arrays. Estes dependem da dimensão do raster enviado
        self.global_vars = GlobalVariables(0,0)
        self.rdc_vars = RDCVariables(0,0)

        # Seleciona o diretório atual do plugin
        file_path = os.path.dirname(__file__)

        # Inicia a interface gráfica da rotina flow travel time
        ui_file = os.path.join(file_path, 'hidroPixel_dialog_flow_tt.ui')

        # Inicia a interface gráfica da rotina excess rainfall
        ui_file1 = os.path.join(file_path, 'hidroPixel_dialog_exec_rainfall.ui')

        # Inicia a interface gráfica da rotina flow routing
        ui_file2 = os.path.join(file_path, 'hidroPixel_dialog_flow_rout.ui')

        # Inicia a interface gráfica da pagina run da função rainfall interpolation
        ui_file3 = os.path.join(file_path, 'hidroPixel_dialog_run_rainfall_interpol.ui')

        # inicia instânica das diferentes routinas do plugin Hidropixel
        self.dlg_flow_tt = uic.loadUi(ui_file)
        self.dlg_exc_rain = uic.loadUi(ui_file1)
        self.dlg_flow_rout = uic.loadUi(ui_file2)
        self.dlg_rain_interpl_run = uic.loadUi(ui_file3)

        # Cria outras variáveis necessárias
        self.save_result = None
        self.fn_n_conect_dren = None
        self.fn_num_pix_dren = None
        self.fn_comp_acum = None
        self.fn_comp_foz = None
        self.fn_decli_pix = None
        self.fn_decli_pix_jus = None
        self.fn_temp_total = None
        self.fn_travel_time_map = None
        self.fn_hidrograma = None
        self.flag = None
        self.flag_1 = None
        self.alfa, self.delta_t, self.criterio_parada, self.beta = 0,0,0,0
        self.numero_total_pix = 0
        self.num_intervalos = 0
        self.volume_total = 0.0 
        self.quantidade_blocos_chuva = 0
        self.chuva_excedente_calc = 0
        self.blocos_vazao = 0
        self.Pexc = 0
        self.diretorio_atual = os.path.dirname(os.path.abspath(__file__))
        self.file_name_tb1:str = ''
        self.file_name_tb2:str = ''
        
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Hidropixel', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        # Armazena diretório do plugin
        icon_path = self.diretorio_atual + '\icons\icon.png'

        self.add_action(
            icon_path,
            text=self.tr(u'Hidropixel Plugin'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = False

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Hidropixel'),
                action)
            self.iface.removeToolBarIcon(action)

    def carrega_work_folder(self, line_edit):
        '''Esta função define a pasta padrão tanto para buscar, quanto para salvar os arquivos'''
        # Define as variáveis e configurações da janela de escolha do arquivo
        pasta = None
        line_edit.setText('')
        options = QFileDialog.Options()
        pasta = QFileDialog.getExistingDirectory(None, caption = 'Select your work folder!', options = options)

        if pasta != '':
            # Se o usário enviar um arquivo, este será armazenado na sua referida line edit
            line_edit.setText(pasta)
        else:
            # Caso contrário, será mostrada uma mensagem de aviso
            result ="Wait! You did not select any folder."
            QMessageBox.warning(None, "No folder selected", result)

        return pasta

    def carrega_arquivos(self, lineEdit, file_type="raster", qtd=1):
        """Esta função é utilizada para adicionar os arquivos enviados pelo usuário ao plugin"""
        # Define as variáveis e configurações da janela de escolha do arquivo
        file_ = None
        options = QFileDialog.Options()
        directory = self.dlg_flow_tt.le_21_pg1.text()

        while True:  # Loop até que o usuário selecione um arquivo ou cancele
            if qtd == 2:
                file_, _ = QFileDialog.getOpenFileNames(None, caption="Select the files!", directory=directory, filter="GeoTIFF (*.tif)", options=options)
                if file_:
                    lineEdit.setPlainText("\n".join(file_))
                    self.rdc_vars.nomeRDC = file_[0] if file_ else None
                    self.rdc_vars.nomeRST = file_[1] if len(file_) > 1 else None
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No file selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break  
            else:
                # Janela de diálogo com o Usuário
                if file_type == "raster".lower():
                    file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory=directory, filter="GeoTIFF (*.tif)", options=options)
                elif file_type == "text".lower():
                    file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory=directory, filter="Text Files (*.txt)", options=options)

                # Verificar se algum arquivo foi selecionado
                if file_:
                    # Adiciona o arquivo selecionado a lineEdit
                    lineEdit.setText(file_)
                    return file_
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break 

    def save_buttons(self, line_edit,file_type = 'raster'):
        '''Esta função configura os botões da salvar (criar arquivo)'''
        # Seleciona o arquivo enviado pelo usuário
        while True:
            # Obtendo o caminho do arquivo a ser salvo usando um diálogo de arquivo
            if file_type == 'raster':
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file",'',"GeoTIFF(*.tif)")
                if file_name:
                    line_edit.setText(file_name)
                    break
                else:
                    # O usuário não solucionou um arquivo (um caminho para salvar o arquivo de saída)
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break
            elif file_type == 'text':
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file",'',"Text (*.txt)")
                if file_name:
                    line_edit.setText(file_name)
                    break
                else:
                    # O usuário não solucionou um arquivo (um caminho para salvar o arquivo de saída)
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break

    def save_to_file(self, function, page):
        '''Esta função gera o arquivo com as informações enviadas por meio do usuário por página
        Function: Indica qual função a página pertence
                function == 1: Flow travel time;
                function == 2: Excess rainfall;
                function == 3: Flow routing
        Page: variável que identifica a página do arquivo que será escrito
                page == 1: Configurations;
                page == 2: Input Data;
                page == 3: Data Validation;
                page == 4: Run
        '''
        # Seleciona o arquivo enviado pelo usuário
        while True:
            if function == 1:
                if page == 1:
                    # Obtendo o caminho do arquivo a ser salvo usando um diálogo de arquivo
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "ftt_configuration_page", "Text Files (*.txt)")
                    # Verifica se o usuário selecionou um arquivo
                    if file_name:
                        # Armazenará as informações da primeira página
                        with open(file_name, 'w', encoding ='utf-8') as arquivo_txt:
                            arquivo_txt.write('Flow Travel Time - Configuration\n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('GENERAL INFORMATIONS')
                            arquivo_txt.write('Minimum slope surface travel time determination (m/km):\n')
                            arquivo_txt.write(f'={self.dlg_flow_tt.le_1_pg1.text()}\n')
                            arquivo_txt.write('Orthogonal step for distance computation (dx):\n')
                            arquivo_txt.write(f'={self.dlg_flow_tt.le_3_pg1.text()}\n')
                            arquivo_txt.write('Diagonal step for distance computation (dx):\n')
                            arquivo_txt.write(f'={self.dlg_flow_tt.le_4_pg1.text()}\n')
                            
                            arquivo_txt.write('CHANEL INFORMATIONS')
                            arquivo_txt.write('\n')
                            if self.dlg_flow_tt.cb_1_pg1.isChecked():
                                arquivo_txt.write('Sheet flow lenght (m):\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.cb_1_pg1.isChecked()}\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_13_pg1.text()}\n')
                                arquivo_txt.write('Manning coefficient for river segments without cross-section information:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_14_pg1.text()}\n')
                                arquivo_txt.write('Maximum river segment lenght for river segments without cross-section information (m)\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_15_pg1.text()}\n')
                                arquivo_txt.write(f'Coefficient c = {self.dlg_flow_tt.le_16_pg1.text()}\n')
                                arquivo_txt.write(f'Coefficient d = {self.dlg_flow_tt.le_17_pg1.text()}\n')
                                arquivo_txt.write(f'Coefficient g = {self.dlg_flow_tt.le_18_pg1.text()}\n')
                                arquivo_txt.write(f'Coefficient h = {self.dlg_flow_tt.le_19_pg1.text()}\n')
                                
                                arquivo_txt.write('RESERVOIRS INFORMATIONS')
                                arquivo_txt.write('\n')
                                arquivo_txt.write('Mean depth of lake or reservoir (m):\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_20_pg1.text()}\n')

                                arquivo_txt.write('Flow direction code: \n')
                                arquivo_txt.write(f'A = {self.dlg_flow_tt.le_5_pg1.text()}\n')
                                arquivo_txt.write(f'B = {self.dlg_flow_tt.le_6_pg1.text()}\n')
                                arquivo_txt.write(f'C = {self.dlg_flow_tt.le_7_pg1.text()}\n')
                                arquivo_txt.write(f'D = {self.dlg_flow_tt.le_8_pg1.text()}\n')
                                arquivo_txt.write(f'E = {self.dlg_flow_tt.le_9_pg1.text()}\n')
                                arquivo_txt.write(f'F = {self.dlg_flow_tt.le_10_pg1.text()}\n')
                                arquivo_txt.write(f'G = {self.dlg_flow_tt.le_11_pg1.text()}\n')
                                arquivo_txt.write(f'H = {self.dlg_flow_tt.le_12_pg1.text()}\n')
                                arquivo_txt.write('lineage: This file was created automatically by Hidropixel')

                            else:
                                arquivo_txt.write('Manning coefficient for river segments without cross-section information:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_14_pg1.text()}\n')
                                arquivo_txt.write('Maximum river segment lenght for river segments without cross-section information (m)\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_15_pg1.text()}\n')
                                arquivo_txt.write(f'Coefficient c = {self.dlg_flow_tt.le_16_pg1.text()}\n')
                                arquivo_txt.write(f'Coefficient d = {self.dlg_flow_tt.le_17_pg1.text()}\n')
                                arquivo_txt.write(f'Coefficient g = {self.dlg_flow_tt.le_18_pg1.text()}\n')
                                arquivo_txt.write(f'Coefficient h = {self.dlg_flow_tt.le_19_pg1.text()}\n')
                                
                                arquivo_txt.write('RESERVOIRS INFORMATIONS')
                                arquivo_txt.write('\n')
                                arquivo_txt.write('Mean depth of lake or reservoir (m):\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_20_pg1.text()}\n')

                                arquivo_txt.write('Flow direction code: \n')
                                arquivo_txt.write(f'A = {self.dlg_flow_tt.le_5_pg1.text()}\n')
                                arquivo_txt.write(f'B = {self.dlg_flow_tt.le_6_pg1.text()}\n')
                                arquivo_txt.write(f'C = {self.dlg_flow_tt.le_7_pg1.text()}\n')
                                arquivo_txt.write(f'D = {self.dlg_flow_tt.le_8_pg1.text()}\n')
                                arquivo_txt.write(f'E = {self.dlg_flow_tt.le_9_pg1.text()}\n')
                                arquivo_txt.write(f'F = {self.dlg_flow_tt.le_10_pg1.text()}\n')
                                arquivo_txt.write(f'G = {self.dlg_flow_tt.le_11_pg1.text()}\n')
                                arquivo_txt.write(f'H = {self.dlg_flow_tt.le_12_pg1.text()}\n')
                                arquivo_txt.write('lineage: This file was created automatically by Hidropixel')                                
                    else:
                        # O usuário não solucionou um arquivo (um caminho para salvar o arquivo de saída)
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo
                    break

                elif page == 2:
                    # Salva as informações fornecidas na página de input
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "ftt_input_data_page", "Text Files (*.txt)")        
                    if file_name:
                            # Atribuindo o nome do arquivo(fn : file name) para escrita dos resultados da página 1
                            with open(file_name, 'w', encoding ='utf-8') as arquivo_txt:
                                arquivo_txt.write('Flow Travel Time - Input Data: \n')
                                arquivo_txt.write('\n')
                                arquivo_txt.write('Watershed delineation:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_1_pg2.text()}\n')
                                arquivo_txt.write('\nDigital elevation model:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_2_pg2.text()}\n')
                                arquivo_txt.write('\nFlow direction:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_3_pg2.text()}\n')
                                arquivo_txt.write('\nRiver drainage newtwork (RDN):\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_4_pg2.text()}\n')
                                arquivo_txt.write('\nRDN segmentation into classes:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_5_pg2.text()}\n')
                                arquivo_txt.write('\nDrainage area (km²):\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_6_pg2.text()}\n')
                                arquivo_txt.write('\nReservoir:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_7_pg2.text()}\n')
                                arquivo_txt.write('\nCharacteristics of RDN classes:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_8_pg2.text()}\n')
                                arquivo_txt.write('\nLand use or land corver (LULC) map:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_9_pg2.text()}\n')
                                arquivo_txt.write('\nManning roughness coeficient for each LULC:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_10_pg2.text()}\n')
                                arquivo_txt.write('\nRainfall depth for 24-h duration (mm):\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_11_pg2.text()}\n')
                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

                # elif page == 3:
                    # Salva informações página de data validation

                elif page == 4:
                    # Salva as informações fornecidas na página de run
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "ftt_run_page", "Text Files (*.txt)")
                    if file_name:
                            # Atribuindo o nome do arquivo(fn : file name) para escrita dos resultados da página 1
                            with open(file_name, 'w', encoding ='utf-8') as arquivo_txt:
                                arquivo_txt.write('Flow Travel Time - Run page: \n')
                                arquivo_txt.write('\n')
                                arquivo_txt.write('Numering pixels part of the river drainage network:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_1_pg4.text()}\n')
                                arquivo_txt.write('Areas draining directly to each pixel of the RDN:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_2_pg4.text()}\n')
                                arquivo_txt.write('Upstream flowpath length:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_3_pg4.text()}')
                                arquivo_txt.write('Downstream flow path slope (m/m):\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_4_pg4.text()}\n')
                                arquivo_txt.write('Downstream flow path length:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_5_pg4.text()}\n')
                                arquivo_txt.write('Slope relative to downstream pixel:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_6_pg4.text()}\n')
                                arquivo_txt.write('All river segments with similar hydrologic conditions:\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_7_pg4.text()}\n')    
                                arquivo_txt.write('Hydraulic radius, roughness and slope for all river segments::\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_8_pg4.text()}\n')
                                arquivo_txt.write('River cross-sectional area calculated by regional curves (m²):\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_9_pg4.text()}\n')                                                                                            
                                arquivo_txt.write('River cross-sectional area calculated by regional curves (m):\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_10_pg4.text()}\n')                                                                                            
                                arquivo_txt.write('Flow travel time (min):\n')
                                arquivo_txt.write(f'={self.dlg_flow_tt.le_11_pg4.text()}\n')

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

            elif function == 2:
                if page == 1:
                    # Salva as informações fornecidas na página de configuration: excess rainfall
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "exc_rain_configuration_page", "Text Files (*.txt)")
                    if file_name:
                        with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                            arquivo_txt.write('Excess Rainfall - Configuration page\n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Initial abstraction parameter (λ):\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_1_pg1.text()}\n')
                            arquivo_txt.write('Time step (min):\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_2_pg1.text()}\n')
                            arquivo_txt.write('Finish (min):\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_4_pg1.text()}\n')
                            arquivo_txt.write('Rainfall defination:\n')
                            arquivo_txt.write('    Areal averaged:\n')
                            arquivo_txt.write(f'   ={self.dlg_exc_rain.rb_1_pg1.isChecked()}\n')
                            arquivo_txt.write('    Spatially distributed:\n')
                            arquivo_txt.write(f'   ={self.dlg_exc_rain.rb_2_pg1.isChecked()}\n')

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

                elif page == 2:
                    # Armazena as informações acerca da função rainfall intepolation
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "exc_rain_rainfall_inter_page", "Text Files (*.txt)")
                    if file_name:
                        with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                            arquivo_txt.write('Excess Rainfall - Rainfall interpolation: \n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Watershed delineation:\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_1_pg_ri.text()}\n')
                            arquivo_txt.write('Rain gauges metadata:\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_2_pg_ri.text()}\n')
                            arquivo_txt.write('Rainfall data:\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_3_pg_ri.text()}\n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Rainfall file:\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_4_pg_ri.text()}\n')
                            arquivo_txt.write('Rainfall maps:\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_5_pg_ri.text()}\n')

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                        
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

                elif page == 3:
                    # Salva as informações fornecidas na página de input data: excess rainfall
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "exc_rain_input_data_page", "Text Files (*.txt)")
                    if file_name:
                        with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                            arquivo_txt.write('Excess Rainfall - Input data page: \n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Watershed delineation:\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_1_pg2.text()}\n')
                            arquivo_txt.write('Map of curve-number:\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_2_pg2.text()}\n')
                            if self.dlg_exc_rain.rb_1_pg1.isChecked():
                                arquivo_txt.write('Areal averaged rainfall:\n')
                                arquivo_txt.write(f'={self.dlg_exc_rain.le_3_pg2.text()}\n')
                            else:
                                arquivo_txt.write('List of files with the spatially distributed rainfall:\n')
                                arquivo_txt.write(f'={self.dlg_exc_rain.le_4_pg2.text()}\n')

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

                # elif page == 3:   

                elif page == 4:
                    # Salva informações da página de run : excess rainfall
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "exc_rain_run_page", "Text Files (*.txt)")
                    if file_name:
                        with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                            arquivo_txt.write('Excess Rainfall - Run page: \n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Numbering of watershed pixels:\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_1_pg4.text()}\n')
                            arquivo_txt.write('Maximum potential retention (mm):\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_2_pg4.text()}\n')
                            arquivo_txt.write('Initial abstraction (mm):\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_3_pg4.text()}\n')
                            arquivo_txt.write('Total rainfall (mm):\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_4_pg4.text()}\n')
                            arquivo_txt.write('Total excess rainfall (mm):\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_5_pg4.text()}\n')
                            arquivo_txt.write('Excess hyetographs per pixel (mm):\n')
                            arquivo_txt.write(f'={self.dlg_exc_rain.le_6_pg4.text()}\n')     
                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

            elif function == 3:
                if page == 1:
                # Salva as informações fornecidas na página de configuration: flow routing
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "flow_rout_configuration_page", "Text Files (*.txt)")
                    if file_name:
                        with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                            arquivo_txt.write('Flow Routing - Configuration page: \n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Model type:\n')
                            arquivo_txt.write('    Hidropixel - TUH:\n')
                            arquivo_txt.write(f'   ={self.dlg_flow_rout.rb_1_pg1.isChecked()}\n')
                            arquivo_txt.write('    Hidropixel - TUH+:\n')
                            arquivo_txt.write(f'   ={self.dlg_flow_rout.rb_2_pg1.isChecked()}\n')
                            arquivo_txt.write('    Hidropixel - DLR:\n')
                            arquivo_txt.write(f'   ={self.dlg_flow_rout.rb_3_pg1.isChecked()}\n')
                            arquivo_txt.write('Initial abstraction parameter (λ):\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_1_pg1.text()}\n')
                            arquivo_txt.write('Time step (min):\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_2_pg1.text()}\n')                            
                            arquivo_txt.write('Finish time (min):\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_4_pg1.text()}\n')                            
                            arquivo_txt.write('Parameter β:\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_5_pg1.text()}\n')                            

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break 

                elif page == 2:
                    # Salva as informações fornecidas na página de input data: flow routing
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "flow_rout_input_data_page", "Text Files (*.txt)")
                    if file_name:
                        with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                            arquivo_txt.write('Flow Routing - Input data page: \n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Numbering of watershed pixels:\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_1_pg2.text()}\n')
                            arquivo_txt.write('Watershed delineation:\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_2_pg2.text()}\n')
                            arquivo_txt.write('Flow travel time:\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_3_pg2.text()}\n')
                            arquivo_txt.write('Excess hyetographs per pixel:\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_4_pg2.text()}\n')
                            arquivo_txt.write('Total excess rainfall per pixel (mm):\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_5_pg2.text()}\n')

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

                # elif page == 3

                elif page == 4:
                    # Salva as informações fonecidas na página de run: flow routing 
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "flow_rout_run_page", "Text Files (*.txt)")
                    if file_name:
                        with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                            arquivo_txt.write('Flow Routing - Run page: \n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('TUH peak discharge per pixel:\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_1_pg4.text()}\n')
                            arquivo_txt.write(f'            (L/s) ={self.dlg_flow_rout.rb_1_pg4.isChecked()}\n')
                            arquivo_txt.write('Select unit:\n')
                            arquivo_txt.write(f'            (m³/s) ={self.dlg_flow_rout.rb_2_pg4.isChecked()}\n')
                            arquivo_txt.write('TUH peak time per pixel (min):\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_2_pg4.text()}\n')
                            arquivo_txt.write('TUH base time per pixel (min):\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_3_pg4.text()}\n')                                                          
                            arquivo_txt.write('Resulting peak discharge per pixel:\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_4_pg4.text()}\n')
                            arquivo_txt.write(f'            (L/s) ={self.dlg_flow_rout.rb_3_pg4.isChecked()}\n')
                            arquivo_txt.write('Select unit:\n')
                            arquivo_txt.write(f'            (m³/s) ={self.dlg_flow_rout.rb_4_pg4.isChecked()}\n')                            
                            arquivo_txt.write('Resulting runoff velume per pixel (m³):\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_5_pg4.text()}\n')
                            arquivo_txt.write('Resulting watershed hydrograph (m³/s):\n')
                            arquivo_txt.write(f'={self.dlg_flow_rout.le_6_pg4.text()}\n')  

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

    def read_from_file(self, function, page, directory):
        '''Esta função é responsável por obter as informações a partir dos arquivos enviados pelo usuário
        Function: Indica qual função a página pertence
                function == 1: Flow travel time;
                function == 2: Excess rainfall;
                function == 3: Flow routing
        Page: variável que identifica a página do arquivo que será escrito
                page == 1: Configurations;
                page == 2: Input Data;
                page == 3: Data Validation;
                page == 4: Run
        '''
        # Seleciona o arquivo enviado pelo usuário
        while True:
            options = QFileDialog.Options()
            file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory = directory, filter="Text Files (*.txt)", options = options)
            if file_:
                if function == 1:

                    if page == 1:
                        # Ler as informações da página 1: configuration
                        with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                            # Armazena as informações do arquivo enviado em uma lista
                            values = []
                            for line in arquivo_txt:
                                if '=' in line:
                                    value_ = line.split("=")[1].strip()
                                    values.append(value_)

                        # Adiciona as informações lidas nas suas respectivas 
                        
                        # General informations
                        self.dlg_flow_tt.le_1_pg1.setText(str(values[0]))
                        self.dlg_flow_tt.le_3_pg1.setText(str(values[1]))
                        self.dlg_flow_tt.le_4_pg1.setText(str(values[2]))

                        if bool(values[3]) == True:
                            # Flow path
                            self.dlg_flow_tt.cb_1_pg1.setChecked(bool(values[3]))
                            self.dlg_flow_tt.le_13_pg1.setText(str(values[4]))

                            # Channel's information
                            self.dlg_flow_tt.le_14_pg1.setText(str(values[5]))
                            self.dlg_flow_tt.le_15_pg1.setText(str(values[6]))

                            # Regional curve
                            self.dlg_flow_tt.le_16_pg1.setText(str(values[7]))
                            self.dlg_flow_tt.le_17_pg1.setText(str(values[8]))
                            self.dlg_flow_tt.le_18_pg1.setText(str(values[9]))
                            self.dlg_flow_tt.le_19_pg1.setText(str(values[10]))

                            # Reservoirs
                            self.dlg_flow_tt.le_20_pg1.setText(str(values[11]))
                        
                            # Flow dir
                            self.dlg_flow_tt.le_5_pg1.setText(str(values[12]))
                            self.dlg_flow_tt.le_6_pg1.setText(str(values[13]))
                            self.dlg_flow_tt.le_7_pg1.setText(str(values[14]))
                            self.dlg_flow_tt.le_8_pg1.setText(str(values[15]))
                            self.dlg_flow_tt.le_9_pg1.setText(str(values[16]))
                            self.dlg_flow_tt.le_10_pg1.setText(str(values[17]))
                            self.dlg_flow_tt.le_11_pg1.setText(str(values[18]))
                            self.dlg_flow_tt.le_12_pg1.setText(str(values[19]))

                        else:
                            # Channel's information
                            self.dlg_flow_tt.le_14_pg1.setText(str(values[3]))
                            self.dlg_flow_tt.le_15_pg1.setText(str(values[4]))

                            # Regional curve
                            self.dlg_flow_tt.le_16_pg1.setText(str(values[5]))
                            self.dlg_flow_tt.le_17_pg1.setText(str(values[6]))
                            self.dlg_flow_tt.le_18_pg1.setText(str(values[7]))
                            self.dlg_flow_tt.le_19_pg1.setText(str(values[8]))

                            # Reservoirs
                            self.dlg_flow_tt.le_20_pg1.setText(str(values[9]))
                        
                            # Flow dir
                            self.dlg_flow_tt.le_5_pg1.setText(str(values[10]))
                            self.dlg_flow_tt.le_6_pg1.setText(str(values[11]))
                            self.dlg_flow_tt.le_7_pg1.setText(str(values[12]))
                            self.dlg_flow_tt.le_8_pg1.setText(str(values[13]))
                            self.dlg_flow_tt.le_9_pg1.setText(str(values[14]))
                            self.dlg_flow_tt.le_10_pg1.setText(str(values[15]))
                            self.dlg_flow_tt.le_11_pg1.setText(str(values[16]))
                            self.dlg_flow_tt.le_12_pg1.setText(str(values[17]))

                        break

                    elif page == 2:
                        # Ler o arquivo da página 2: input dat
                        with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=' in line:
                                    # Substitui o identificador =por uma string fazia e retira os espaços da linha
                                    value = line.replace('=', '').strip()
                                    values.append(value)
                        
                        # Adiciona as informações lidas à seus respectivos campos
                        self.dlg_flow_tt.le_1_pg2.setText(str(values[0]))
                        self.dlg_flow_tt.le_2_pg2.setText(str(values[1]))
                        self.dlg_flow_tt.te_1_pg2.setPlainText(str(values[2]))
                        self.dlg_flow_tt.te_1_pg2.append(str(values[3]))
                        self.dlg_flow_tt.le_3_pg2.setText(str(values[4]))
                        self.dlg_flow_tt.le_4_pg2.setText(str(values[5]))
                        self.dlg_flow_tt.le_9_pg2.setText(str(values[6]))
                        self.dlg_flow_tt.le_10_pg2.setText(str(values[7]))

                        # Atribui os valores do arquivo enviado a tabela em questão
                        self.dlg_flow_tt.le_7_pg2.setText(str(values[8]))
                        self.read_tb_from_file_2(self.dlg_flow_tt.tbw_1_pg2,values[8], 1)
                        
                        self.dlg_flow_tt.le_5_pg2.setText(str(values[9]))

                        # Atribui os valores do arquivo enviado a tabela em questão
                        self.dlg_flow_tt.le_8_pg2.setText(str(values[10]))
                        self.read_tb_from_file_2(self.dlg_flow_tt.tbw_2_pg2,values[10],2)
                        
                        self.dlg_flow_tt.le_6_pg2.setText(str(values[11]))
                        
                        break               

                    elif page == 4:
                        # Ler arquivos página 4
                        with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=' in line:
                                    # Substitui o identificador =por uma string fazia e retira os espaços da linha
                                    value = line.replace('=', '').strip()
                                    values.append(value)

                        # Adiciona as informações lidas à seus respectivos campos            
                        self.dlg_flow_tt.le_1_pg4.setText(str(values[0]))
                        self.dlg_flow_tt.le_2_pg4.setText(str(values[1]))
                        self.dlg_flow_tt.le_3_pg4.setText(str(values[2]))
                        self.dlg_flow_tt.le_4_pg4.setText(str(values[3]))
                        self.dlg_flow_tt.le_5_pg4.setText(str(values[4]))
                        self.dlg_flow_tt.le_6_pg4.setText(str(values[5]))
                        self.dlg_flow_tt.le_7_pg4.setText(str(values[6]))
                        self.dlg_flow_tt.le_8_pg4.setText(str(values[7]))
                        self.dlg_flow_tt.le_9_pg4.setText(str(values[8]))
                        self.dlg_flow_tt.le_10_pg4.setText(str(values[9]))
                        self.dlg_flow_tt.le_11_pg4.setText(str(values[10]))
                        break

                elif function == 2:
                    # Lê os arquivos da primeira página
                    if page == 1:
                        with open(file_, 'r', encoding = 'utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=' in line:
                                    # Substitui o identificador =por uma string fazia e retira os espaços da linha
                                    value = line.replace('=', '').strip()
                                    values.append(value)      
                        self.dlg_exc_rain.le_1_pg1.setText(str(values[0]))                      
                        self.dlg_exc_rain.le_2_pg1.setText(str(values[1]))
                        self.dlg_exc_rain.le_4_pg1.setText(str(values[2]))
                        self.dlg_exc_rain.rb_1_pg1.setChecked(str(values[2])=='True')                 
                        self.dlg_exc_rain.rb_2_pg1.setChecked(str(values[3])=='True')             
                        break
                    
                    # Lê informações página rainfall interpolation
                    elif page == 2:
                        with open(file_, 'r', encoding = 'utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=' in line:
                                    # Substitui o identificador =por uma string fazia e retira os espaços da linha
                                    value = line.replace('=', '').strip()
                                    values.append(value) 

                        self.dlg_exc_rain.le_1_pg_ri.setText(str(values[0]))           
                        self.dlg_exc_rain.le_2_pg_ri.setText(str(values[1]))           
                        self.dlg_exc_rain.le_3_pg_ri.setText(str(values[2]))           
                        self.dlg_exc_rain.le_4_pg_ri.setText(str(values[3]))
                        self.dlg_exc_rain.le_5_pg_ri.setText(str(values[4]))
                        break         

                    # Lê os arquivos da segunda página
                    elif page == 3:
                        with open(file_, 'r', encoding = 'utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=' in line:
                                    # Substitui o identificador =por uma string fazia e retira os espaços da linha
                                    value = line.replace('=', '').strip()
                                    values.append(value) 

                        self.dlg_exc_rain.le_1_pg2.setText(str(values[0]))           
                        self.dlg_exc_rain.le_2_pg2.setText(str(values[1]))           
                        self.dlg_exc_rain.le_3_pg2.setText(str(values[2]))           
                        self.dlg_exc_rain.le_4_pg2.setText(str(values[3]))
                        break

                    # elif page == 4 and file_ != '':

                    # Lê os arquivos da quarta página                    
                    elif page == 5:
                        with open(file_, 'r', encoding = 'utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=' in line:
                                    # Substitui o identificador =por uma string fazia e retira os espaços da linha
                                    value = line.replace('=', '').strip()
                                    values.append(value) 
                        self.dlg_exc_rain.le_1_pg4.setText(str(values[0]))           
                        self.dlg_exc_rain.le_2_pg4.setText(str(values[1]))           
                        self.dlg_exc_rain.le_3_pg4.setText(str(values[2]))           
                        self.dlg_exc_rain.le_4_pg4.setText(str(values[3]))
                        self.dlg_exc_rain.le_5_pg4.setText(str(values[4]))
                        self.dlg_exc_rain.le_6_pg4.setText(str(values[5]))
                        break
                
                elif function == 3:
                    # Lê os arquivos da primeira página
                    if page == 1:
                        with open(file_, 'r', encoding = 'utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=' in line:
                                    # Substitui o identificador =por uma string fazia e retira os espaços da linha
                                    value = line.replace('=', '').strip()
                                    values.append(value)
                        self.dlg_flow_rout.rb_1_pg1.setChecked(str(values[0])=='True')
                        self.dlg_flow_rout.rb_2_pg1.setChecked(str(values[1])=='True')
                        self.dlg_flow_rout.rb_3_pg1.setChecked(str(values[2])=='True')
                        self.dlg_flow_rout.le_1_pg1.setText(str(values[3]))
                        self.dlg_flow_rout.le_2_pg1.setText(str(values[4]))
                        self.dlg_flow_rout.le_4_pg1.setText(str(values[5]))
                        self.dlg_flow_rout.le_5_pg1.setText(str(values[6]))
                        break
                    # Lê os arquivos da segunda página
                    elif page == 2:
                        with open(file_, 'r', encoding = 'utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=' in line:
                                    # Substitui o identificador =por uma string fazia e retira os espaços da linha
                                    value = line.replace('=', '').strip()
                                    values.append(value)

                        self.dlg_flow_rout.le_1_pg2.setText(str(values[0]))
                        self.dlg_flow_rout.le_2_pg2.setText(str(values[1]))
                        self.dlg_flow_rout.le_3_pg2.setText(str(values[2]))
                        self.dlg_flow_rout.le_4_pg2.setText(str(values[3]))
                        self.dlg_flow_rout.le_5_pg2.setText(str(values[4]))
                        break           
                    # Lê os arquivos da quarta página
                    elif page == 4:
                        with open(file_, 'r', encoding = 'utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=' in line:
                                    # Substitui o identificador =por uma string fazia e retira os espaços da linha
                                    value = line.replace('=', '').strip()
                                    values.append(value)

                        self.dlg_flow_rout.le_1_pg4.setText(str(value[0]))
                        self.dlg_flow_rout.rb_2_pg4.setChecked(bool(values[1]))                 
                        self.dlg_flow_rout.rb_3_pg4.setChecked(bool(values[2]))            
                        self.dlg_flow_rout.le_2_pg4.setText(str(value[3]))           
                        self.dlg_flow_rout.le_3_pg4.setText(str(value[4]))           
                        self.dlg_flow_rout.le_4_pg4.setText(str(value[5]))
                        self.dlg_flow_rout.rb_3_pg4.setChecked(bool(values[6]))                 
                        self.dlg_flow_rout.rb_4_pg4.setChecked(bool(values[7])) 
                        self.dlg_flow_rout.le_5_pg4.setText(str(value[8]))           
                        self.dlg_flow_rout.le_6_pg4.setText(str(value[9]))                          
                        break
            else:
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    break 

    def save_table_to_file_btn(self, table):
        '''Esta função lê as informações adicionadas às tabelas e as armazena em um arquivo após o usuário clicar no botão de salvar
            table == 1: a tabela de referência é a tabelea das caracteristicas da rede de drenagem
            table == 2 referencia a tabela das classes e coeficientes de manning.'''
        while True:
            if table == 1:
                # Solicita um local de salvamento para o usuário
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "RDN_classes", "Text (*.txt)")
                if file_name:
                    self.dlg_flow_tt.le_7_pg2.setText(file_name)
                    # seleciona as dimensões da tabela
                    nlin_tb1 = self.dlg_flow_tt.tbw_1_pg2.rowCount()
                    ncol_tb1 = self.dlg_flow_tt.tbw_1_pg2.columnCount()

                    # Escreve o arquivo de saída
                    with open(file_name, 'w', encoding='utf-8') as arquivo_txt_csv:
                        arquivo_txt_csv.write(f'Trecho,Rh (m),n,S (m/m)\n')
                        # Adicionando as informações das linhas e colunas ao arquivo de saída
                        for lin in range(nlin_tb1):
                            for col in range(ncol_tb1):
                                item = self.dlg_flow_tt.tbw_1_pg2.item(lin, col)
                                # Verifica se o item existe
                                if item is not None and item != '':  
                                    arquivo_txt_csv.write(f'{item.text()}')
                                    arquivo_txt_csv.write(',')
                            arquivo_txt_csv.write('\n')
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break 

            elif table ==2:
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "Manning_roughness_coef_for_each_LULC", "Text (*.txt)")
                if file_name:
                    self.dlg_flow_tt.le_8_pg2.setText(file_name)
                    # seleciona as dimensões da tabela
                    nlin_tb1 = self.dlg_flow_tt.tbw_2_pg2.rowCount()
                    ncol_tb1 = self.dlg_flow_tt.tbw_2_pg2.columnCount()

                    # Escreve o arquivo de saída
                    with open(file_name, 'w', encoding='utf-8') as arquivo_txt_csv:
                        arquivo_txt_csv.write('Land Cover Type Code,Manning (Sheet Flow),Land Cover Type Name,Coefficient k (Shallow concentrated flow)\n')
                        # Adicionando as informações das linhas e colunas ao arquivo de saída
                        for lin in range(nlin_tb1):
                            for col in range(ncol_tb1):
                                item = self.dlg_flow_tt.tbw_2_pg2.item(lin, col)
                                # Verifica se o item existe
                                if item is not None and item != '':
                                    arquivo_txt_csv.write(f'{item.text()}')
                                    arquivo_txt_csv.write(',')
                            arquivo_txt_csv.write('\n')
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break 

    def save_table_to_file(self, table):
        '''Esta função lê as informações adicionadas às tabelas e as armazena em um arquivo, sendo essas para leitura do visual basic
            table == 1: a tabela de referência é a tabelea das caracteristicas da rede de drenagem
            table == 2 referencia a tabela das classes e coeficientes de manning.'''

        if table == 1:
            # Solicita um local de salvamento para o usuário
            self.file_name_tb1 = self.diretorio_atual + r'\temp' + r'\segment_characteristics.txt'
            if file_name:
                # seleciona as dimensões da tabela
                nlin_tb1 = self.dlg_flow_tt.tbw_1_pg2.rowCount()
                ncol_tb1 = self.dlg_flow_tt.tbw_1_pg2.columnCount()

                # Escreve o arquivo de saída
                with open(file_name, 'w', encoding='utf-8') as arquivo_txt_csv:
                    arquivo_txt_csv.write(f'Trecho,Rh (m),n,S (m/m)\n')
                    # Adicionando as informações das linhas e colunas ao arquivo de saída
                    for lin in range(nlin_tb1):
                        for col in range(ncol_tb1):
                            item = self.dlg_flow_tt.tbw_1_pg2.item(lin, col)
                            # Verifica se o item existe
                            if item is not None and item != '':  
                                arquivo_txt_csv.write(f'{item.text()}')
                                arquivo_txt_csv.write(',')
                        arquivo_txt_csv.write('\n')
                
        elif table ==2:
            self.file_name_tb2 = self.diretorio_atual + r'\temp' + r'\surface_roughness.txt'
            if file_name:
                # seleciona as dimensões da tabela
                nlin_tb1 = self.dlg_flow_tt.tbw_2_pg2.rowCount()
                ncol_tb1 = self.dlg_flow_tt.tbw_2_pg2.columnCount()

                # Escreve o arquivo de saída
                with open(file_name, 'w', encoding='utf-8') as arquivo_txt_csv:
                    arquivo_txt_csv.write('Land Cover Type Code,Manning (Sheet Flow),Land Cover Type Name,Coefficient k (Shallow concentrated flow)\n')
                    # Adicionando as informações das linhas e colunas ao arquivo de saída
                    for lin in range(nlin_tb1):
                        for col in range(ncol_tb1):
                            item = self.dlg_flow_tt.tbw_2_pg2.item(lin, col)
                            # Verifica se o item existe
                            if item is not None and item != '':
                                arquivo_txt_csv.write(f'{item.text()}')
                                arquivo_txt_csv.write(',')
                        arquivo_txt_csv.write('\n')

    def read_tb_from_file(self,table, lineEdit,table_ordem):
        '''Esta função adiciona os valores do arquivo enviado pelo usuário à respectiva tabela
            table == 1: a tabela de referência é a tabelea das caracteristicas da rede de drenagem
            table == 2 referencia a tabela das classes e coeficientes de manning.'''

        # Seleciona o arquivo enviado pelo usuário
        options = QFileDialog.Options()
        directory = self.dlg_flow_tt.le_21_pg1.text()
        # Atualiza a flag para leitura dos dados da tabela
        self.flag = 1
        self.flag_1 = 1

        while True:
            # Solicita o arquivo
            file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory=directory, filter="Text or CSV Files (*.txt *.csv)", options=options)
            
            if file_:
                # Configura a primeira tabela
                if table_ordem == 1:
                    lineEdit.setText(file_)
                    # Abre o arquivo e processa as linhas
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                        # Lê a linha contendo o número de classes
                        self.global_vars.nclasses = int(arquivo_txt_csv.readline().split(':')[1])
                        # Lê a linha e o cabeçalho
                        arquivo_txt_csv.readline()

                        # Inicializa as listas para armazenamento das informações
                        id_class_list = []
                        Sclasse_list = []
                        Mannclasse_list = []
                        Rhclasse_list = []

                        # Iterando sobre as linhas do arquivo
                        for line in arquivo_txt_csv:
                            # Divide a linha nos espaços em branco e converte para float
                            line.replace(',',';')
                            info = line.strip().split(';')
                            # Armazenando os valores das linhas nas suas respectivas variáveis
                            if info[0] !='' and info[1] !='' and info[2] !='' and info[3]:
                                indice = info[0]
                                Scla = info[1]
                                Mann = info[2]
                                Rh = info[3]
                                # Adiciona os valores às listas
                                id_class_list.append(indice)
                                Sclasse_list.append(Scla)
                                Mannclasse_list.append(Mann)
                                Rhclasse_list.append(Rh)

                    # Atualiza as variáveis gerais
                    self.global_vars.j = np.array(id_class_list)
                    self.global_vars.Sclasse = np.array(Sclasse_list)
                    self.global_vars.Mannclasse = np.array(Mannclasse_list)
                    self.global_vars.Rhclasse = np.array(Rhclasse_list)    

                    # Atualiza no número de linhas da tabela (recebe o número de classes dos rios da bacia hidrográfica)
                    table.setRowCount(self.global_vars.nclasses)
                    
                    # Coleta as dimensões da tabela
                    n_row = table.rowCount()
                    n_column = table.columnCount()

                    # Itera sobre os elementos da tabela
                    for lin in range(n_row):                            
                        for col in range(n_column):

                            if col == 0:
                                # Adiciona a coluna do id
                                item = QTableWidgetItem(str(id_class_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 1:
                                # Adiciona a coluna da declividade
                                item = QTableWidgetItem(str(Sclasse_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 2:
                                # Adiciona a coluna do coef de Manning  
                                item = QTableWidgetItem(str(Mannclasse_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 3:
                                # Adiciona a coluna do raio hidráulico
                                item = QTableWidgetItem(str(Rhclasse_list[lin]))
                                table.setItem(lin, col, item)               
                    break

                # Configura a segunda tabela
                else:

                    # Criando variável extra, para armazenar os tipos de uso e coeficente de Manning
                    lineEdit.setText(file_)
                    uso_manning = []
                    # Criando variável extra, para armazenar os tipos de uso e coeficente de Manning
                    class_id = 0
                    uso_manning = []
                    coef_maning = []
                    coef_K = []
                    uso_manning_val = {}
                    coef_maning_val = []
                    coef_K_val = []

                    # Abrindo o arquivo que contém o coeficiente de Manning para os diferentes usos do solo
                    with open(arquivo, 'r', encoding='utf-8') as arquivo_txt_csv:
                        # Amazena a linha do cabeçalho
                        firt_line = arquivo_txt_csv.readline().strip()

                        # Lê as informações de uso do solo e coeficiente de Manning 
                        for line in arquivo_txt_csv:
                            # Coletando as informações de cada linha
                            info = line.strip().split(';')
                            # Armazenando os valores das linhas nas suas respectivas variáveis
                            if info[0] !='' and info[1] !='' and info[2] !='' and info[3]:
                                classe_id_key = int(info[0])
                                uso_manning = str(info[1])
                                coef_maning = float(info[2])
                                coef_K = float(info[3])

                                # Adicionando os valores nas variáveis destinadas
                                coef_maning_val = np.append(coef_maning_val, coef_maning)
                                coef_K_val = np.append(coef_K_val, coef_K)
                                uso_manning_val[classe_id_key] = class_id
                                class_id +=1

                    # Adicionando cada valor às suas respectivas variáveis
                    self.global_vars.uso_mann = uso_manning_val
                    self.global_vars.Mann = coef_maning_val
                    self.global_vars.coef_K = coef_K_val
                    self.global_vars.n_tipo_uso = len(class_name_val)

                    # Coleta as dimensões da tabela
                    n_row = table.rowCount()
                    n_column = table.columnCount()

                    # Adiciona as informações à tabela
                    for col in range(n_column):
                        for lin in range(n_row):
                            if col == 0:
                                # Adiciona a coluna class Id
                                item = QTableWidgetItem(str(classe_id_key[lin]))
                                table.setItem(lin, col, item)
                            elif col == 1:
                                # Adiciona a coluna class Name
                                item = QTableWidgetItem(str(class_name_val[lin]))
                                table.setItem(lin, col, item)
                            elif col == 2:
                                # Adiciona a coluna do coef de Manning  
                                item = QTableWidgetItem(str(coef_maning_val[lin]))
                                table.setItem(lin, col, item)
                            elif col == 3:
                                # Adiciona a coluna do coef K (shallow concentreted flow) 
                                item = QTableWidgetItem(str(coef_K_val[lin]))
                                table.setItem(lin, col, item)                                
                    
                    break

            else:
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    break

    def read_tb_from_file_2(self,table, line_edit,table_ordem):
        '''Esta função adiciona os valores do arquivo enviado pelo usuário à tabela quando se clica no botão READ FROM FILE (da página 2)
            table == 1: a tabela de referência é a tabelea das caracteristicas da rede de drenagem
            table == 2 referencia a tabela das classes e coeficientes de manning. 
            '''
        # Atribui os valores do arquivo enviado à tabela das características
        file_ = line_edit
        if table_ordem == 1:
            # Abre o arquivo e processa as linhas
            with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                # Lê a linha contendo o número de classes
                self.global_vars.nclasses = int(arquivo_txt_csv.readline().split(':')[1])
                # Lê a linha e o cabeçalho
                arquivo_txt_csv.readline()

                # Inicializa as listas para armazenamento das informações
                id_class_list = []
                Sclasse_list = []
                Mannclasse_list = []
                Rhclasse_list = []

                # Iterando sobre as linhas do arquivo
                for line in arquivo_txt_csv:
                    # Divide a linha nos espaços em branco e converte para float
                    line.replace(',',';')
                    info = line.strip().split(';')
                    # Armazenando os valores das linhas nas suas respectivas variáveis
                    if info[0] !='' and info[1] !='' and info[2] !='' and info[3]:
                        indice = int(info[0])
                        Scla = float(info[1])
                        Mann = float(info[2])
                        Rh = float(info[3])
                        # Adiciona os valores às listas
                        id_class_list.append(indice)
                        Sclasse_list.append(Scla)
                        Mannclasse_list.append(Mann)
                        Rhclasse_list.append(Rh)

            # Atualiza as variáveis gerais
            self.global_vars.j = np.array(id_class_list)
            self.global_vars.Sclasse = np.array(Sclasse_list)
            self.global_vars.Mannclasse = np.array(Mannclasse_list)
            self.global_vars.Rhclasse = np.array(Rhclasse_list)    

            # Atualiza no número de linhas da tabela (recebe o número de classes dos rios da bacia hidrográfica)
            table.setRowCount(self.global_vars.nclasses)
            
            # Coleta as dimensões da tabela
            n_row = table.rowCount()
            n_column = table.columnCount()

            # Itera sobre os elementos da tabela
            for lin in range(n_row):                            
                for col in range(n_column):

                    if col == 0:
                        # Adiciona a coluna do id
                        item = QTableWidgetItem(str(id_class_list[lin]))
                        table.setItem(lin, col, item)
                    elif col == 1:
                        # Adiciona a coluna da declividade
                        item = QTableWidgetItem(str(Sclasse_list[lin]))
                        table.setItem(lin, col, item)
                    elif col == 2:
                        # Adiciona a coluna do coef de Manning  
                        item = QTableWidgetItem(str(Mannclasse_list[lin]))
                        table.setItem(lin, col, item)
                    elif col == 3:
                        # Adiciona a coluna do raio hidráulico
                        item = QTableWidgetItem(str(Rhclasse_list[lin]))
                        table.setItem(lin, col, item)               


        # Configura a segunda tabela
        else:

            # Criando variável extra, para armazenar os tipos de uso e coeficente de Manning
            class_id = 0
            uso_manning = []
            coef_maning = []
            coef_K = []
            uso_manning_val = {}
            coef_maning_val = []
            coef_K_val = []

            # Abrindo o arquivo que contém o coeficiente de Manning para os diferentes usos do solo
            with open(arquivo, 'r', encoding='utf-8') as arquivo_txt_csv:
                # Amazena a linha do cabeçalho
                firt_line = arquivo_txt_csv.readline().strip()

                # Lê as informações de uso do solo e coeficiente de Manning 
                for line in arquivo_txt_csv:
                    # Coletando as informações de cada linha
                    info = line.strip().split(';')
                    # Armazenando os valores das linhas nas suas respectivas variáveis
                    if info[0] !='' and info[1] !='' and info[2] !='' and info[3]:
                        classe_id_key = int(info[0])
                        uso_manning = str(info[1])
                        coef_maning = float(info[2])
                        coef_K = float(info[3])

                        # Adicionando os valores nas variáveis destinadas
                        coef_maning_val = np.append(coef_maning_val, coef_maning)
                        coef_K_val = np.append(coef_K_val, coef_K)
                        uso_manning_val[classe_id_key] = class_id
                        class_id +=1

            # Adicionando cada valor às suas respectivas variáveis
            self.global_vars.uso_mann = uso_manning_val
            self.global_vars.Mann = coef_maning_val
            self.global_vars.coef_K = coef_K_val
            self.global_vars.n_tipo_uso = len(class_name_val)

            # Coleta as dimensões da tabela
            n_row = table.rowCount()
            n_column = table.columnCount()

            # Adiciona as informações à tabela
            for col in range(n_column):
                for lin in range(n_row):
                    if col == 0:
                        # Adiciona a coluna class Id
                        item = QTableWidgetItem(str(classe_id_key[lin]))
                        table.setItem(lin, col, item)
                    elif col == 1:
                        # Adiciona a coluna class Name
                        item = QTableWidgetItem(str(class_name_val[lin]))
                        table.setItem(lin, col, item)
                    elif col == 2:
                        # Adiciona a coluna do coef de Manning  
                        item = QTableWidgetItem(str(coef_maning_val[lin]))
                        table.setItem(lin, col, item)
                    elif col == 3:
                        # Adiciona a coluna do coef K (shallow concentreted flow) 
                        item = QTableWidgetItem(str(coef_K_val[lin]))
                        table.setItem(lin, col, item)

    def leh_geotiff_escreve_ascii(self, arquivo, arquivo2, int_float):
        '''Esta função realiza a leitura do arquivo .tif enviado pelo user e o converte em .rst tipo ascii para leitura no visual basic
            arquivo1 = diretório do arquivo arquivo raster tiff
            arquivo2 = arquivo raster tipo rst ascii (será criado)''' 

        # Lê o arquivo .tiff enviado
        raster_enviado = gdal.Open(arquivo)

        # Lendo os dados raster como um array 
        dados_lidos = raster_enviado.GetRasterBand(1).ReadAsArray()

        # Tratamento de erro: verifica se o arquivo foi aberto corretamente
        if raster_enviado is not None:
            # Obtenção da dimensão da imagem raster
            self.rdc_vars.nlin = dados_lidos.RasterYSize           
            self.rdc_vars.ncol = dados_lidos.RasterXSize
            self.rdc_vars.geotransform = dados_lidos.GetGeoTransform()
            self.rdc_vars.resolucao = dados_lidos.GetProjection()[1]

        # Leitura do arquivo ascii
        if int_float == 'int':
            with open(arquivo2, 'w') as arquivo_ascii:
                for lin in range(self.rdc_vars.nlin):
                    for col in range(self.rdc_vars.ncol):
                        if ((lin*col)-1) != ((lin*col)-1):
                            arquivo_ascii.write(f'{int(dados_lidos[self.rdc_vars.nlin,self.rdc_vars.ncol])}')
                        else:
                            arquivo_ascii.write(int(dados_lidos[self.rdc_vars.nlin,self.rdc_vars.ncol]))

        elif int_float == 'float':
            with open(arquivo2, 'w') as arquivo_ascii:
                for lin in range(self.rdc_vars.nlin):
                    for col in range(self.rdc_vars.ncol):
                        if ((lin*col)-1) != ((lin*col)-1):
                            arquivo_ascii.write(f'{float(dados_lidos[self.rdc_vars.nlin,self.rdc_vars.ncol])}\n')  
                        else:
                            arquivo_ascii.write(f'{float(dados_lidos[self.rdc_vars.nlin,self.rdc_vars.ncol])}')

        arquivo2_doc = arquivo2.replace('.rst','.RDC')
        arquivo2_doc = arquivo2.replace('.RST','.RDC')
        with open(arquivo2_doc, 'w', encoding = 'utf-8') as arquivo_rdc:
            arquivo_rdc.write(f'Rows,{self.rdc_vars.nlin}')
            arquivo_rdc.write(f'Columns,{self.rdc_vars.ncol}')
            arquivo_rdc.write(f'resolution,{self.rdc_vars.resolucao}')

    def leh_rst_escreve_geotiff(self, arquivo1, arquivo2, file_type):
        '''Esta função lê os arquivos processados nas rotinas em visual basic, no formato .rst(ascii) e os escreve em geotiff (no diretório informado)
            arquivo1 = diretório do arquivo raster tipo rst ascii
            arquivo2 = arquivo raster tiff (será criado)'''

        # Convertendo arquivo ascii para geotiff
        rst_to_raster = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))

        # Leitura do arquivo ascii
        if int_float == 'int':
            with open(arquivo1, 'r') as arquivo_ascii:
                for lin in range(self.rdc_vars.nlin):
                    for col in range(self.rdc_vars.ncol):
                        raster_lido[lin,col] = int(arquivo_ascii.readline())

        elif int_float == 'float':
            with open(arquivo1, 'r') as arquivo_ascii:
                for lin in range(self.rdc_vars.nlin):
                    for col in range(self.rdc_vars.ncol):
                        raster_lido[lin,col] = float(arquivo_ascii.readline())

        # Define os dados a serem escritos
        if file_type == 'int':
            tipo_dados = gdalconst.GDT_Int16
        else:
            tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver para escrita do arquivo em GeoTiff
        fn_geotiff = arquivo_2
        driver = gdal.GetDriverByName('GTiff')

        # Cria arquivo final
        dataset = driver.Create(fn_geotiff, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(raster_lido)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

    def add_new_row(self,table):
        '''Está função adiciona uma linha a uma tabela relecionada'''
        last_row = table.rowCount()
        table.insertRow(last_row)
    
    def delete_row(self,table):
        '''Esta função deleta uma linha de uma referida tabela'''
        selected_row = table.currentRow()
        if selected_row >= 0:
            table.removeRow(selected_row)
        else:
            QMessageBox.warning(None, "Warning", "You did not select any row.")
             
    def save(self):
        '''Esta função é usada para salvar as informações adiconadas'''
        self.save_result = True

    def close_gui(self, function):
        '''Está função é usada para torna nulo (limpar) as informações adicionadas nos diferentes objetos das funções do Hidropixel Plugin
           - Function = 1 : Flow travel time
           - Function = 2 : Excess rainfall
           - Function = 3 : Flow routing'''

        if function == 1:
            # Verifica se alguma lineEdit sobreu alteração: modifica a execução da função close
            line_edit_list = [
                self.dlg_flow_tt.le_1_pg1.text(),
                self.dlg_flow_tt.le_5_pg1.text(),
                self.dlg_flow_tt.le_6_pg1.text(),
                self.dlg_flow_tt.le_7_pg1.text(),
                self.dlg_flow_tt.le_8_pg1.text(),
                self.dlg_flow_tt.le_9_pg1.text(),
                self.dlg_flow_tt.le_10_pg1.text(),
                self.dlg_flow_tt.le_11_pg1.text(),
                self.dlg_flow_tt.le_12_pg1.text(),
                self.dlg_flow_tt.le_13_pg1.text(),
                self.dlg_flow_tt.le_14_pg1.text(),
                self.dlg_flow_tt.le_15_pg1.text(),
                self.dlg_flow_tt.le_16_pg1.text(),
                self.dlg_flow_tt.le_17_pg1.text(),
                self.dlg_flow_tt.le_18_pg1.text(),
                self.dlg_flow_tt.le_19_pg1.text(),
                self.dlg_flow_tt.le_20_pg1.text(),
                self.dlg_flow_tt.le_21_pg1.text(),
                self.dlg_flow_tt.le_1_pg2.text(),
                self.dlg_flow_tt.le_2_pg2.text(),
                self.dlg_flow_tt.le_3_pg2.text(),
                self.dlg_flow_tt.le_4_pg2.text(),
                self.dlg_flow_tt.le_5_pg2.text(),
                self.dlg_flow_tt.le_6_pg2.text(),
                self.dlg_flow_tt.le_7_pg2.text(),
                self.dlg_flow_tt.le_8_pg2.text(),
                self.dlg_flow_tt.le_9_pg2.text(),
                self.dlg_flow_tt.le_10_pg2.text(),
                self.dlg_flow_tt.le_1_pg4.text(),
                self.dlg_flow_tt.le_2_pg4.text(),
                self.dlg_flow_tt.le_3_pg4.text(),
                self.dlg_flow_tt.le_4_pg4.text(),
                self.dlg_flow_tt.le_5_pg4.text(),
                self.dlg_flow_tt.le_6_pg4.text(),
                self.dlg_flow_tt.le_7_pg4.text(),
                self.dlg_flow_tt.le_8_pg4.text(),
                self.dlg_flow_tt.le_9_pg4.text(),
                self.dlg_flow_tt.le_10_pg4.text(),
                self.dlg_flow_tt.le_11_pg4.text()
            ]

            # Verifica se algum elemento da lista de line_edits foi modificado
            if any(item != '' for item in line_edit_list) and self.save_result == False:
                while True:

                    result = "Wait! You did not save your changes. Are you sure you want to close?"
                    reply = QMessageBox.warning(None, "Changes not saved", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break

                    else: 
                        # Limpando as informações armazenadas: line edit
                        self.dlg_flow_tt.le_1_pg1.clear()
                        self.dlg_flow_tt.le_5_pg1.clear()
                        self.dlg_flow_tt.le_6_pg1.clear()
                        self.dlg_flow_tt.le_7_pg1.clear()
                        self.dlg_flow_tt.le_8_pg1.clear()
                        self.dlg_flow_tt.le_9_pg1.clear()
                        self.dlg_flow_tt.le_10_pg1.clear()
                        self.dlg_flow_tt.le_11_pg1.clear()
                        self.dlg_flow_tt.le_12_pg1.clear()
                        self.dlg_flow_tt.le_13_pg1.clear()
                        self.dlg_flow_tt.le_14_pg1.clear()
                        self.dlg_flow_tt.le_15_pg1.clear()
                        self.dlg_flow_tt.le_16_pg1.clear()
                        self.dlg_flow_tt.le_17_pg1.clear()
                        self.dlg_flow_tt.le_18_pg1.clear()
                        self.dlg_flow_tt.le_19_pg1.clear()
                        self.dlg_flow_tt.le_20_pg1.clear()
                        self.dlg_flow_tt.le_21_pg1.clear()

                        self.dlg_flow_tt.le_1_pg2.clear()
                        self.dlg_flow_tt.le_2_pg2.clear()
                        self.dlg_flow_tt.te_1_pg2.clear()
                        self.dlg_flow_tt.le_3_pg2.clear()
                        self.dlg_flow_tt.le_4_pg2.clear()
                        self.dlg_flow_tt.le_5_pg2.clear()
                        self.dlg_flow_tt.le_6_pg2.clear()
                        self.dlg_flow_tt.le_7_pg2.clear()
                        self.dlg_flow_tt.le_8_pg2.clear()
                        self.dlg_flow_tt.le_9_pg2.clear()
                        self.dlg_flow_tt.le_10_pg2.clear()

                        self.dlg_flow_tt.le_1_pg4.clear()
                        self.dlg_flow_tt.le_2_pg4.clear()
                        self.dlg_flow_tt.le_3_pg4.clear()
                        self.dlg_flow_tt.le_4_pg4.clear()
                        self.dlg_flow_tt.le_5_pg4.clear()
                        self.dlg_flow_tt.le_6_pg4.clear()
                        self.dlg_flow_tt.le_7_pg4.clear()
                        self.dlg_flow_tt.le_8_pg4.clear()
                        self.dlg_flow_tt.le_9_pg4.clear()
                        self.dlg_flow_tt.le_10_pg4.clear()
                        self.dlg_flow_tt.le_11_pg4.clear()

                        # Limpando as informações armazenadas: tables widgets
                        nlin_tb1 = self.dlg_flow_tt.tbw_1_pg2.rowCount()
                        ncol_tb1 = self.dlg_flow_tt.tbw_1_pg2.columnCount()
                        nlin_tb2 = self.dlg_flow_tt.tbw_2_pg2.rowCount()
                        ncol_tb2 = self.dlg_flow_tt.tbw_2_pg2.columnCount()
                        # Primeira tabela
                        for lin in range(nlin_tb1):
                            for col in range(ncol_tb1):
                                item = self.dlg_flow_tt.tbw_1_pg2.item(lin, col)
                                if item is not None:
                                    item.setText('')

                        # Segunda tabela
                        for lin in range(nlin_tb2):
                            for col in range(ncol_tb2):
                                item = self.dlg_flow_tt.tbw_2_pg2.item(lin, col)
                                if item is not None:
                                    item.setText('')
                        self.dlg_flow_tt.ch_1_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_2_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_3_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_4_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_5_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_6_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_7_pg4.setChecked(False)
                        self.dlg_flow_tt.ch_8_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_9_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_10_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_11_pg4.setChecked(False)
                        self.dlg_flow_tt.ch_12_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_13_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_14_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_15_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_16_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_17_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_18_pg4.setChecked(False)
                        self.dlg_flow_tt.ch_19_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_20_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_21_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_22_pg4.setChecked(False)
                        self.dlg_flow_tt.close()

                    # Atualiza as variáveis para a condição de salvamento
                    self.save_result = False
                    break

            # Se não houver moficações nos objetos do plugin, a janela será fechada normalmente
            else:
                self.dlg_flow_tt.close()
                self.save_result = False

        elif function == 2:
            # Verifica se alguma lineEdit sobreu alteração: modifica a execução da função close
            line_edit_list = [
                self.dlg_exc_rain.le_1_pg1.text(),
                self.dlg_exc_rain.le_2_pg1.text(),
                self.dlg_exc_rain.le_3_pg1.text(),
                self.dlg_exc_rain.le_1_pg_ri.text(),
                self.dlg_exc_rain.le_2_pg_ri.text(),
                self.dlg_exc_rain.le_3_pg_ri.text(),
                self.dlg_exc_rain.le_4_pg_ri.text(),
                self.dlg_exc_rain.le_5_pg_ri.text(),
                self.dlg_exc_rain.le_1_pg2.text(),
                self.dlg_exc_rain.le_2_pg2.text(),
                self.dlg_exc_rain.le_3_pg2.text(),
                self.dlg_exc_rain.le_4_pg2.text(),
                self.dlg_exc_rain.le_1_pg4.text(),
                self.dlg_exc_rain.le_2_pg4.text(),
                self.dlg_exc_rain.le_3_pg4.text(),
                self.dlg_exc_rain.le_4_pg4.text(),
                self.dlg_exc_rain.le_5_pg4.text(),
                self.dlg_exc_rain.le_6_pg4.text()
            ]

            # Verifica se algum elemento da função foi modificado
            if any(item != '' for item in line_edit_list) and self.save_result == False:
                while True:

                    result = "Wait! You did not save your changes. Are you sure you want to close?"
                    reply = QMessageBox.warning(None, "Changes not saved", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break
                    
                    else:
                        # Limpando os elementos da função excess rainfall
                        self.dlg_exc_rain.le_1_pg1.clear()
                        self.dlg_exc_rain.le_2_pg1.clear()
                        self.dlg_exc_rain.le_3_pg1.clear()
                        self.dlg_exc_rain.le_4_pg1.clear()
                        self.dlg_exc_rain.le_1_pg_ri.clear()
                        self.dlg_exc_rain.le_2_pg_ri.clear()
                        self.dlg_exc_rain.le_3_pg_ri.clear()
                        self.dlg_exc_rain.le_4_pg_ri.clear()
                        self.dlg_exc_rain.le_5_pg_ri.clear()
                        self.dlg_exc_rain.le_1_pg2.clear()
                        self.dlg_exc_rain.le_2_pg2.clear()
                        self.dlg_exc_rain.le_3_pg2.clear()
                        self.dlg_exc_rain.le_4_pg2.clear()
                        self.dlg_exc_rain.le_1_pg4.clear()
                        self.dlg_exc_rain.le_2_pg4.clear()
                        self.dlg_exc_rain.le_3_pg4.clear()
                        self.dlg_exc_rain.le_4_pg4.clear()
                        self.dlg_exc_rain.le_5_pg4.clear()
                        self.dlg_exc_rain.le_6_pg4.clear()     
                        self.dlg_exc_rain.rb_1_pg1.setChecked(False) 
                        self.dlg_exc_rain.rb_2_pg1.setChecked(False) 
                        self.dlg_exc_rain.ch_1_pg4.setChecked(False)  
                        self.dlg_exc_rain.ch_2_pg4.setChecked(False)  
                        self.dlg_exc_rain.ch_3_pg4.setChecked(False)  
                        self.dlg_exc_rain.ch_4_pg4.setChecked(False)  
                        self.dlg_exc_rain.ch_5_pg4.setChecked(False)  
                        self.dlg_exc_rain.ch_6_pg4.setChecked(False)
                        self.dlg_exc_rain.close()

                    # Atualiza as variáveis para a condição de salvamento
                    self.save_result = False
                    break
            else:
                # Se não houver moficações nos objetos do plugin, a janela será fechada normalmente
                self.save_result = False
                self.dlg_exc_rain.close()

        elif function == 3:
            # Verifica se alguma lineEdit sobreu alteração: modifica a execução da função close
            line_edit_list = [
                self.dlg_flow_rout.le_1_pg1.text(),
                self.dlg_flow_rout.le_2_pg1.text(),
                self.dlg_flow_rout.le_3_pg1.text(),
                self.dlg_flow_rout.le_4_pg1.text(),
                self.dlg_flow_rout.le_5_pg1.text(),
                self.dlg_flow_rout.le_1_pg2.text(),
                self.dlg_flow_rout.le_2_pg2.text(),
                self.dlg_flow_rout.le_3_pg2.text(),
                self.dlg_flow_rout.le_4_pg2.text(),
                self.dlg_flow_rout.le_5_pg2.text(),
                self.dlg_flow_rout.le_1_pg4.text(),
                self.dlg_flow_rout.le_2_pg4.text(),
                self.dlg_flow_rout.le_3_pg4.text(),
                self.dlg_flow_rout.le_4_pg4.text(),
                self.dlg_flow_rout.le_5_pg4.text(),
                self.dlg_flow_rout.le_6_pg4.text()
            ]

            # Verifica se algum elemento da função foi modificado
            if any(item != '' for item in line_edit_list) and self.save_result == False:
                while True:

                    result = "Wait! You did not save your changes. Are you sure you want to close?"
                    reply = QMessageBox.warning(None, "Changes not saved", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break
                    
                    else:
                        # Limpando os elementos da função excess rainfall
                        self.dlg_flow_rout.le_1_pg1.clear()
                        self.dlg_flow_rout.le_2_pg1.clear()
                        self.dlg_flow_rout.le_3_pg1.clear()
                        self.dlg_flow_rout.le_4_pg1.clear()
                        self.dlg_flow_rout.le_5_pg1.clear()
                        self.dlg_flow_rout.le_1_pg2.clear()
                        self.dlg_flow_rout.le_2_pg2.clear()
                        self.dlg_flow_rout.le_3_pg2.clear()
                        self.dlg_flow_rout.le_4_pg2.clear()
                        self.dlg_flow_rout.le_5_pg2.clear()
                        self.dlg_flow_rout.le_1_pg4.clear()
                        self.dlg_flow_rout.le_2_pg4.clear()
                        self.dlg_flow_rout.le_3_pg4.clear()
                        self.dlg_flow_rout.le_4_pg4.clear()
                        self.dlg_flow_rout.le_5_pg4.clear()
                        self.dlg_flow_rout.le_6_pg4.clear()     
                        self.dlg_flow_rout.rb_1_pg1.setChecked(False) 
                        self.dlg_flow_rout.rb_2_pg1.setChecked(False) 
                        self.dlg_flow_rout.rb_3_pg1.setChecked(False)  
                        self.dlg_flow_rout.rb_1_pg4.setChecked(False) 
                        self.dlg_flow_rout.rb_2_pg4.setChecked(False) 
                        self.dlg_flow_rout.rb_3_pg4.setChecked(False) 
                        self.dlg_flow_rout.rb_4_pg4.setChecked(False) 
                        self.dlg_flow_rout.ch_1_pg4.setChecked(False)  
                        self.dlg_flow_rout.ch_2_pg4.setChecked(False)  
                        self.dlg_flow_rout.ch_3_pg4.setChecked(False)  
                        self.dlg_flow_rout.ch_4_pg4.setChecked(False)  
                        self.dlg_flow_rout.ch_5_pg4.setChecked(False)  
                        self.dlg_flow_rout.ch_6_pg4.setChecked(False)
                        self.dlg_flow_rout.close()

                    # Atualiza as variáveis para a condição de salvamento
                    self.save_result = False
                    break
   
            else:
                # Se não houver moficações nos objetos do plugin, a janela será fechada normalmente
                self.save_result = False
                self.dlg_flow_rout.close()

    def clear_table(self,table,lineEdit):
        '''Esta função limpa os valores armazenados na respectiva tabela'''
        # Limpando as informações armazenadas: tables widgets
        nlin_tb1 = table.rowCount()
        ncol_tb1 = table.columnCount()

        # Reinicia a respectiva tabela
        for lin in range(nlin_tb1):
            for col in range(ncol_tb1):
                item = table.item(lin, col)
                if item is not None:
                    item.setText('')
        # Limpa a lineEdit
        lineEdit.clear()

    def adiciona_layer(self, file_path):
        '''Esta função adiciona um arquivo enviado às layers do atual projeto do usuário no QGIS'''
        # Adiciona o arquivo raster ao projeto do QGIS
        file_name = os.path.basename(file_path)
        layer = QgsRasterLayer(file_path, 'gdal')
        layer.setName(file_name)
        QgsProject.instance().addMapLayer(layer)

        # Atualiza a tela do QGIS
        iface.layerTreeView().refreshLayerSymbology(layer.id())

    def rain_def_condition(self, rain_condition):
        '''Esta função verifica a condição da variável precipitação para execução da rotina Excess rainfall
           - rain_condition == 1 : areal averaged
           - rain_condition == 2 : spatiallu distributed'''

        if rain_condition == 1:
            # Objetos ligado a opção de precipitação média na área da baica ficam ativos
            self.dlg_exc_rain.le_3_pg2.setEnabled(True)
            self.dlg_exc_rain.label_31.setEnabled(True)
            self.dlg_exc_rain.tbtn_pg2_3.setEnabled(True)
            self.dlg_exc_rain.label_35.setEnabled(True)  

            # Objetos ligado a opção de precipitação distribuida espacialmente ficam inativos
            self.dlg_exc_rain.le_4_pg2.setEnabled(False)
            self.dlg_exc_rain.label_32.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_4.setEnabled(False)
            self.dlg_exc_rain.label_36.setEnabled(False)           

        elif rain_condition == 2:
            # Objetos ligado a opção de precipitação distribuida espacialmente ficam ativos
            self.dlg_exc_rain.le_4_pg2.setEnabled(True)
            self.dlg_exc_rain.label_32.setEnabled(True)
            self.dlg_exc_rain.tbtn_pg2_4.setEnabled(True)
            self.dlg_exc_rain.label_36.setEnabled(True)
            
            # Objetos ligado a opção de precipitação média na área da baica ficam inativos         
            self.dlg_exc_rain.le_3_pg2.setEnabled(False)
            self.dlg_exc_rain.label_31.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_3.setEnabled(False)
            self.dlg_exc_rain.label_35.setEnabled(False)  

    def cancel_log_page(self, text_edit, pg_parameters, pg_logge):
        '''Esta função configura o botão de cancelar da página de log'''
        mensagem_log1 = None
        # Cria texto formatado para adicionar ao text edit? mensagem de aviso
        mensagem_log1 = '<font>\nATTENTION: stopping FLOW TRAVEL TIME process...</font>'

        # Adiciona o texto formatado no QTextEdit
        text_edit.insertHtml(mensagem_log1)

        # Reativa a página de parametros
        pg_parameters.setEnabled(True)

        # Desativa a página de logge
        pg_logge.setEnabled(False)

    def cancel_rainfall_interpol(self):
        '''Esta configura o botão cancel da página run da função rainfall interpolation'''
        # Adiciona mensagem de cancelamento do processo 
        self.dlg_rain_interpl_run.te_rain_int('BREAKING THE RAINFALL INTERPOLATION PROCESSING...')
        self.dlg_rain_interpl_run.close()

    def apaga_arquivos_temp(self):
        '''Esta função exclui os arquivos temporários criados durante a execução do plugin'''
        # Muda para o diretório especificado
        os.chdir(self.diretorio_atual)

        # Obtém todos os arquivos com a extensão .txt
        arquivos_txt = glob.glob('*.txt')
        arquivos_rst = glob.glob('*.rst')
        arquivos_rdc = glob.glob('*.rdc')

        # Apaga todos os arquivos .txt
        for txt, rst, rdc in zip(arquivos_txt,arquivo_rst,arquivo_rdc):
            os.remove(txt)
            os.remove(rst)
            os.remove(rdc)

    def run_flow_tt(self):
        '''Está função ativa a página de log e configura a ordem de execução das funções para o cálculo do tempo de viagem'''
        # Ativiva a página de log e limpa as informações passadas no text_edit 
        mensagem_log1 = None
        self.dlg_flow_tt.tabWidget.setCurrentIndex(1)
        self.dlg_flow_tt.pg_log_ftt.setEnabled(True)
        self.dlg_flow_tt.te_logg.clear()

        # Configura a progressbar
        self.dlg_flow_tt.progressBar.setRange(0, 100)
        self.dlg_flow_tt.progressBar.setValue(0)

        # Adiciona avisa acerca do tempo de processamento
        # reply = QMessageBox.information(None, "Information", "This will take a few minutes", QMessageBox.Ok | QMessageBox.Cancel)
        
        # Apenas inicia o prpocessamento se o usuário estiver de acordo com o tempo de processamento
        # if reply == QMessageBox.Ok:

        # Configura as informações do textEdit da referida página
        font = QFont()
        font.setPointSize(11)
        version_info = {
            "QGIS Version": '3.34.0-Prizren',
            "Qt Version": '5.15.3',
            "Python Version": '3.9.5',
            "GDAL Version": '3.8.0'}
        
        datatime_started = datetime.now().isoformat()
        mensagem_log1 = "The plugin was developed with:\n"
        mensagem_log1 += f"QGIS Version: {version_info['QGIS Version']}\n"
        mensagem_log1 += f"Qt Version: {version_info['Qt Version']}\n"
        mensagem_log1 += f"Python Version: {version_info['Python Version']}\n"
        mensagem_log1 += f"GDAL Version: {version_info['GDAL Version']}\n"
        mensagem_log1 += "--------------------------------------------------------\n"
        mensagem_log1 += f"Algorithm started at: {datatime_started}\n"
        mensagem_log1 += "--------------------------------------------------------\n"

        # Cria condição de parada da execução: se o usuário clicar no botão cancel da página de log
        while True:
            # Método usado para permitir a iteração do usuário enquanto o programa está em execução
            QApplication.processEvents()
            self.dlg_flow_tt.btn_cancel_log.clicked.connect(lambda: self.cancel_log_page(self.dlg_flow_tt.te_logg,self.dlg_flow_tt.pg_par_ftt, self.dlg_flow_tt.pg_log_ftt))

            # Verifica a existência de incoerências nas informações (direções de fluxo) fornecidas pelo usuário
            list_line_edit_value_pg1 = [self.dlg_flow_tt.le_5_pg1.text(),
                                        self.dlg_flow_tt.le_6_pg1.text(),
                                        self.dlg_flow_tt.le_7_pg1.text(),
                                        self.dlg_flow_tt.le_8_pg1.text(),
                                        self.dlg_flow_tt.le_9_pg1.text(),
                                        self.dlg_flow_tt.le_10_pg1.text(),
                                        self.dlg_flow_tt.le_11_pg1.text(),
                                        self.dlg_flow_tt.le_12_pg1.text()
                                    ]
            duplicate = []
            # Verifica se há duplicatas no código
            for i in range(len(list_line_edit_value_pg1)):
                for j in range(i+1,len(list_line_edit_value_pg1)):
                    if list_line_edit_value_pg1[i] == list_line_edit_value_pg1[j]:
                        # Para os elementos iguais, armazena eles em uma lista
                        duplicate.append(list_line_edit_value_pg1[i])

            if any(item == '' for item in duplicate):
                self.dlg_flow_tt.pages_flow_tt.setCurrentIndex(0)
                # Vefica se os códigos das diferções de drenagem foram corretamente enviados
                QMessageBox.warning(self.dlg_flow_tt, 'Warning', "Direction codes might not None.")
                return

            elif duplicate and all(item != '' for item in duplicate):
                self.dlg_flow_tt.pages_flow_tt.setCurrentIndex(0)
                # O usuário enviou 2 valores semelhantes, será mostrado uma mensagem de erro
                QMessageBox.warning(self.dlg_flow_tt, 'Warning', f"The value(s) '{duplicate}' is(are) (a) duplicate(s)! Direction codes do not accept duplicates.")
                return
                
            else:
                # Se não existir erros nas informações enviadas, será mostrada a página de log e o programa será executado
                self.dlg_flow_tt.pg_par_ftt.setEnabled(False)
                    
                # Adiciona as mensagem de log ao text edit e configura a função run
                self.dlg_flow_tt.te_logg.append(mensagem_log1)
                self.dlg_flow_tt.progressBar.setValue(40)
                self.run_process_flow_tt()

                # Chama executável vb para iniciar o processamento
                travel_time_vb =  self.diretorio_atual + r'\temp\Travel Time.exe'
                flow_tt_exe = subprocess.Popen([travel_time_vb])
                flow_tt_exe.wait()              

                if flow_tt_exe.returncode == 0:
                    self.dlg_flow_tt.progressBar.setValue(60)
                    # Encerra o processo aberto (GUI vb)
                    flow_tt_exe.terminate()

                    # Define parâmetros da função que transforma .rst(ascii) para geotiff: Cria arquivos de saída no diretório fornecido pelo user

                    # slope
                    self.leh_rst_escreve_geotiff(output1,self.dlg_flow_tt.le_6_pg4.text(), 'float')
                    # river_segments
                    self.leh_rst_escreve_geotiff(output2,self.dlg_flow_tt.le_7_pg4.text(), 'float')
                    # River_cross-sectional_area
                    self.leh_rst_escreve_geotiff(output4,self.dlg_flow_tt.le_9_pg4.text(), 'float')
                    # River_bankfull_width
                    self.leh_rst_escreve_geotiff(output5,self.dlg_flow_tt.le_10_pg4.text(), 'float')
                    # Flow_travel_time
                    self.leh_rst_escreve_geotiff(output6,self.dlg_flow_tt.le_11_pg4.text(), 'float')
                    
                    # Atualiza progressBar
                    self.dlg_flow_tt.progressBar.setValue(80)

                    # Adição dos arquivos gerados ao QGIS
                    if self.dlg_flow_tt.ch_17_pg4.isChecked() == True:
                        # Adiciona ao QGIS o output: slope
                        self.adiciona_layer(self.dlg_flow_tt.le_6_pg4.text())

                    if self.dlg_flow_tt.ch_18_pg4.isChecked() == True:
                        # Adiciona ao QGIS o output: river_segments
                        self.adiciona_layer(self.dlg_flow_tt.le_7_pg4.text())

                    if self.dlg_flow_tt.ch_20_pg4.isChecked() == True:
                        # Adiciona ao QGIS o output: River_cross-sectional_area
                        self.adiciona_layer(self.dlg_flow_tt.le_9_pg4.text())

                    if self.dlg_flow_tt.ch_21_pg4.isChecked() == True:
                        # Adiciona ao QGIS o output: River_bankfull_width
                        self.adiciona_layer(self.dlg_flow_tt.le_10_pg4.text())

                    if self.dlg_flow_tt.ch_22_pg4.isChecked() == True:
                        # Adiciona ao QGIS o output: flow travel time 
                        self.adiciona_layer(self.dlg_flow_tt.le_11_pg4.text())

                    # Adiciona as informação ao text edit
                    self.dlg_flow_tt.te_logg.append('Operation completed successfully!')
                    QMessageBox.information(None, "Information", "Operation completed successfully!", )

                self.dlg_flow_tt.progressBar.setValue(100)

                # Finaliza execução do programa
                break

    def replace_tif_rst(self, arquivo1):
        '''Esta função modifica a extensão do parâmetro de .tif para .rst'''
        arquivo2 = arquivo1.replace('.tif','.rst')
        return arquivo2

    def run_process_flow_tt(self):
        """Esta função configa a escrita dos arquivos txt para integração com a linguagem visual basic"""
        
        # Captura diretório dos arquivo txt (pasta temp)
        direct_temp = self.diretorio_atual + r'\temp'

        # Escreve txt contendo código de direções de fluxo
        flow_directions_code = direct_temp + r'\flow_directions_code.txt'
        with open(flow_directions_code, 'w', enconding = 'utf-8') as arquivo_txt:
            # Escreve cabeçalho
            arquivo_txt.write('Flow Directions Code')
            arquivo_txt.write(f'A,{self.dlg_flow_tt.le_5_pg1.text()}\n')
            arquivo_txt.write(f'B,{self.dlg_flow_tt.le_6_pg1.text()}\n')
            arquivo_txt.write(f'C,{self.dlg_flow_tt.le_7_pg1.text()}\n')
            arquivo_txt.write(f'D,{self.dlg_flow_tt.le_8_pg1.text()}\n')
            arquivo_txt.write(f'E,{self.dlg_flow_tt.le_9_pg1.text()}\n')
            arquivo_txt.write(f'F,{self.dlg_flow_tt.le_10_pg1.text()}\n')
            arquivo_txt.write(f'G,{self.dlg_flow_tt.le_11_pg1.text()}\n')
            arquivo_txt.write(f'H,{self.dlg_flow_tt.le_12_pg1.text()}')

        # Escreve arquivo txt contento os parâmetros do modelo
        parameters_file = direct_temp + r'\parameters.txt'
        with open(parameters_file,'w', encoding = 'utf-8') as arquivo_txt:
            arquivo_txt.write(f'Manning coefficient for river segments without cross-section information,{self.dlg_flow_tt.le_14_pg1.text()}')
            arquivo_txt.write(f'Sheet flow lenght (m),{self.dlg_flow_tt.le_13_pg1.text()}')
            arquivo_txt.write(f'P24 - Rainfall depth for 24-hour duration and 2-year return period (mm),{self.dlg_flow_tt.le_6_pg2.text()}')
            arquivo_txt.write(f'Mean depth of lake or reservoir (m),{self.dlg_flow_tt.le_20_pg1.text()}')
            arquivo_txt.write(f'Regional curve coefficient c,{self.dlg_flow_tt.le_16_pg1.text()}')
            arquivo_txt.write(f'Regional curve coefficient d,{self.dlg_flow_tt.le_17_pg1.text()}')
            arquivo_txt.write(f'Regional curve coefficient g,{self.dlg_flow_tt.le_18_pg1.text()}')
            arquivo_txt.write(f'Regional curve coefficient h,{self.dlg_flow_tt.le_19_pg1.text()}')
            arquivo_txt.write(f'Maximum river segment lenght for river segments without cross-section information (m),{self.dlg_flow_tt.le_15_pg1.text()}')
            arquivo_txt.write(f'Minimum slope,{self.dlg_flow_tt.le_1_pg1.text()}')

        # Escreve arquivos contendo as informações das tabelas referentes aos segmentos homogêneos da rede de drenagem e das características do uso e cobertura do solo
        self.save_table_to_file(1)
        self.save_table_to_file(2)

        # Chama funções para tranformação do raster em geotiff para rst tipo ascii
        bacia_file = direct_temp + r'\Watershed.rst'
        self.leh_geotiff_escreve_ascii(self.dlg_flow_tt.le_1_pg2.text(),bacia_file, 'int')

        dem_file = direct_temp + r'\DEM.rst'
        self.leh_geotiff_escreve_ascii(self.dlg_flow_tt.le_2_pg2.text(),dem_file, 'float')

        Flow_Dir_file = direct_temp + r'\Flow_dir.rst'
        self.leh_geotiff_escreve_ascii(self.dlg_flow_tt.le_3_pg2.text(),Flow_Dir_file, 'int')

        DA_km2_file = direct_temp + r'\DA_km2.rst'
        self.leh_geotiff_escreve_ascii(self.dlg_flow_tt.le_4_pg2.text(),DA_km2_file, 'float')
        
        drainage_file = direct_temp + r'\drainage.rst'
        self.leh_geotiff_escreve_ascii(self.dlg_flow_tt.le_5_pg2.text(),drainage_file, 'int')

        river_segments_file = direct_temp + r'\river_segments.rst'
        self.leh_geotiff_escreve_ascii(self.dlg_flow_tt.le_6_pg2.text(),river_segments_file, 'int')

        LULC_file = direct_temp + r'\LULC.rst'
        self.leh_geotiff_escreve_ascii(self.dlg_flow_tt.le_7_pg2.text(),LULC_file, 'int')

        
        if self.dlg_flow_tt.le_6_pg2.text() is not None:
            reservoirs_file = direct_temp + r'\reservoirs.rst'
            self.leh_geotiff_escreve_ascii(self.dlg_flow_tt.le_7_pg2.text(),reservoirs_file, 'float')
        else:
            reservoirs_file = ''

        # Escreve arquivo txt com os diretórios e nome dos inputs enviados pelo user
        direct_in_files = direct_temp + r'\input_files_configuration.txt'
        with open(direct_in_files, 'w', enconding = 'utf-8') as arquivo_txt:
            # Escreve cabeçalho
            arquivo_txt.write("Selected input file directory")
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.le_1_pg2.text() is not None else 0},watershed,{bacia_file}')
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.le_2_pg2.text() is not None else 0},DEM,{dem_file}')
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.le_3_pg2.text() is not None else 0},Flow_Dir,{Flow_Dir_file}')
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.le_4_pg2.text() is not None else 0},DA_km2,{DA_km2_file}')
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.le_5_pg2.text() is not None else 0},drainage,{drainage_file}')
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.le_6_pg2.text() is not None else 0},river_segments,{river_segments_file}')
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.le_1_pg2.text() is not None else 0},segment_characteristics,{self.file_name_tb1}') # Arquivo obrigatório, condição apenas para manter o padrão e controle
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.le_9_pg2.text() is not None else 0},LULC,{LULC_file}')
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.le_1_pg2.text() is not None else 0},surface_roughness,{self.file_name_tb2}') # Arquivo obrigatório, condição apenas para manter o padrão e controle
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.le_7_pg2.text() is not None else 0},reservoirs,{reservoirs_file}')
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.le_1_pg2.text() is not None else 0},parameters,{parameters_file}') # Arquivo obrigatório, condição apenas para manter o padrão e controle
        
        # Organiza os caminhos dos arquivos de saída enviados pelo user: modifica a extensão de .tif para .rst
        output1 = replace_tif_rst(self.dlg_flow_tt.le_6_pg4.text())
        output2 = replace_tif_rst(self.dlg_flow_tt.le_7_pg4.text())
        output3 = self.dlg_flow_tt.le_8_pg4.text()
        output4 = replace_tif_rst(self.dlg_flow_tt.le_9_pg4.text())
        output5 = replace_tif_rst(self.dlg_flow_tt.le_10_pg4.text()) 
        output6 = replace_tif_rst(self.dlg_flow_tt.le_11_pg4.text())

        # Escreve aquivo txt contendo o diretório informado pelo user: será fornecido para a rotina em visual basic
        direct_out_files = direct_temp + r'\output_files_configuration.txt'
        with open(direct_out_files, 'w', encoding = 'utf-8') as arquivo_txt:
            arquivo_txt.write("Select output file directory")
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.ch_6_pg4.isChecked() == True else 0},Slope,{output1}') #rst
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.ch_7_pg4.isChecked() == True else 0},river_segments,{output2}') #rst
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.ch_8_pg4.isChecked() == True else 0},Hydraulic_radius-roughness_and_slope,{output3}') #txt: gerado diretamente nas rotinas vb
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.ch_9_pg4.isChecked() == True else 0},River_cross-sectional_area,{output4}') #rst
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.ch_10_pg4.isChecked() == True else 0},River_bankfull_width,{output5}') #rst
            arquivo_txt.write(f'{1 if self.dlg_flow_tt.ch_11_pg4.isChecked() == True else 0},Flow_travel_time,{output6}') #rst
  
    def run(self):
        """Esta é a função principal do plugin, todas as funcionalidades propostas anteriormente serão efetivadas na função run"""
        
        # Verifica se a interface já foi mostrada anteriormente
        if not hasattr(self, 'dlg_hidro_pixel') or not  self.dlg_hidro_pixel.isVisible():
            # Inicializa self.dlg_hidro_pixel apenas se ainda não estiver inicializado ou se estiver fechado
            self.dlg_hidro_pixel = HidroPixelDialog()
            # Mostra a interface gráfica
            self.dlg_hidro_pixel.show()
            QApplication.processEvents()

            # Desativa a página de log, só será ativada após clicar no botão run
            self.dlg_flow_tt.pg_log_ftt.setEnabled(False)
            # Cria as flags para configurar a leitura dos dados da tabela
            self.flag = 0
            self.flag_1 = 0

            # Configura botões do menu do hidropixel
            self.dlg_hidro_pixel.btn_flow_trav.clicked.connect(lambda: self.dlg_flow_tt.show())
            self.dlg_hidro_pixel.btn_exes_rain.clicked.connect(lambda: self.dlg_exc_rain.show())
            self.dlg_hidro_pixel.btn_flow_rout.clicked.connect(lambda: self.dlg_flow_rout.show())
            # self.dlg_hidro_pixel.btn_help.clicked.connect()

            '''Configura os botões da página da rotina do flow travel time'''
            self.dlg_flow_tt.btn_config.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg1_config))      
            self.dlg_flow_tt.btn_input_data.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg2_in_data))
            self.dlg_flow_tt.btn_data_va_tool.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg3_data_val_tool))
            self.dlg_flow_tt.btn_run.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg4_run))

            # Configura os botões da página configuration: flow travel time
            self.dlg_flow_tt.tbtn_pg1_1.clicked.connect(lambda: self.carrega_work_folder(self.dlg_flow_tt.le_21_pg1))
            
            # self.dlg_flow_tt.cb_1_pg1.toggled.connect(lambda: self.sheet_flow_status(self.dlg_flow_tt.cb_1_pg1.isChecked()))

            # Configura os botões da página input data : flow travel time
            self.dlg_flow_tt.tbtn_pg2_1.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_1_pg2))
            self.dlg_flow_tt.tbtn_pg2_2.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_2_pg2))
            self.dlg_flow_tt.tbtn_pg2_3.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.te_1_pg2, qtd = 2))
            self.dlg_flow_tt.tbtn_pg2_4.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_3_pg2))
            self.dlg_flow_tt.tbtn_pg2_5.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_4_pg2))
            self.dlg_flow_tt.tbtn_pg2_6.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_5_pg2))
            self.dlg_flow_tt.tbtn_pg2_9.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_9_pg2))
            self.dlg_flow_tt.tbtn_pg2_10.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_10_pg2))

            # Configura os botões da página run page: flow travel time
            self.dlg_flow_tt.tbtn_pg4_1.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_1_pg4))
            self.dlg_flow_tt.tbtn_pg4_2.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_2_pg4))
            self.dlg_flow_tt.tbtn_pg4_3.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_3_pg4))
            self.dlg_flow_tt.tbtn_pg4_4.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_4_pg4))
            self.dlg_flow_tt.tbtn_pg4_5.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_5_pg4))
            self.dlg_flow_tt.tbtn_pg4_6.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_6_pg4))
            self.dlg_flow_tt.tbtn_pg4_7.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_7_pg4))
            self.dlg_flow_tt.tbtn_pg4_8.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_8_pg4))
            self.dlg_flow_tt.tbtn_pg4_9.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_9_pg4))
            self.dlg_flow_tt.tbtn_pg4_10.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_10_pg4))
            self.dlg_flow_tt.tbtn_pg4_11.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_11_pg4))

            # configura botões de salvar e salvar para um arquivo: flow travel time
            self.dlg_flow_tt.btn_save_file_pg1.clicked.connect(lambda: self.save_to_file(1, 1))
            self.dlg_flow_tt.btn_save_file_pg2.clicked.connect(lambda: self.save_to_file(1, 2))
            self.dlg_flow_tt.btn_save_file_pg4.clicked.connect(lambda: self.save_to_file(1, 4))

            # Configura botão para ler informações de uma arquivo enviado : flow travel time
            self.dlg_flow_tt.btn_read_pg1.clicked.connect(lambda: self.read_from_file(1,1,self.dlg_flow_tt.le_21_pg1.text()))
            self.dlg_flow_tt.btn_read_pg2.clicked.connect(lambda: self.read_from_file(1,2,self.dlg_flow_tt.le_21_pg1.text()))
            self.dlg_flow_tt.btn_read_pg4.clicked.connect(lambda: self.read_from_file(1,4,self.dlg_flow_tt.le_21_pg1.text()))

            # Configura botões das tabelas : flow travel time
            self.dlg_flow_tt.btn_read_t1.clicked.connect(lambda: self.read_tb_from_file(self.dlg_flow_tt.tbw_1_pg2,self.dlg_flow_tt.le_7_pg2, 1))
            self.dlg_flow_tt.btn_read_t2.clicked.connect(lambda: self.read_tb_from_file(self.dlg_flow_tt.tbw_2_pg2,self.dlg_flow_tt.le_8_pg2,2))
            self.dlg_flow_tt.btn_save_file_t1.clicked.connect(lambda: self.save_table_to_file_btn(1))
            self.dlg_flow_tt.btn_save_file_t2.clicked.connect(lambda: self.save_table_to_file_btn(2))
            self.dlg_flow_tt.btn_add_row_1.clicked.connect(lambda: self.add_new_row(self.dlg_flow_tt.tbw_1_pg2))
            self.dlg_flow_tt.btn_add_row_2.clicked.connect(lambda: self.add_new_row(self.dlg_flow_tt.tbw_2_pg2))
            self.dlg_flow_tt.btn_del_row_1.clicked.connect(lambda: self.delete_row(self.dlg_flow_tt.tbw_1_pg2))
            self.dlg_flow_tt.btn_del_row_2.clicked.connect(lambda: self.delete_row(self.dlg_flow_tt.tbw_2_pg2))
            
            # Configura botões de salvar das diferentes páginas : flow travel time
            self.dlg_flow_tt.btn_save_pg1.clicked.connect(lambda: self.save())
            self.dlg_flow_tt.btn_save_pg2.clicked.connect(lambda: self.save())
            self.dlg_flow_tt.btn_save_pg4.clicked.connect(lambda: self.save())

            # Configura os botões de limpeza das variáveis : flow travel time
            self.dlg_flow_tt.btn_clear_1.clicked.connect(lambda: self.clear_table(self.dlg_flow_tt.tbw_1_pg2,self.dlg_flow_tt.le_7_pg2))
            self.dlg_flow_tt.btn_clear_2.clicked.connect(lambda: self.clear_table(self.dlg_flow_tt.tbw_2_pg2,self.dlg_flow_tt.le_8_pg2))

            # configura botões da página run : flow travel time
            self.dlg_flow_tt.btn_close_pg4.clicked.connect(lambda: self.close_gui(1))
            
            # Configura run button : flow travel time
            self.dlg_flow_tt.btn_run_2.clicked.connect(lambda: self.run_flow_tt())

            # Configura botões página de log: flow travel time
            self.dlg_flow_tt.btn_close_log.clicked.connect(lambda: self.close_gui(1))

            '''Configura os botões da página da rotina excess rainfall'''

            # Configura botões gerais das páginas da rotina excess rainfall
            self.dlg_exc_rain.btn_config.clicked.connect(lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg1_config))      
            self.dlg_exc_rain.btn_rain_int.clicked.connect(lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg2_rain_int))      
            self.dlg_exc_rain.btn_input_data.clicked.connect(lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg3_in_data))
            self.dlg_exc_rain.btn_data_va_tool.clicked.connect(lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg4_data_val_tool))
            self.dlg_exc_rain.btn_run.clicked.connect(lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg5_run))

            # Configura botões da página de configuration: excess rainfall
            self.dlg_exc_rain.tbtn_pg1_1.clicked.connect(lambda: self.carrega_work_folder(self.dlg_exc_rain.le_3_pg1))

            # Condição: usuário escolhe precipitação média (na bacia) ou destribuida (na bacia)
            self.dlg_exc_rain.le_4_pg2.setEnabled(False)
            self.dlg_exc_rain.label_32.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_4.setEnabled(False)
            self.dlg_exc_rain.label_36.setEnabled(False)
            self.dlg_exc_rain.le_3_pg2.setEnabled(False)
            self.dlg_exc_rain.label_31.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_3.setEnabled(False)
            self.dlg_exc_rain.label_35.setEnabled(False)

            # Se o usuário escolher a opção para chuva média
            self.dlg_exc_rain.rb_1_pg1.toggled.connect(lambda: self.rain_def_condition(1))
            self.dlg_exc_rain.rb_2_pg1.toggled.connect(lambda: self.rain_def_condition(2))

            # Configura os botões da página input data : excess rainfall
            self.dlg_exc_rain.tbtn_pg2_1.clicked.connect(lambda: self.carrega_arquivos(self.dlg_exc_rain.le_1_pg2))
            self.dlg_exc_rain.tbtn_pg2_2.clicked.connect(lambda: self.carrega_arquivos(self.dlg_exc_rain.le_2_pg2))
            self.dlg_exc_rain.tbtn_pg2_3.clicked.connect(lambda: self.carrega_arquivos(self.dlg_exc_rain.le_3_pg2))
            self.dlg_exc_rain.tbtn_pg2_4.clicked.connect(lambda: self.carrega_arquivos(self.dlg_exc_rain.le_4_pg2,file_type = 'text'))
            
            # configura botões de salvar e salvar para um arquivo: excess rainfall
            self.dlg_exc_rain.btn_save_file_pg1.clicked.connect(lambda: self.save_to_file(2, 1))
            self.dlg_exc_rain.btn_save_file_pg_ri.clicked.connect(lambda: self.save_to_file(2, 2))
            self.dlg_exc_rain.btn_save_file_pg2.clicked.connect(lambda: self.save_to_file(2, 2))
            self.dlg_exc_rain.btn_save_file_pg4.clicked.connect(lambda: self.save_to_file(2, 4))

            # Configura botão para ler informações de uma arquivo enviado : excess rainfall
            self.dlg_exc_rain.btn_read_pg1.clicked.connect(lambda: self.read_from_file(2,1,self.dlg_exc_rain.le_3_pg1.text()))
            self.dlg_exc_rain.btn_read_pg_ri.clicked.connect(lambda: self.read_from_file(2,2,self.dlg_exc_rain.le_3_pg1.text()))
            self.dlg_exc_rain.btn_read_pg2.clicked.connect(lambda: self.read_from_file(2,3,self.dlg_exc_rain.le_3_pg1.text()))
            self.dlg_exc_rain.btn_read_pg4.clicked.connect(lambda: self.read_from_file(2,4,self.dlg_exc_rain.le_3_pg1.text()))

            # Configura botões de salvar das diferentes páginas : excess rainfall
            self.dlg_exc_rain.btn_save_pg1.clicked.connect(lambda: self.save())
            self.dlg_exc_rain.btn_save_pg2.clicked.connect(lambda: self.save())
            self.dlg_exc_rain.btn_save_pg4.clicked.connect(lambda: self.save())
            
            # Configura os botões da página run page: excess rainfall
            self.dlg_exc_rain.tbtn_pg4_1.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_1_pg4))
            self.dlg_exc_rain.tbtn_pg4_2.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_2_pg4))
            self.dlg_exc_rain.tbtn_pg4_3.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_3_pg4))
            self.dlg_exc_rain.tbtn_pg4_4.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_4_pg4))
            self.dlg_exc_rain.tbtn_pg4_5.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_5_pg4))
            self.dlg_exc_rain.tbtn_pg4_6.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_6_pg4,file_type = 'text'))
            
            # configura botões da página run : excess rainfall
            # self.dlg_exc_rain.btn_run_2.clicked.connect(lambda: self.run_exc_rain())
            self.dlg_exc_rain.btn_close_pg4.clicked.connect(lambda: self.close_gui(2))
            
            # Configura botões da página rainfall interpolation
            self.dlg_exc_rain.tbtn_pg_r_1.clicked.connect(lambda: self.carrega_arquivos(self.dlg_exc_rain.le_1_pg_ri))
            self.dlg_exc_rain.tbtn_pg_r_2.clicked.connect(lambda: self.carrega_arquivos(self.dlg_exc_rain.le_2_pg_ri,file_type = 'text'))
            self.dlg_exc_rain.tbtn_pg_r_3.clicked.connect(lambda: self.carrega_arquivos(self.dlg_exc_rain.le_3_pg_ri,file_type = 'text'))
            self.dlg_exc_rain.tbtn_pg_r_4.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_4_pg_ri,file_type = 'text'))
            self.dlg_exc_rain.tbtn_pg_r_5.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_5_pg_ri))
            self.dlg_exc_rain.btn_save_1_pg_ri.clicked.connect(lambda: self.run_rainfall_interpolation(0))
            self.dlg_exc_rain.btn_save_2_pg_ri.clicked.connect(lambda: self.run_rainfall_interpolation(1))


            '''Configura os botões da página da rotina flow routing'''
            self.dlg_flow_rout.btn_config.clicked.connect(lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg1_config))      
            self.dlg_flow_rout.btn_input_data.clicked.connect(lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg2_in_data))
            self.dlg_flow_rout.btn_data_va_tool.clicked.connect(lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg3_data_val_tool))
            self.dlg_flow_rout.btn_run.clicked.connect(lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg4_run))    

            # Configura botões da página de configuration: flow routing
            self.dlg_flow_rout.tbtn_pg1_1.clicked.connect(lambda: self.carrega_work_folder(self.dlg_flow_rout.le_3_pg1))

            # Configura os botões da página input data : flow routing
            self.dlg_flow_rout.tbtn_pg2_1.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_rout.le_1_pg2))
            self.dlg_flow_rout.tbtn_pg2_2.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_rout.le_2_pg2))
            self.dlg_flow_rout.tbtn_pg2_3.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_rout.le_3_pg2))
            self.dlg_flow_rout.tbtn_pg2_4.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_rout.le_4_pg2,file_type='text'))
            self.dlg_flow_rout.tbtn_pg2_5.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_rout.le_5_pg2))

            # configura botões de salvar e salvar para um arquivo: flow travel time
            self.dlg_flow_rout.btn_save_file_pg1.clicked.connect(lambda: self.save_to_file(3, 1))
            self.dlg_flow_rout.btn_save_file_pg2.clicked.connect(lambda: self.save_to_file(3, 2))
            self.dlg_flow_rout.btn_save_file_pg4.clicked.connect(lambda: self.save_to_file(3, 4))

            # Configura botão para ler informações de uma arquivo enviado : flow routing
            self.dlg_flow_rout.btn_read_pg1.clicked.connect(lambda: self.read_from_file(3,1,self.dlg_flow_rout.le_3_pg1.text()))
            self.dlg_flow_rout.btn_read_pg2.clicked.connect(lambda: self.read_from_file(3,2,self.dlg_flow_rout.le_3_pg1.text()))
            self.dlg_flow_rout.btn_read_pg4.clicked.connect(lambda: self.read_from_file(3,4,self.dlg_flow_rout.le_3_pg1.text()))

            # Configura botões de salvar das diferentes páginas : flow routing
            self.dlg_flow_rout.btn_save_pg1.clicked.connect(lambda: self.save())
            self.dlg_flow_rout.btn_save_pg2.clicked.connect(lambda: self.save())
            self.dlg_flow_rout.btn_save_pg4.clicked.connect(lambda: self.save())

            # Configura os botões da página run page: flow routing
            self.dlg_flow_rout.tbtn_pg4_1.clicked.connect(lambda: self.save_buttons(self.dlg_flow_rout.le_1_pg4))
            self.dlg_flow_rout.tbtn_pg4_2.clicked.connect(lambda: self.save_buttons(self.dlg_flow_rout.le_2_pg4))
            self.dlg_flow_rout.tbtn_pg4_3.clicked.connect(lambda: self.save_buttons(self.dlg_flow_rout.le_3_pg4))
            self.dlg_flow_rout.tbtn_pg4_4.clicked.connect(lambda: self.save_buttons(self.dlg_flow_rout.le_4_pg4))
            self.dlg_flow_rout.tbtn_pg4_5.clicked.connect(lambda: self.save_buttons(self.dlg_flow_rout.le_5_pg4))
            self.dlg_flow_rout.tbtn_pg4_6.clicked.connect(lambda: self.save_buttons(self.dlg_flow_rout.le_6_pg4, file_type = 'text'))            
            
            # configura botões da página run : flow routing
            # self.dlg_flow_rout.btn_run_2.clicked.connect(lambda: self.run_flow_routing())
            self.dlg_flow_rout.btn_close_pg4.clicked.connect(lambda: self.close_gui(3))

            '''Menu Hidropixel Plugin'''
            # Run the dialog event loop
            self.dlg_hidro_pixel.exec_()

            # Encerra todas as GUIs
            self.close_gui(1)
            self.close_gui(2)
            self.close_gui(3)

            # Elimina os arquivos criados durante a execução do hidropixel
            self.apaga_arquivos_temp()