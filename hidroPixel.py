# -*- coding: utf-8 -*-
"""
/***************************************************************************
 HidroPixel
 Add the description
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2023 by João Vitor & Adriano Rolim
        email                : jvds@academico.ufpb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt import uic
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QRegularExpression
from qgis.PyQt.QtGui import QIcon, QRegExpValidator, QIntValidator, QFont
from qgis.PyQt.QtWidgets import QApplication, QMainWindow, QAction, QFileDialog, QMessageBox, QTableWidgetItem, QWidget, QStackedWidget
from qgis.core import QgsMessageLog, Qgis, QgsProject, QgsRasterLayer
from qgis.utils import iface


# Import the code for the dialog
import os.path
import sys, os
import logging
from .hidroPixel_dialog import HidroPixelDialog
from pathlib import Path
from datetime import datetime
from hidropixel.modulos_files.RDC_variables import RDCVariables
from hidropixel.modulos_files.global_variables import GlobalVariables

# Initialize Qt resources from file resources.py
from .resources import *

# Importing libs
import numpy as np
from osgeo import ogr, gdal, gdalconst

class HidroPixel:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Hidropixel_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Hidropixel')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Criando instâncias das classes
        self.global_vars = GlobalVariables()
        self.rdc_vars = RDCVariables()

        # Seleciona o diretório atual do plugin
        file_path = os.path.dirname(__file__)

        # Inicia a interface gráfica da rotina flow travel time
        ui_file = os.path.join(file_path, 'hidroPixel_dialog_flow_tt.ui')

        # Inicia a interface gráfica da rotina excess rainfall
        ui_file1 = os.path.join(file_path, 'hidroPixel_dialog_exec_rainfall.ui')

        # Inicia a interface gráfica da rotina flow routing
        ui_file2 = os.path.join(file_path, 'hidroPixel_dialog_flow_rout.ui')

        # inicia instânica das diferentes routinas do plugin Hidropixel
        self.dlg_flow_tt = uic.loadUi(ui_file)
        self.dlg_exc_rain = uic.loadUi(ui_file1)
        self.dlg_flow_rout = uic.loadUi(ui_file2)

        # Cria outras variáveis necessárias
        self.save_result = None
        self.classerio_aux = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        self.fn_n_conect_dren = None
        self.fn_comp_acum = None
        self.fn_comp_foz = None
        self.fn_decli_pix = None
        self.fn_decli_pix_jus = None
        self.fn_temp_total = None
        self.flag = None
        self.flag_1 = None
        
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Hidropixel', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/hidroPixel/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Hidropixel Plugin'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Hidropixel'),
                action)
            self.iface.removeToolBarIcon(action)

    def carrega_work_folder(self, line_edit):
        '''Esta função define a pasta padrão tanto para buscar, quanto para salvar os arquivos'''
        # Define as variáveis e configurações da janela de escolha do arquivo
        pasta = None
        line_edit.setText('')
        options = QFileDialog.Options()
        pasta = QFileDialog.getExistingDirectory(None, caption = 'Select your work folder!', options = options)

        if pasta != '':
            # Se o usário enviar um arquivo, este será armazenado na sua referida line edit
            line_edit.setText(pasta)
        else:
            # Caso contrário, será mostrada uma mensagem de aviso
            result ="Wait! You did not select any folder."
            QMessageBox.warning(None, "No folder selected", result)

        return pasta

    def carrega_arquivos(self, lineEdit, file_type="raster", qtd=1):
        """Esta função é utilizada para adicionar os arquivos enviados pelo usuário ao plugin"""
        # Define as variáveis e configurações da janela de escolha do arquivo
        file_ = None
        options = QFileDialog.Options()
        directory = self.dlg_flow_tt.le_13_pg1.text()

        while True:  # Loop até que o usuário selecione um arquivo ou cancele
            if qtd == 2:
                file_, _ = QFileDialog.getOpenFileNames(None, caption="Select the files!", directory=directory, filter="Raster or RDC file (*.tif *.rst *.rdc)", options=options)
                if file_:
                    lineEdit.setPlainText("\n".join(file_))
                    self.rdc_vars.nomeRDC = file_[0] if file_ else None
                    self.rdc_vars.nomeRST = file_[1] if len(file_) > 1 else None
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No file selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break  
            else:
                # Janela de diálogo com o Usuário
                if file_type == "raster".lower():
                    file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory=directory, filter="Raster Files (*.tif *.rst)", options=options)
                elif file_type == "text".lower():
                    file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory=directory, filter="Text Files (*.txt)", options=options)

                # Verificar se algum arquivo foi selecionado
                if file_:
                    # Adiciona o arquivo selecionado a lineEdit
                    lineEdit.setText(file_)
                    return file_
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break 

    def leh_bacia(self):
        """Esta função é utilizada para ler as informações da bacia hidrográfica (arquivo .rst)"""
        
        # Arquivo raster enviado pelo usuário
        arquivo = self.dlg_flow_tt.le_1_pg2.text()
        # Tratamento de erros: verifica se o arquivo foi corretamente enviado
        if arquivo:
            # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
            rst_file_bacia = gdal.Open(arquivo)

            # Lendo os dados raster como um array 
            dados_lidos_bacia = rst_file_bacia.GetRasterBand(1).ReadAsArray()
            
            # Tratamento de erro: verifica se o arquivo foi aberto corretamente
            if rst_file_bacia is not None:

                # atualizando os valores das variáveis para coletar o número de linhas e colunas do arquivo raster lido
                self.rdc_vars.nlin = rst_file_bacia.RasterYSize               
                self.rdc_vars.ncol = rst_file_bacia.RasterXSize

                # Determinando o numéro de elementos contidos no arquivo raster
                num_elements_bacia = dados_lidos_bacia.size

                # Tratamento de erros: verifica se o número de elementos (pixel) do arquivo está de acordo com as dimensões da matriz da bacia hidrográfica
                if num_elements_bacia != self.rdc_vars.nlin * self.rdc_vars.ncol:
                    result = f"ERROR! As dimensões do arquivo raster ({self.rdc_vars.nlin},{self.rdc_vars.ncol}) são diferentes do número total de \
                        elementos {num_elements_bacia}. Assim, não é possível ler o arquivo raster '{arquivo}' e armazená-lo na matriz destinada."
                    QMessageBox.warning(None, "ERROR!", result)
                else:
                    # Reorganizando os dados lidos da bacia em uma nova matriz chamada bacia.

                    # global_vars.bacia = dados_lidos_bacia
                    self.global_vars.bacia = dados_lidos_bacia
                    # Fechando o dataset GDAL

                    rst_file_bacia = None
            else:
                """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
                resulte = f"Failde to open the raster file: {arquivo}"
                QMessageBox.warning(None, "ERROR!", resulte)

        else:
            result ="Nenhum arquivo foi selecionado!"
            QMessageBox.warning(None, "ERROR!", result)

    def leh_valores_table_1(self):
        '''Esta função coleta as informações adicionadas nos itens da tabela da característica dos rios e adiciona em suas variáveis'''

        # Verifica a dimensão da tabela
        nlin_tb = self.dlg_flow_tt.tbw_1_pg2.rowCount()
        ncol_tb = self.dlg_flow_tt.tbw_1_pg2.columnCount()

        # Define variáveis para obtenção das informações
        id_class = []
        slope_class = []
        mann_coef_class = []
        hydraul_rad_class = []
        item = 0

        # Itera sobre os itens da tabela
        for col in range(ncol_tb):
            for lin in range(nlin_tb):
                item_tb = self.dlg_flow_tt.tbw_1_pg2.item(lin,col).text()

                if item_tb is not None:
                    # coleta o item da celula atual e tenta converter para float
                    item_tb = float(self.dlg_flow_tt.tbw_1_pg2.item(lin,col).text())

                    # coleta o id das classes
                    if col == 0:
                        id_class.append(item_tb)

                    # coleta a inclinação
                    elif col == 1:
                        slope_class.append(item_tb)
                    
                    # coleta o coeficiente de Manning
                    elif col == 2:
                        mann_coef_class.append(item_tb)
                    
                    # coleta o raio hidráulico
                    elif col == 3:
                        hydraul_rad_class.append(item_tb)
        # Atualiza a variável 
        # Atualiza as variáveis globais com os valores enviados
        self.global_vars.j = np.array(id_class)
        self.global_vars.Sclasse = np.array(slope_class)
        self.global_vars.Mannclasse = np.array(mann_coef_class)
        self.global_vars.Rhclasse = np.array(hydraul_rad_class)

    def leh_classes_rios(self):
        """Esta função é utilizada para ler as informações acerca da classe dos rios da bacia hidrográfica (arquivo raster -  .rst)"""
        
        # Abrindo o arquivo com as informações acerca das classes dos rios
        arquivo = self.dlg_flow_tt.le_4_pg2.text()

        # Tratamento de erros: verifica se o arquivo foi corretamente enviado
        if arquivo:
            # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
            rst_file_claRIO = gdal.Open(arquivo)
            
            # Lendo os dados raste como um array 
            dados_lidos_raster_claRIO = rst_file_claRIO.GetRasterBand(1).ReadAsArray()

            #  Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
            if rst_file_claRIO is not None:
                # Reorganizando os dados lidos em uma nova matriz, essa possui as informações sobre as classes dos rios
                self.global_vars.classerio = dados_lidos_raster_claRIO
                # Fechando o dataset GDAL referente ao arquivo raster
                rst_file_claRIO = None
            else:
                # Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro
                resulte = f"Failde to open the raster file: {arquivo}"
                QMessageBox.warning(None, "ERROR!", resulte)
                
        else:
            # Exibe uma mensagem de erro
            result ="Nenhum arquivo foi selecionado!"
            QMessageBox.warning(None, "ERROR!", result)

    def leh_direcoes_de_fluxo(self):
        """Esta função é utilizada para ler as informações acerca da direção de escoamento dos rios (arquivo raster - .rst)"""

        # Definindo a numeração das direções &
        # Definindo a posição relativa dos pixels vizinhos
        # lin viz = lin centro + dlin(i)
        # col viz = col centro + dcol(i)
        
        self.global_vars.dlin = {
                            1: -1,
                            2: 0,
                            4: 1,
                            8: 1,
                            16: 1,
                            32: 0,
                            64: -1,
                            128: -1
                            }
        self.global_vars.dcol = {
                            1: 1,
                            2: 1,
                            4: 1,
                            8: 0,
                            16: -1,
                            32: -1,
                            64: -1,
                            128: 0
                            }

       
        # ATENÇÃO PARA O VALOR NUMÉRICO DAS DIRECÕES
        # ---------------------------------------------------------
        # - G  H  A      ArcView:  32 64 128    MGB-IPH:  64  128  1 -
        # - F  *  B                16  *  1               32   *   2 -
        # - E  D  C                 8  4  2               16   8   4 -

        # Recebendo os arquivos necessários: função run
        linhas_text_edit = self.dlg_flow_tt.te_1_pg2.toPlainText()
        linhas = linhas_text_edit.split('\n')
        self.rdc_vars.nomeRDC = linhas[0]
        self.rdc_vars.nomeRST = linhas[1]

        if self.rdc_vars.nomeRDC !='' and self.rdc_vars.nomeRST !='':
            # Verificando a extensão do arquivo: ordem de leitura, 1st o arquivo rdc
            exten1 = Path(self.rdc_vars.nomeRDC).suffix.lower()
            exten2 = Path(self.rdc_vars.nomeRST).suffix.lower()
            # Verifica se o primeiro arquivo é .rdc e o segundo .rst
            if exten1 == ".rdc" and exten2 == ".rst":
                self.rdc_vars.nomeRDC, self.rdc_vars.nomeRST = self.rdc_vars.nomeRDC, self.rdc_vars.nomeRST
            # Verifica se o primeiro arquivo é .rst e o segundo .rdc, caso contrário, troca os nomes
            elif exten1 == ".rst" and exten2 == ".rdc":
                self.rdc_vars.nomeRDC, self.rdc_vars.nomeRST = self.rdc_vars.nomeRST, self.rdc_vars.nomeRDC

            # Abrindo o arquivo RDC
            arquivo = self.rdc_vars.nomeRDC
            with open(arquivo, 'r',  encoding='iso-8859-1') as rdc_file:
                # Separando os dados do arquivo RDC em função das linhas que contém alguma das palavras abaixo
                k_words = ["columns", "rows", "ref. system", "ref. units", "min. X", "max. X", "min. Y", "max. Y", "resolution"]
                lines_RDC = [line.strip() for line in rdc_file.readlines() if any(word in line for word in k_words)]
                
                # Iterando sobre a lista de lines_rdc para guardas as informações das palavras da lista (k_words) nas ruas respectivas variáveis
                for line in lines_RDC:
                    # Separando as linhas de acordo com o refencial (:)
                    split_line = line.split(":")
                    # Armazenando o primeiro valor da linha (antes do sinal ":")em uma variável e retirando os espaços (caracter) do inicio e fim da linha repartida
                    key = split_line[0].strip()
                    # Armazenando o segundo valor da linha (antes do sinal ":") em uma variáveis e retirando os espaços (caracter) do inicio e fim da linha repartida
                    value = split_line[-1].strip()

                    # Estrutura condicional para verificar quais são as informações de cada linha e armazenando elas em suas respectivas variáveis
                    if key == "rows":
                        self.rdc_vars.nlin = int(value)
                    elif key == "columns":
                        self.rdc_vars.ncol = int(value)
                    elif key == "ref. system":
                        self.rdc_vars.sistemaref = value
                    elif key == "ref. units":
                        self.rdc_vars.unidaderef3 = value
                    elif key == "min. X":
                        self.rdc_vars.xmin = float(value)
                    elif key == "max. X":
                        self.rdc_vars.xmax = float(value)
                    elif key == "min. Y":
                        self.rdc_vars.ymin = float(value)
                    elif key == "max. Y":
                        self.rdc_vars.ymax = float(value)
                    elif key == "resolution":
                        self.global_vars.dx = float(value)
            
            # Atualizando algumas variáveis com as informações coletadas do arquivo RDC
            self.global_vars.Xres2 = self.global_vars.dx
            self.global_vars.Xres = float(self.global_vars.Xres2)
            self.global_vars.Yres = self.global_vars.Xres

            # Abrindo o arquivo raster
            rst_file_dir = gdal.Open(self.rdc_vars.nomeRST)
            # Lendo os dados raster como um array
            dados_lidos_direcoes = rst_file_dir.GetRasterBand(1).ReadAsArray()

            # Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
            if rst_file_dir is not None:
                # Reorganizando os dados lidos na matriz destinadas às informações da drenagem da bacia hidrográfica
                self.global_vars.direcoes = dados_lidos_direcoes

                # Fechando o dataset GDAL referente ao arquivo raster
                rst_file_dir = None
            else:
                """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
                resulte = f"Failde to open the raster file: {self.rdc_vars.nomeRST}"
                QMessageBox.warning(None, "ERROR!", resulte)

            # Verificação do valor da variável maxdir
            self.global_vars.maxdir = np.amax(self.global_vars.direcoes)

            # Iniciando a iterações com base nas linhas e colunas
            if self.global_vars.maxdir > 128:
                # Mapeamento das direções de fluxo do tipo idrisi
                A = self.dlg_flow_tt.le_5_pg1.text()
                B = self.dlg_flow_tt.le_6_pg1.text()
                C = self.dlg_flow_tt.le_7_pg1.text()
                D = self.dlg_flow_tt.le_8_pg1.text()
                E = self.dlg_flow_tt.le_9_pg1.text()
                F = self.dlg_flow_tt.le_10_pg1.text()
                G = self.dlg_flow_tt.le_11_pg1.text()
                H = self.dlg_flow_tt.le_12_pg1.text()
                valores = [A, B, C, D, E, F, G, H]
                chaves = [45, 90, 135, 180, 225, 270, 315, 360]
                value_error = [valor for valor in valores if type(valor) != int]

                # Dicionário com as combinações das direções de fluxo
                idrisi_map = {}
                for chave, valor in zip(chaves, valores):
                    try:
                        idrisi_map[chave] = int(valor) #devem ser diferentes entre si, i+1 != i e i-1
                    except ValueError:
                        result = f'The value(s) "{value_error}" is(are) not (a) valid integer number(s)!'
                        QMessageBox.warning(None, "ERROR!", result)
                
                for lin in range(self.rdc_vars.nlin):
                    for col in range(self.rdc_vars.ncol):
                        # Verifica se o valor atual da variável maxdir está presente no mapeamento
                        if self.global_vars.direcoes[lin, col] in idrisi_map:
                            # Atualiza o valor do elemento atual da matriz dir de acordo com os novos valores
                            self.global_vars.direcoes[lin, col] = idrisi_map[self.global_vars.direcoes[lin, col]]


            # Tratamento das direções na borda
            self.global_vars.direcoes[0, :] = 128
            self.global_vars.direcoes[-1, :] = 8
            self.global_vars.direcoes[:, 0] = 32
            self.global_vars.direcoes[:, -1] = 2

    def leh_drenagem(self):
        """Esta função é utilizada para ler as informações acerca da drenagem dos rios (arquivo raster - .rst)"""

        # Obtendo o arquivo referente as calasses dos rios da bacia hidrográfica
        arquivo = self.dlg_flow_tt.le_3_pg2.text()
        # Abrindo o arquivo raster com as informações acerda do sistema de drenagem da bacia hidrográfica
        rst_file_drenagem = gdal.Open(arquivo)
        
        # Lendo os dados raster como um array
        dados_lidos_drenagem = rst_file_drenagem.GetRasterBand(1).ReadAsArray()

        # Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_drenagem is not None:
            # Reorganizando os dados lidos na matriz destinadas às informações da drenagem da bacia hidrográfica
            self.global_vars.dren = dados_lidos_drenagem
            
            # Fechando o dataset GDAl referente ao arquivo raster
            rst_file_drenagem = None
        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {arquivo}"
            QMessageBox.warning(None, "ERROR!", resulte)


    def leh_modelo_numerico_dTerreno(self):
        """Esta função é utilizada para ler as informações acerca do modelo numérico do terreno (arquivo raster - .rst)"""

        # Obtendo o arquivo referente ao MDE da bacia hidrográfica
        arquivo = self.dlg_flow_tt.le_2_pg2.text()

        # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
        rst_file_MDE = gdal.Open(arquivo)

        # Lendo os dados raster como um array
        dados_lidos_MDE = rst_file_MDE.GetRasterBand(1).ReadAsArray()

        #  Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_MDE is not None:
            # Reoganizando os dados lidos em uma nova matriz que possuirá os dados ligados ao MDE da baciaa hidrográfica
            self.global_vars.MDE = dados_lidos_MDE

            # Fechando o dataset GDAL
            rst_file_MDE = None
        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {arquivo}"
            QMessageBox.warning(None, "ERROR!", resulte)

    def leh_precipitacao_24h(self):
        """Esta função é utilizada para ler as informações acerca da precipitação das últimas 24 horas, P24 (arquivo texto - .txt)"""

        # Armazenando o valor da precipitação de 24 horas em uma variável específica
        self.global_vars.P24 = float(self.dlg_flow_tt.le_6_pg2.text())

    def leh_uso_do_solo(self):
        """Esta função é utilizada para ler as informações acerca do uso do solo (arquivo raster - .rst)"""

        # Obtendo o arquivo raster referente ao uso do solo
        arquivo = self.dlg_flow_tt.le_5_pg2.text()

        # Abrindo o arquivo raster com as informações acerda do uso do solo da bacia hidrográfica
        rst_file_usoSolo = gdal.Open(arquivo)

        # Lendo os dados do arquivo raster como um array
        dados_lidos_usoSolo = rst_file_usoSolo.GetRasterBand(1).ReadAsArray()

        # Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_usoSolo is not None:
            # Reorganizando os dados lidos na matriz destinadas às informações da drenagem da bacia hidrográfica
            self.global_vars.usosolo = dados_lidos_usoSolo

            # Inicializando as variáveis fundamentais
            self.global_vars.Nusomax = np.amax(self.global_vars.usosolo)

        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {arquivo}"
            QMessageBox.warning(None, "ERROR!", resulte)

                  
    def leh_valores_table_2(self):
        '''Esta função coleta as informações adicionadas nos itens da tabela das classes do uso e ocupação do solo e adiciona em suas variáveis'''
        # Verifica a dimensão da tabela
        nlin_tb = self.dlg_flow_tt.tbw_2_pg2.rowCount()
        ncol_tb = self.dlg_flow_tt.tbw_2_pg2.columnCount()

        # Cria variáveis necessárias
        uso_manning_val = []
        coef_maning_val = []

        # Itera sobre os itens da tabela
        for col in range(ncol_tb):
            for lin in range(nlin_tb):
                item_tb = self.dlg_flow_tt.tbw_2_pg2.item(lin,col).text()

                if item_tb is not None:
                    
                    # Coleta os ID's das classes
                    if col == 0:
                        # coleta o item da celula atual e tenta converter para int
                        item_tb = self.dlg_flow_tt.tbw_2_pg2.item(lin,col).text()

                        # Armazena o valor do ID em sua variável
                        uso_manning_val.append(item_tb)
                    
                    # Coleta os valores dos coeficiente de Mannning por classe
                    if col == 2:
                        # coleta o item da celula atual e tenta converter para float
                        item_tb = self.dlg_flow_tt.tbw_2_pg2.item(lin,col).text()

                        # Armazena o valor do coef. de Manning em sua variável
                        coef_maning_val.append(item_tb)

        # Adicionando cada valor às suas respectivas variáveis
        self.global_vars.usaux = uso_manning_val
        self.global_vars.Mann = coef_maning_val

    def project(self,x1, x2, y1,y2,tipo2,dist2,lado2,diagonal2):
        """Esta função calcula as distâncias sobre a superfície considerando o elipsóide WGS84"""
        # Definindo as constantes
        PI = 3.141592
        A = 6378.137 #comprimento do semi eixo maior do elipsóide (km)
        B = 6358.752 #comprimento do semi eixo menor do elipsóide (km)

        # Iniciando os cálulos
        ylat = (y1 + y2) / 2

        # Definição do achatamento do elipsóide
        f = (A - B) / A 
        # Determinando o quadrado da excentricidade
        e2 = (2*f) - (f**2) 
        # Determinando o raio da curvatura da Terra na latitude ylat
        rn = A / ((1 - e2*(np.sin(ylat)))**0.2) 

        # Calculando o raio da circunferência de um círculo determinado pelo plano que corta o elipsóide na latitude ylat
        raio_circ = rn*np.cos(ylat)
        dgx = x2 - x1
        dgy = y1 - y2

        dx = raio_circ*dgx*(PI/180.0)
        dy = rn*dgy*(PI/180.0)

        # Verificando o conteúdo da vairável tipo2 e atualizando a distanância com base nele
        if tipo2 == 1:
            dist2 = dx*lado2
        elif tipo2 == 2:
            dist2 = dy*lado2
        elif tipo2 == 3:
            dist2 = np.sqrt(dx**2+dy**2)*diagonal2/1.414

        self.global_vars.dist_2 = dist2

        return dist2

    def comprimento_acumulado(self):
        """Esta função determina o comprimento dos pixels que fazem partes da rede de drenagem da bacia hidrográfica. Da cabeceira ao exutório em questão"""
        # Define variáveis
        Lfoz = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.Lfoz= Lfoz
        Lac = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.Lac = Lac
        Lac = None
        Lfoz = None

        # Redefinindo as respectivas variáveis
        self.global_vars.lado = float(self.dlg_flow_tt.le_3_pg1.text())
        self.global_vars.diagonal = float(self.dlg_flow_tt.le_4_pg1.text())
        
        # Iniciando a iteração para varrer todos os elementos da bacia hidrográfica
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Delimitando apenas os elementos que estão presentes na bacia hidrográfica
                if self.global_vars.bacia[lin,col] == 1:
                    # Coletando as informações referentes ao sistema de drenagem da bacia hidrográfica
                    if self.global_vars.dren[lin,col] == 1:
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.caminho = 0
                        
                        while self.global_vars.caminho == 0:

                            # Criando condição de parada
                            condicao = self.global_vars.linaux <= 1 or self.global_vars.linaux >= self.rdc_vars.nlin \
                            or self.global_vars.colaux<=1 or self.global_vars.colaux>= self.rdc_vars.ncol \
                            or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux] == 0

                            if condicao:
                                self.global_vars.caminho = 1

                            else:
                                # Continuar caminho: determina a contagem das distâncias projetadas (WGS84) e \
                                # determina as coordenadas verticais do pixel+

                                self.global_vars.Xesq = self.rdc_vars.xmin + (self.global_vars.colaux - 1)*self.global_vars.Xres
                                self.global_vars.Xdir = self.global_vars.Xesq + self.global_vars.Xres
                                self.global_vars.Yinf = self.global_vars.ymax - self.global_vars.linaux*self.global_vars.Yres
                                self.global_vars.Ysup = self.global_vars.Yinf + self.global_vars.Yres

                                # Determinando a posição relativa ao pixel anterior
                                condicao2 = self.global_vars.linaux2 == self.global_vars.linaux or self.global_vars.colaux2 == self.global_vars.colaux
                                if condicao2:
                                    if self.global_vars.linaux2 == self.global_vars.linaux:
                                        self.rdc_vars.tipo = 1
                                    else:
                                        self.rdc_vars.tipo = 2
                                else:
                                    self.rdc_vars.tipo = 3

                                # Deteminando a distância incremental projetada
                                if self.global_vars.metro == 0:
                                    self.global_vars.auxdist = self.project(self.global_vars.Xesq,
                                                                        self.global_vars.Xdir,
                                                                        self.global_vars.Ysup,
                                                                        self.global_vars.Yinf,
                                                                        self.rdc_vars.tipo,
                                                                        self.global_vars.auxdist,
                                                                        self.global_vars.lado,
                                                                        self.global_vars.diagonal)
                                    
                                else:
                                    if self.rdc_vars.tipo == 1 or self.rdc_vars.tipo == 2:
                                        self.global_vars.auxdist = self.global_vars.dx*self.global_vars.lado

                                    else:
                                        self.global_vars.auxdist = self.global_vars.dx*self.global_vars.diagonal
                                        
                                # Atualizando o comprimento do rio desde o pixel inicial
                                self.global_vars.tamcam += self.global_vars.auxdist
                                self.global_vars.tamfoz = self.global_vars.tamcam

                                # Condição para verificar se o tamanho do rio é maior que o armazenameto do pixel
                                condicao3 = self.global_vars.tamcam > self.global_vars.Lac[self.global_vars.linaux, self.global_vars.colaux]
                                if condicao3:
                                    # O valor do pixel é armazenado em um novo rio
                                    self.global_vars.Lac[self.global_vars.linaux, self.global_vars.colaux] = self.global_vars.tamcam
                                
                                # Armazena o pixel contabilizado
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux

                                # determina o próximo píxel do caminho
                                self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux, self.global_vars.colaux]
                                self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                                self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]
                                # JVD: alocação redundante(caminho = 0)
                                self.global_vars.sda = 0

                        # Atulizando a variável lfoz
                        self.global_vars.Lfoz[lin, col] = self.global_vars.tamfoz

    def numera_pixel(self):
        '''
        Esta função enumera os píxels presentes na rede de drenagem
        '''
        # Define variáveis
        self.contadren = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol), dtype=np.float64)
        self.numcabe = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol), dtype=np.float64)
        self.cabeceira = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.numcabeaux = 0
        
        # Enumerando os píxels pertencentes à bacia e à rede de drenagem
        pix_bacia_e_dren = (self.global_vars.bacia == 1) & (self.global_vars.dren == 1)

        self.rdc_vars.cont += np.sum(pix_bacia_e_dren)

        self.contadren[pix_bacia_e_dren] = self.rdc_vars.cont

        pixel_dren = np.where(self.global_vars.dren == 1)
        self.global_vars.lincontadren = np.array(pixel_dren[0])
        self.global_vars.colcontadren = np.array(pixel_dren[1])


        # Numeração dos píxels internos a bacia: São chamados de cabeceira, pois o caminho do fluxo é iniciado a partir de cada um deles
        for col in range(1, self.rdc_vars.ncol - 1):
            for lin in range(1, self.rdc_vars.nlin - 1):
            
                # Atualizará apenas os píxel que estão na bacia hidrográfica(cabeceira == 1)
                if self.global_vars.bacia[lin][col] == 1:
                    # A priori, todos os píxels serão considerados de cabeceira
                    self.cabeceira[lin][col] = 1
                    # Cria vizinhança 3x3 para estudar a direção de fluxo do píxel central.
                    for linaux in range(lin - 1, lin + 2):
                        for colaux in range(col - 1, col + 2):
                            # Para cada vizinho, verifica a direção de fluxo dela e para qual pixel ele drena
                            self.global_vars.diraux = self.global_vars.direcoes[linaux][colaux]
                            self.global_vars.linaux2 = linaux + self.global_vars.dlin[self.global_vars.diraux]
                            self.global_vars.colaux2 = colaux + self.global_vars.dcol[self.global_vars.diraux]

                            # Se algum vizinho drenar para o central em análise, este não é de cabeceira
                            if self.global_vars.linaux2 == lin and self.global_vars.colaux2 == col:
                                self.cabeceira[lin][col] = 0

                    # Contagem de píxels que são cabeceira
                    if self.cabeceira[lin][col] == 1:
                        self.numcabeaux += 1
                        self.numcabe[lin][col] = self.numcabeaux

        # Atualiza variáveis globais
        self.global_vars.numcabe = self.numcabe

        # JVD: redundancia de variáveis, Ncabe = numcabeaux
        self.global_vars.numcabeaux = self.numcabeaux

    def dist_drenagem(self):
        """Esta funçao determina a distância incremental percorrida pela água na rede de drenagem,
            assim como a declividade pixel a pixel"""

        # Redimenciona as variáveis necessárias
        dist = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        pixeldren = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.pixeldren = pixeldren
        pixeldren = None
        Difcota = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.Difcota = Difcota
        Difcota = None
        DECLIVpixjus = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.DECLIVpixjus = DECLIVpixjus
        DECLIVpixjus = None
        TSpix = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.TSpix = TSpix
        TSpix = None

        # Atualizando as referidas variáveis
        self.global_vars.lado = float(self.dlg_flow_tt.le_3_pg1.text())
        self.global_vars.diagonal = float(self.dlg_flow_tt.le_4_pg1.text())

        # iterando sobre os elementos do arquivo raster
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Relaizando operações no apenas na região da bacia hidográfica
                if self.global_vars.bacia[lin][col] == 1:
                    self.global_vars.linaux = lin
                    self.global_vars.colaux = col
                    self.global_vars.caminho = 0
                    self.global_vars.tamcam = 0.0

                    if self.global_vars.dren[lin][col] == 1:
                        self.global_vars.caminho = 1

                    else:
                        while self.global_vars.caminho == 0:
                            
                            condicao = (self.global_vars.linaux<= 1
                            or self.global_vars.linaux>=self.rdc_vars.nlin
                            or self.global_vars.colaux<=1 or self.global_vars.colaux>= self.rdc_vars.ncol
                            or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux]==0)

                            # Verificando a resposta da variável condicao
                            if condicao:
                                self.global_vars.caminho = 1
                            
                            else:
                                # Criando a segunda condição: 
                                # valores pertencentes ao sistema de drenagem da bacia
                                condicao2 = self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] == 1

                                if condicao2:
                                    # Após alocação do pixel da rede de drenagem: encerra o processo de busca
                                    self.global_vars.caminho = 1
                                    dist[lin][col] = self.global_vars.tamcam
                                    self.global_vars.pixeldren[lin][col] = self.contadren[self.global_vars.linaux][self.global_vars.colaux]
                                else:
                                    self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                                    self.global_vars.caminho = 0
                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.linaux2 = self.global_vars.linaux

                                    self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                                    self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]

                                    # Calculando a distância incremental percorrida &
                                    # Contabilizar distancias projetadas (WGS84) &
                                    # Determina coordenadas vertices do pixel
                                    self.global_vars.Xesq = self.rdc_vars.xmin + (self.global_vars.colaux2 - 1) * self.global_vars.Xres
                                    self.global_vars.Xdir = self.global_vars.Xesq + self.global_vars.Xres
                                    self.global_vars.Yinf = self.rdc_vars.ymax - self.global_vars.linaux2 * self.global_vars.Yres
                                    self.global_vars.Ysup = self.global_vars.Yinf + self.global_vars.Yres

                                    # Determina a posição relativa ao píxel anterior
                                    condicao3 = self.global_vars.linaux2 == self.global_vars.linaux or self.global_vars.colaux2 == self.global_vars.colaux
                                    if condicao3:
                                        if self.global_vars.linaux2 == self.global_vars.linaux:
                                            self.rdc_vars.tipo = 1
                                        else:
                                            self.rdc_vars.tipo = 2
                                    else:
                                        self.rdc_vars.tipo = 3

                                    # Determinando a distância incremental projetada
                                    if self.global_vars.metro == 0:
                                        self.global_vars.auxdist = self.project(self.global_vars.Xesq,
                                                           self.global_vars.Xdir,
                                                           self.global_vars.Ysup,
                                                           self.global_vars.Yinf,
                                                           self.rdc_vars.tipo,
                                                           self.global_vars.auxdist,
                                                           self.global_vars.lado,
                                                           self.global_vars.diagonal)
                                    else:
                                        condicao4 = self.rdc_vars.tipo == 1 or self.rdc_vars.tipo == 2
                                        if  condicao4:
                                            self.global_vars.auxdist = self.global_vars.dx * self.global_vars.lado
                                        else:
                                            self.global_vars.auxdist = self.global_vars.dx * self.global_vars.diagonal
                                    
                                    # atualiza o comprimento do rio desde o pixel inicial
                                    self.global_vars.tamcam += self.global_vars.auxdist

                                    # ARPdeclivjus
                                    if self.global_vars.tipo_decliv == 4:
                                        # calcula declividade do pixel relativo ao pixel de jusante (este pixel)
                                        self.global_vars.Lincr = self.global_vars.auxdist
                                        self.global_vars.Difcota = self.global_vars.MDE[self.global_vars.linaux2][self.global_vars.colaux2] - self.global_vars.MDE[self.global_vars.linaux][self.global_vars.colaux]
                                        self.global_vars.DECLIVpixjus[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.Difcota/self.global_vars.Lincr*1000.0
                                        self.global_vars.Streaux = self.global_vars.DECLIVpixjus[self.global_vars.linaux2][self.global_vars.colaux2]
                                        self.global_vars.Ltreaux = self.global_vars.Lincr
                                        self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux2][self.global_vars.colaux2]
                                        self.global_vars.Smin = float(self.dlg_flow_tt.le_1_pg1.text()) #em m/km

                                        if self.global_vars.Streaux < self.global_vars.Smin:
                                            self.global_vars.Streaux = self.global_vars.Smin
                                        
                                        self.global_vars.Smax = float(self.dlg_flow_tt.le_2_pg1.text()) #em m/km
                                        if self.global_vars.Streaux > self.global_vars.Smax:
                                            self.global_vars.Streaux = self.global_vars.Smax

                                        # JVD: correção da indexação para o python (inicia no zero)
                                        # Calcula o TS por píxel
                                        self.global_vars.TSpix[self.global_vars.linaux2][self.global_vars.colaux2] = 5.474 * ((self.global_vars.Mann[self.global_vars.usaux - 1] *self.global_vars.Ltreaux)**0.8) \
                                            / ((self.global_vars.P24**0.5)*((self.global_vars.Streaux/1000.0)**0.4))
        # Atualiza as variáveis globais
        self.global_vars.DIST = dist

    def dist_trecho(self):
        ''' Esta função determina o número dos diferentes trechos que existem na bacia hidrográfica estudada'''
        self.global_vars.numtreauxmax = 0
        TREpix = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.TREpix = TREpix
        TREpix = None
        condicao1 = None
        
        #ARPlidar: loop para contar o número máximo de trechos
        for col in range(1, self.rdc_vars.ncol):
            for lin in range(1, self.rdc_vars.nlin):

                # Ações realizadas apenas na região da bacia
                if self.global_vars.bacia[lin][col] == 1:

                    # ARPlidar
                    if self.global_vars.numcabe[lin][col] > 0:
                        self.global_vars.numcabeaux = int(self.global_vars.numcabe[lin][col])
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.linaux2 = lin
                        self.global_vars.colaux2 = col
                        self.global_vars.linaux3 = lin
                        self.global_vars.colaux3 = col
                        self.global_vars.numtreaux = 0
                        self.global_vars.caminho = 0
                        self.global_vars.usaux = self.global_vars.usosolo[lin][col]
                        self.global_vars.usaux2 = self.global_vars.usaux

                        # ARPlidar
                        # Grava qual trecho o píxel em questão pertence
                        self.global_vars.numtreaux2 = 1

                        while self.global_vars.caminho == 0:
                            self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                            self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                            self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]


                            condicao1 = self.global_vars.usaux != self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]
                            condicao2 = self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] == 1
                           
                            if condicao1 or condicao2:
                                # Mudou o uso do solo ou alcançou a rede de drenagem,
                                # então terminou um trecho no píxel anterior
                                self.global_vars.numtreaux += 1

                                if self.global_vars.numtreaux > self.global_vars.numtreauxmax:
                                    self.global_vars.numtreauxmax = self.global_vars.numtreaux

                                # ARPlidar: incluindo o teste da bacia
                                condicao3 = self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] == 1 or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux] == 0
                                if condicao3:
                                    self.global_vars.caminho = 1
                                else:
                                    # Continua o caminho, porém em um trecho novo
                                    self.global_vars.linaux2 = self.global_vars.linaux
                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.linaux3 = self.global_vars.linaux
                                    self.global_vars.colaux3 = self.global_vars.colaux
                                    self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]
                                    # ARPdecliv
                                    # Grava qual trecho o píxel em questão pertence
                                    self.global_vars.numtreaux2 += 1
                            else:
                                # Vai continuar caminhando, mas grava o valor do par (lin,col) do último píxel acessado
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux
                                self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

        self.global_vars.Ntre = self.global_vars.numtreauxmax + 1

        # Percorrendo o caminho desde as cabeceiras e granvando as distâncias relativas de cada trecho de uso do solo contínuo

        # Redimenciona variáveis necessárias
        cotaini = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.cotaini = cotaini
        containi = None
        cotafim = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.cotafim = cotafim
        cotafim = None
        Ltre = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.Ltre = Ltre
        Ltre = None
        Stre = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.Stre = Stre
        Stre = None
        usotre = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.usotre = usotre
        usotre = None
        DISTult = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.DISTult = DISTult
        DISTult = None
        refcabtre  = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        self.global_vars.refcabtre = refcabtre
        refcabtre = None
        DISTtre  = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        self.global_vars.DISTtre = DISTtre
        DECLIVpix  = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        self.global_vars.DECLIVpix = DECLIVpix
        DECLIVpix = None
        CABEpix = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        self.global_vars.CABEpix = CABEpix
        CABEpix = None

        # Continua o cálculo dos trechos
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Verificando os elementos da região da bacia
                if self.global_vars.numcabe[lin][col] > 0:
                    self.global_vars.numcabeaux = int(self.global_vars.numcabe[lin][col])
                    self.global_vars.linaux = lin
                    self.global_vars.colaux = col
                    self.global_vars.linaux2 = lin
                    self.global_vars.colaux2 = col
                    self.global_vars.linaux3 = lin
                    self.global_vars.colaux3 = col
                    self.global_vars.numtreaux = 0
                    self.global_vars.caminho = 0
                    self.global_vars.usaux = self.global_vars.usosolo[lin][col]
                    self.global_vars.usaux2 = self.global_vars.usaux

                    # ARPdecliv
                    # Grava qual trecho o píxel em questão pertence
                    self.global_vars.numtreaux2 = 1
                    self.global_vars.TREpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numcabeaux2

                    while self.global_vars.caminho == 0:
                        self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                        self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                        self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]

                        if condicao1 or condicao2:
                            # Mudou o tipo de uso do solo ou alcançou a rede de drenagem,
                            # então terminou o trecho no píxel anterior
                            self.global_vars.numtreaux +=1
                            self.global_vars.numtre[self.global_vars.numcabeaux] = self.global_vars.numtreaux
                            self.global_vars.Ltre[self.global_vars.numcabeaux][self.global_vars.numtreaux] = self.global_vars.DIST[self.global_vars.linaux3][self.global_vars.colaux3] \
                                                                                                            - self.global_vars.DIST[self.global_vars.linaux][self.global_vars.colaux] 
                                                                                                            
                            # Grava a distância (DIST) do último píxel do trecho
                            self.global_vars.DISTult[self.global_vars.numcabeaux][self.global_vars.numtreaux] = self.global_vars.DIST[self.global_vars.linaux][self.global_vars.colaux]
                            self.global_vars.cotaini[self.global_vars.numcabeaux][self.global_vars.numtreaux] = self.global_vars.MDE[self.global_vars.linaux3][self.global_vars.colaux3]
                            self.global_vars.cotafim[self.global_vars.numcabeaux][self.global_vars.numtreaux] = self.global_vars.MDE[self.global_vars.linaux][self.global_vars.colaux]
                            
                            a1 = (self.global_vars.cotaini[self.global_vars.numcabeaux][self.global_vars.numtreaux] - self.global_vars.cotafim[self.global_vars.numcabeaux][self.global_vars.numtreaux])
                            b1 = self.global_vars.Ltre[self.global_vars.numcabeaux][self.global_vars.numtreaux]*1000.0
                            self.global_vars.Stre[self.global_vars.numcabeaux][self.global_vars.numtreaux] = a1 / b1
                            self.global_vars.usotre[self.global_vars.numcabeaux][self.global_vars.numtreaux] = self.global_vars.usaux

                            # ARPlidar: adiciona a bacia como condição; chegar na rede de drenagem ou sair da baica, finaliza while
                            condicao4 = self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] == 1 or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux] == 0
                            if condicao4:
                                self.global_vars.caminho = 1
                                self.global_vars.refcabtre[self.global_vars.linaux3][self.global_vars.colaux3] = self.global_vars.numtreaux
                                self.global_vars.refcabtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux

                            else:
                                # Vai continuar o cominho, mas em um novo trecho
                                self.global_vars.refcabtre[self.global_vars.linaux3][self.global_vars.colaux3] = self.global_vars.numtreaux
                                self.global_vars.refcabtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux

                                self.global_vars.linaux3 = self.global_vars.linaux
                                self.global_vars.colaux3 = self.global_vars.colaux
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux
                                self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                                # ARPdecliv
                                # Grava qual trecho o píxel em questão pertence
                                self.global_vars.numtreaux2 += 1
                                self.global_vars.TREpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux2

                        else:
                            # Vai continuar caminhando, mas grava o valor do par (lin,col) do último píxel acessado
                            self.global_vars.refcabtre[self.global_vars.linaux3][self.global_vars.colaux3] = self.global_vars.numtreaux + 1
                            self.global_vars.refcabtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux + 1
                            
                            self.global_vars.linaux2 = self.global_vars.linaux
                            self.global_vars.colaux2 = self.global_vars.colaux
                            self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                            # ARPdecliv
                            # Grava qual trecho o píxel em questão pertence
                            self.global_vars.TREpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux2

        # Percorre novamente o caminho desde às cabeceiras, gravando distancias relativas de cada pixel dentro de cada trecho de uso do solo continuo
        # Percorrendo os elementos da bacia hidrográfica
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Os cálculos são executados apenas na região da bacia hidrográfica
                if self.global_vars.bacia[lin][col] == 1:
                    # ARPlidar
                    if self.global_vars.numcabe[lin][col] > 0:
                        self.global_vars.numcabeaux = int(self.global_vars.numcabe[lin][col])
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.linaux2 = lin
                        self.global_vars.colaux2 = col
                        self.global_vars.linaux3 = lin
                        self.global_vars.colaux3 = col
                        self.global_vars.numtreaux = 0
                        self.global_vars.caminho = 0
                        self.global_vars.usaux = self.global_vars.usosolo[lin][col]
                        self.global_vars.usaux2 = self.global_vars.usaux

                        # Grava a distância do píxel relativo ao trecho
                        self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.DIST[lin][col] - self.global_vars.DISTult[self.global_vars.numcabeaux][1]

                        # ARPdecliv: calcula a declividade do píxel relativo ao último píxel do trecho
                        c1 = (self.global_vars.MDE[self.global_vars.linaux2][self.global_vars.colaux2] - self.global_vars.cotafim[self.global_vars.numcabeaux][1])
                        d1 = self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2]*1000.0 
                        self.global_vars.DECLIVpix[[self.global_vars.linaux2][self.global_vars.colaux2]] = c1 / d1

                        # Grava qual cabeceira o píxel em questão faz parte
                        self.global_vars.CABEpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numcabeaux

                        while self.global_vars.caminho == 0:
                            self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                            self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                            self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]
                            
                            if condicao1 or condicao2:
                                # Mudou o tipo de uso do solo ou alcançou a rede de drenagem, 
                                # então terminou um trecho no píxel anterior
                                self.global_vars.numtreaux += 1
                                self.global_vars.numtre[self.global_vars.numtreaux] = self.global_vars.numtreaux
                                
                                # Grava a distância do píxel relativo ao trecho
                                self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux] = self.global_vars.DIST[self.global_vars.linaux][self.global_vars.colaux] - self.global_vars.DISTult[self.global_vars.numcabeaux][self.global_vars.numcabeaux + 1]

                                self.global_vars.usotre[self.global_vars.numcabeaux][self.global_vars.numcabeaux] = self.global_vars.usaux

                                # ARPlidar: adiciona a bacia hidrográfica como uma condição
                                if self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] ==1 or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux] == 0:
                                    self.global_vars.caminho = 1
                                else:
                                    # Vai continuar o caminho, porém em um novo trecho
                                    self.global_vars.linaux3 = self.global_vars.linaux
                                    self.global_vars.colaux3 = self.global_vars.colaux
                                    self.global_vars.linaux2 = self.global_vars.linaux
                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                                    # Grava qual cabeceira o píxel em questão faz parte
                                    self.global_vars.CABEpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numcabeaux

                                    # Calcula a declividade do píxel relativo ao último píxel do trecho
                                    e1 = self.global_vars.MDE[self.global_vars.linaux2][self.global_vars.colaux2] - self.global_vars.cotafim[self.global_vars.numcabeaux][self.global_vars.numcabeaux + 1] 
                                    f1 = self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2]*1000.0
                                    self.global_vars.DECLIVpix[self.global_vars.linaux2][self.global_vars.colaux2] = e1 / f1

                            else:
                                # Vai continuar caminhando, e grava os valores dos pares (nlin,ncol) do último píxel que passou           
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux
                                self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                                # Grava qual cabeceira o píxel em questão pertence
                                self.global_vars.CABEpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numcabeaux

                                # Grava a DIST do píxel relativo ao trecho
                                self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.DIST[self.global_vars.linaux2][self.global_vars.colaux2] \
                                                                                                               - self.global_vars.DISTult[self.global_vars.numcabeaux][self.global_vars.numtreaux + 1]

                                # ARPdecliv: Calcula a declividade o píxel relativo ao último píxel do trecho  
                                g1 = self.global_vars.MDE[self.global_vars.linaux2][self.global_vars.colaux2] - self.global_vars.cotafim[self.global_vars.numcabeaux][self.global_vars.numtreaux + 1]
                                h1 = self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2]*1000.0
                                self.global_vars.DECLIVpix[self.global_vars.linaux2][self.global_vars.colaux2] =  g1/h1
        
        # Redimenciona variáveis necessárias
        Somaaux = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.Somaaux = Somaaux
        Somaaux = None
        SomaauxPond = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.SomaauxPond = SomaauxPond
        SomaauxPond = None
        SomaauxDist = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.SomaauxDist = SomaauxDist
        SomaauxDist = None
        contaaux = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.contaaux = contaaux
        contaaux = None

        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Os cálculo são realizados apenas na região da baica hidrográficia 
                if self.global_vars.bacia[lin][col] == 1:
                    # ARPlidar
                    if self.global_vars.numcabe[lin][col] > 0:
                        self.global_vars.numcabeaux = self.global_vars.numcabe[lin][col]
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.linaux2 = lin
                        self.global_vars.colaux2 = col
                        self.global_vars.linaux3 = lin
                        self.global_vars.colaux3 = col
                        self.global_vars.numtreaux = 0
                        self.global_vars.caminho = 0
                        self.global_vars.usaux = self.global_vars.usosolo[lin][col]
                        self.global_vars.usaux2 = self.global_vars.usaux

                        # ARPdecliv
                        self.global_vars.numtreaux2 = 1

                        # Para o cálculo da média aritmética
                        self.global_vars.Somaaux[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DECLIVpix[lin][col]
                        self.global_vars.contaaux[self.global_vars.numcabeaux][self.global_vars.numtreaux2] = self.global_vars.Somaaux[self.global_vars.numcabeaux][self.global_vars.numtreaux2] + 1

                        # Para o cálculo da média ponderada
                        self.global_vars.Somaauxpond[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DECLIVpix[lin][col] * self.global_vars.DISTtre[lin][col]
                        self.global_vars.SomaauxDist[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DISTtre[lin][col]

                        while self.global_vars.caminho == 0:
                            self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                            self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                            self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]
                            

                            if condicao1 or condicao2:
                                # Mudou o tipo de uso do solo ou alcançou a rede de drenagem, 
                                # então terminou um trecho no píxel anterior
                                self.global_vars.numtreaux += 1
                                 # ARPlidar: adiciona a bacia hidrográfica como uma condição
                                if self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] == 1 or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux] == 0:
                                    self.global_vars.caminho = 1
                                else:
                                    # Vai continuar o caminho, porém em um novo trecho
                                    self.global_vars.linaux3 = self.global_vars.linaux
                                    self.global_vars.colaux3 = self.global_vars.colaux
                                    self.global_vars.linaux2 = self.global_vars.linaux
                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                                    # ARPdecliv: grava qual trecho o píxel em questão pertence
                                    self.global_vars.numtreaux2 += 1

                                    # ARPdecliv: para a média aritmética
                                    self.global_vars.Somaaux[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DECLIVpix[self.global_vars.linaux][self.global_vars.colaux]
                                    self.global_vars.contaaux[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += 1

                                    # ARPdecliv: para a média ponderada
                                    self.global_vars.Somaauxpond[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DECLIVpix[self.global_vars.linaux][self.global_vars.colaux] * self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux]
                                    self.global_vars.SomaauxDist[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux]
                            
                            else:
                                # Vai continuar caminhando, e grava os valores dos pares (nlin,ncol) do último píxel que passou        
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux
                                self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]


                                # ARPdecliv: para a média aritmética
                                self.global_vars.Somaaux[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DECLIVpix[self.global_vars.linaux][self.global_vars.colaux]
                                self.global_vars.contaaux[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += 1

                                # ARPdecliv: para a média ponderada
                                self.global_vars.Somaauxpond[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DECLIVpix[self.global_vars.linaux][self.global_vars.colaux] * self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux]
                                self.global_vars.SomaauxDist[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux]
                                             
    def tempo_canal(self):
        '''
        Esta função é responsável por determinar o tempo de viagem/concentração da água da foz até o exutório da bacia hidrográfica
        '''
        # Declara e redemenciona variáveis
        condicao = None
        condicao2 = None
        TempoRio = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        self.global_vars.TempoRio = TempoRio
        TempoRio = None

        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # O cáclulos são executados apenas na região da bacia
                if self.global_vars.bacia[lin][col] == 1:
                    # Os cálculos acontecerão na rede de drenagem da bacia hidrográfica
                    if  self.global_vars.dren[lin][col] == 1:
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.linaux1 = lin
                        self.global_vars.colaux1 = col
                        self.global_vars.linaux2 = lin
                        self.global_vars.colaux2 = col
                        self.global_vars.caminho = 0
                        self.global_vars.Tempoauxac = 0

                        # Guarda as características do tipo de trecho que o píxel em questão faz parte
                        self.classerio_aux = self.global_vars.classerio[lin][col]

                        while self.global_vars.caminho == 0:
                            condicao = self.global_vars.linaux < 1 or self.global_vars.linaux > self.rdc_vars.nlin or self.global_vars.colaux < 1 or self.global_vars.colaux > self.rdc_vars.ncol    
                            
                            if condicao:
                                self.global_vars.caminho = 1

                                # Contabilizando o último trecho
                                self.global_vars.Lfozaux1 = self.global_vars.Lfoz[self.global_vars.linaux1][self.global_vars.colaux1]
                                self.global_vars.Lfozaux2 = self.global_vars.Lfoz[self.global_vars.linaux2][self.global_vars.colaux2]
                                # Determina a diferença entre o píxel do Lfoz inicial e o do final
                                self.global_vars.Laux = self.global_vars.Lfozaux1 - self.global_vars.Lfozaux2
                                
                                # A declividade(Saux), o coeficiente de Manning(naux) e o raio hidráulico(Rhaux) são aqueles do tipo de rio (rede de drenagem)
                                self.global_vars.Saux = self.global_vars.Sclasse[self.classerio_aux]
                                self.global_vars.naux = self.global_vars.Mannclasse[self.classerio_aux]
                                self.global_vars.Rhaux = self.global_vars.Rhclasse[self.classerio_aux]

                                # Determinando a velocidade do percurso
                                condicao1 = self.global_vars.linaux2 == self.global_vars.linaux and self.global_vars.colaux2 == self.global_vars.colaux1
                                if condicao1:
                                    # Significa que não há mudança de pixel, ou seja, o pixel a montante é igual ao de jusante
                                    self.global_vars.Velaux = 0
                                    self.global_vars.Tempoaux = 0
                                else:
                                    # Determina a velocidade por percurso
                                    self.global_vars.Velaux = self.global_vars.Rhaux ** (2.0/3.0)*self.global_vars.Saux**(1.0/2.0)/self.global_vars.naux
                                    
                                    # Calculando o tempo de viagem/concentração do percuso em min
                                    # em que: Laux em metros e Velaux em m/s; resultado em min
                                    self.global_vars.Tempoaux = self.global_vars.Laux / self.global_vars.Velaux / 60.0
                                
                                # O tempo é acocumulado desde o primeiro percurso
                                self.global_vars.Tempoauxac += self.global_vars.Tempoaux
                            
                                # Após o fim do traçado desde o inicío do píxel, o tempo será armazenado e o acumulador zerado
                                self.global_vars.TempoRio[lin][col] = self.global_vars.Tempoauxac
                                self.global_vars.Tempoauxac = 0
                        
                            else:
                                condicao2 = self.global_vars.classerio[self.global_vars.linaux][self.global_vars.colaux] != self.classerio_aux
                                # Checando se o caminho ainda está no trecho de mesma classe
                                if condicao2:
                                    self.global_vars.Lfozaux1 = self.global_vars.Lfoz[self.global_vars.linaux1][self.global_vars.colaux1]
                                    self.global_vars.Lfozaux2 = self.global_vars.Lfoz[self.global_vars.linaux2][self.global_vars.colaux2]

                                    # Determina a diferença entre o píxel do Lfoz inicial e o do final
                                    self.global_vars.Laux = self.global_vars.Lfozaux1 - self.global_vars.Lfozaux2
                                    
                                    # A declividade(Saux), o coeficiente de Manning(naux) e o raio hidráulico(Rhaux) são aqueles do tipo de rio (rede de drenagem)
                                    self.global_vars.Saux = self.global_vars.Sclasse[self.classerio_aux]
                                    self.global_vars.naux = self.global_vars.Mannclasse[self.classerio_aux]
                                    self.global_vars.Rhaux = self.global_vars.Rhclasse[self.classerio_aux]

                                    # Determinando a velocidade do percurso
                                    condicao1 = self.global_vars.linaux2 == self.global_vars.linaux and self.global_vars.colaux2 == self.global_vars.colaux1
                                    if condicao1:
                                        self.global_vars.Velaux = 0
                                        self.global_vars.Tempoaux = 0
                                    else:
                                        self.global_vars.Velaux = self.global_vars.Rhaux ** (2.0/3.0)*self.global_vars.Saux**(1.0/2.0)/self.global_vars.naux
                                        
                                        # Calculando o tempo de viagem/concentração do percuso em min 
                                        # em que: Laux em metros e Velaux em m/s; resultado em min
                                        self.global_vars.Tempoaux = self.global_vars.Laux / self.global_vars.Velaux / 60.0
                                    
                                    # O tempo é acocumulado desde o primeiro percurso
                                    self.global_vars.Tempoauxac += self.global_vars.Tempoaux

                                    # Atualizando o novo ponto de partida
                                    self.global_vars.linaux1 = self.global_vars.linaux
                                    self.global_vars.colaux1 = self.global_vars.colaux
                                    self.classerio_aux = self.global_vars.classerio[self.global_vars.linaux1][self.global_vars.colaux1]
                                
                                # Armazenando o píxel contabilizado
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux  

                                # Deteminando o próximo píxel do caminho
                                self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                                self.global_vars.caminho = 0 
                                self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                                self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]
    def tempo_sup(self):
        """
        Esta função função determina o tempo de concentração/escoamento para os píxels da superfície da rede de drenagem (aqueles que não são canais)
        """
        # Redimenciona as variáveis necessárias
        lincabe = np.zeros(self.global_vars.numcabeaux)
        self.global_vars.lincabe = lincabe
        lincabe = None
        colcabe = np.zeros(self.global_vars.numcabeaux)
        self.global_vars.colcabe = colcabe
        colcabe = None
        TS = np.zeros((self.global_vars.numcabeaux, self.global_vars.Ntre))
        self.global_vars.TS = TS
        TS = None
        TScabe = np.zeros(self.global_vars.numcabeaux)
        self.global_vars.TScabe = TScabe
        TScabe = None
        TScabe2d = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.TScabe2d = TScabe2d
        TScabe2d = None
        TSnaocabe2d = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.TSnaocabe2d = TSnaocabe2d
        TSnaocabe2d = None
        TSpixacum = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.TSpixacum = TSpixacum
        TSpixacum = None

        for lin in range(self.rdc_vars.nlin):
            for col in range(self.global_vars):
                if self.global_vars.numcabe[lin][col] > 0:
                    self.global_vars.numcabeaux = int(self.global_vars.numcabe[lin][col])
                    self.global_vars.lincabe[self.global_vars.numcabeaux] = lin
                    self.global_vars.colcabe[self.global_vars.numcabeaux] = col


        for item in range(self.global_vars.Ncabec):
            self.global_vars.numtreaux = self.global_vars.numtre[item]
            for t in range(self.global_vars.numtreaux):
                self.global_vars.usaux = self.global_vars.numtre[self.global_vars.numcabeaux][t]
                self.global_vars.Ltreaux = self.global_vars.Ltre[self.global_vars.numcabeaux][t]
                self.global_vars.Streaux = self.global_vars.Stre[self.global_vars.numcabeaux][t] 

                if self.global_vars.Streaux > 0:
                    # Determinando o TS: tempo de concentração
                    self.global_vars.TS[self.global_vars.numcabeaux][t] = 5.474 * ((self.global_vars.Mann[self.global_vars.usaux]*self.global_vars.Ltreaux)**0.8)/((self.global_vars.P24**0.5)*((self.global_vars.Streaux/1000.0)**0.4))
                else:
                    self.global_vars.TS[self.global_vars.numcabeaux][t] = 0
                
                self.global_vars.TScabe[self.global_vars.numcabeaux] += self.global_vars.TS[self.global_vars.numcabeaux][t]
            
            lin1 = self.global_vars.lincabe[self.global_vars.numcabeaux]
            col1 = self.global_vars.colcabe[self.global_vars.numcabeaux]
            self.global_vars.TScabe2d[lin1][col1] = self.global_vars.TScabe[self.global_vars.numcabeaux]
        
        for lin in range(self.rdc_vars.nlin):
            for col in range(self.rdc_vars.ncol):
                # As ações são baseadas na região da bacia hidrográfica
                if self.global_vars.bacia[lin][col] == 1:
                    self.global_vars.numcabeaux = int(self.global_vars.CABEpix[lin][col])
                    self.global_vars.Taux = 0

                    # Verificando se o píxel é válido; executando cabeceiras
                    if self.global_vars.numcabeaux > 0 and self.global_vars.numcabe[lin][col] == 0:
                        
                        self.global_vars.t = self.global_vars.refcabtre[lin][col]
                        self.global_vars.Ltreaux = self.global_vars.Ltre[self.global_vars.numcabeaux][self.global_vars.t]
                        self.global_vars.Ttreaux = self.global_vars.TS[self.global_vars.numcabeaux][self.global_vars.t]
                        self.global_vars.DISTtreaux = self.global_vars.DISTtre[lin][col]
                        self.global_vars.Taux = self.global_vars.DISTtreaux * self.global_vars.Ttreaux / self.global_vars.Ltreaux

                        # ARPdecliv
                        if self.global_vars.subtipodecliv == 'b':
                            self.global_vars.Streaux = self.global_vars.Stre[self.global_vars.numcabeaux][self.global_vars.t]
                            self.global_vars.usaux = self.global_vars.usotre[self.global_vars.numcabeaux][self.global_vars.t]
                            
                            if self.global_vars.Streaux > 0:
                                self.global_vars.Taux = 5.474 * ((self.global_vars.Mann[self.global_vars.usaux] * self.global_vars.DISTtreaux)**0.8) / ((self.global_vars.P24**0.5)*((self.global_vars.Streaux / 1000.0)**0.4))
                            else:
                                self.global_vars.Taux = 0

                        self.global_vars.numtreaux = self.global_vars.numtre[self.global_vars.numcabeaux]

                        if self.global_vars.t < self.global_vars.numtreaux:
                            tt = self.global_vars.t + 1
                            for tt in range(self.global_vars.numtreaux):
                                self.global_vars.Taux += self.global_vars.TS[self.global_vars.numcabeaux][tt]
                        
                        self.global_vars.TSnaocabe2d[lin][col] = self.global_vars.Taux

        self.global_vars.TStodos2d = self.global_vars.TSnaocabe2d + self.global_vars.TScabe2d

        if self.global_vars.tipo_decliv == 4:

            for col in range(self.rdc_vars.ncol):
                for lin in range(self.rdc_vars.nlin):
                    # Exclindo a região fora da bacia
                    self.global_vars.linaux = lin
                    self.global_vars.colaux = col
                    self.global_vars.caminho = 0 
                    self.global_vars.tempocam = 0.0
                    
                    # Para píxels que representam a rede de drenagem
                    if self.global_vars.dren[lin][col]== 1:
                        self.global_vars.caminho = 1
                    else:
                        while self.global_vars.caminho == 0:
                            condicao = self.global_vars.linaux <= 1 or self.global_vars.linaux >=self.rdc_vars.nlin or self.global_vars.colaux <= 1 or self.global_vars.colaux >=self.rdc_vars.nlin \
                                                                    or self.global_vars.bacia[self.global_vars.colaux][self.global_vars.colaux]==0
                            if condicao:
                                self.global_vars.caminho = 1
                            else:
                                if self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux]:
                                    # Alcançou a rede de drenagem: encerra a busca
                                    self.global_vars.caminho = 1
                                    self.global_vars.TSpixacum[lin][col] = self.global_vars.tempocam
                                else:
                                    self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                                    self.global_vars.caminho = 0

                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.linaux2 = self.global_vars.linaux

                                    # Calculando a distância incremental percorrida
                                    self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                                    self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]

                                    # Atualizando o tempo de escoamento desde o píxel inicial
                                    self.global_vars.tempocam += self.global_vars.TSpix[self.global_vars.linaux2][self.global_vars.colaux2]

    def tempo_total(self):
        '''
        Esta função determina o tempo total de escoamento/concentração da bacia hidrográfica
        '''
        # Redimenciona as variáveis necessárias
        TempoTot = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        self.global_vars.TempoTot = TempoTot
        TempoTot = None

        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Os procedimentos são realizados ao longo da bacia hidrográfica
                if self.global_vars.bacia[lin][col] == 1:
                    # Ainda, as verificaçãoes seão baseadas na rede de drenagem
                    if self.global_vars.dren[lin][col] == 1:
                        self.global_vars.TempoTot[lin][col] = self.global_vars.TempoRio[lin][col]
                    else:
                        # ARPlidar: otimização
                        self.global_vars.pixel_ref_dren = self.global_vars.pixeldren[lin][col]
                        if self.global_vars.pixel_ref_dren != 0:
                            self.global_vars.ll = self.global_vars.lincontadren[self.global_vars.pixel_ref_dren]
                            self.global_vars.cc = self.global_vars.colcontadren[self.global_vars.pixel_ref_dren]
                            self.global_vars.auxTempoCanal = self.global_vars.TempoRio[self.global_vars.ll][self.global_vars.cc]
                    # ARPtest
                    if self.global_vars.tipo_decliv == 1 or self.global_vars.tipo_decliv == 2 or self.global_vars.tipo_decliv == 3:
                        self.global_vars.TempoTot[lin][col] = self.global_vars.TStodos2d[lin][col] + self.global_vars.auxTempoCanal

                    if self.global_vars.tipo_decliv == 4:
                        self.global_vars.TempoTot[lin][col] = self.global_vars.TSpixacum[lin][col] + self.global_vars.auxTempoCanal

    def min_max(self):
        """
        Esta função determinar os limites das variáveis varMax e varMin 
        """
        self.rdc_vars.Varmax = -1.0e7
        self.rdc_vars.Varmin = 1.0e7

        if self.rdc_vars.tipoMM == 2:
            for col in range(self.rdc_vars.ncol3):
                for lin in range(self.rdc_vars.nlin3):
                    if self.rdc_vars.VarMM2[lin][col] > self.rdc_vars.Varmax:
                        self.rdc_vars.Varmax = self.rdc_vars.VarMM2[lin][col]
                    
                    elif self.rdc_vars.VarMM2[lin][col] < self.rdc_vars.Varmin:
                        self.rdc_vars.Varmin = self.rdc_vars.VarMM2[lin][col]

            for col in range(self.rdc_vars.ncol3):
                for lin in range(self.rdc_vars.nlin3):
                    if self.rdc_vars.VarMM3[lin][col][self.rdc_vars.i3] > self.rdc_vars.Varmax:
                        self.rdc_vars.Varmax = self.rdc_vars.VarMM3[lin][col][self.rdc_vars.i3]
                        
                    elif self.rdc_vars.VarMM3[lin][col][self.rdc_vars.i3] < self.rdc_vars.Varmin:
                        self.rdc_vars.Varmin = self.rdc_vars.VarMM3[lin][col][self.rdc_vars.i3]
    
    def tamanho_numero(self, varaux, num):
        '''Esta função determina quais sãos os maiores valores do raster em questão'''
        negativo = None
        nzeros = None
        pp = None
        varaux2 = None 
        limsup = None
        
        if varaux < 0:
            negativo = 1
        else:
            negativo = 0
        
        varaux2 = np.abs(varaux)
        
        for pp in range(11):
            limsup = 10.0**pp
            if varaux2 < limsup:
                nzeros = pp
                break
        # Se o valor for inteiro
        if num == 1:
            if nzeros == 0:
                self.global_vars.tamnum = 1 + negativo
            else:
                self.global_vars.tamnum = nzeros + negativo
        # Se o valor for real
        else:
            if nzeros == 0:
                self.global_vars.tamnum = 8 + 1 + negativo
            else:
                self.global_vars.tamnum = 8 + nzeros + negativo     

        return self.global_vars.tamnum

    def aux_RDC(self, file_, textoaux, varaux, tamnum):
        """
        Esta função é responsável por formatar as informações dos arquivos de saida do programa
        """
        if tamnum == 1:
            file_.write(f'{textoaux:14s}{varaux:1d}\n')
            return file_
        elif tamnum == 2:
            file_.write(f'{textoaux:14s}{varaux:2d}\n')
            return file_
        elif tamnum == 3:
            file_.write(f'{textoaux:14s}{varaux:3d}\n')
            return file_
        elif tamnum == 4:
            file_.write(f'{textoaux:14s}{varaux:4d}\n')
            return file_
        elif tamnum == 5:
            file_.write(f'{textoaux:14s}{varaux:5d}\n')
            return file_
        elif tamnum == 6:
            file_.write(f'{textoaux:14s}{varaux:7d}\n')
            return file_
        elif tamnum == 8:
            file_.write(f'{textoaux:14s}{varaux:8d}\n')
            return file_
        elif tamnum == 9:
            file_.write(f'{textoaux:14s}{varaux:9.7f}\n')
            return file_
        elif tamnum == 10:
            file_.write(f'{textoaux:14s}{varaux:10.7f}\n')
            return file_
        elif tamnum == 11:
            file_.write(f'{textoaux:14s}{varaux:11.7f}\n')
            return file_
        elif tamnum == 12:
            file_.write(f'{textoaux:14s}{varaux:12.7f}\n')
            return file_
        elif tamnum == 13:
            file_.write(f'{textoaux:14s}{varaux:13.7f}\n')
            return file_
        elif tamnum == 14:
            file_.write(f'{textoaux:14s}{varaux:14.7f}\n')
            return file_
        elif tamnum == 15:
            file_.write(f'{textoaux:14s}{varaux:15.7f}\n')
            return file_
        elif tamnum == 16:
            file_.write(f'{textoaux:14s}{varaux:16.7f}\n')
            return file_
        elif tamnum == 17:
            file_.write(f'{textoaux:14s}{varaux:17.7f}\n')
            return file_
        elif tamnum == 18:
            file_.write(f'{textoaux:14s}{varaux:18.7f}\n')
            return file_
        elif tamnum == 19:
            file_.write(f'{textoaux:14s}{varaux:19.7f}\n')
            return file_

    def escreve_RDC(self, nome_RST):
        """
        Esta função constrói os arquivos de saída das diferentes funcionalidades do programa
        """
        # Identifica a posição da extensão no arquivo .rst
        pos_ext = nome_RST.find('.rst')

        # Atribui o nome do arquivo .rst ao novo arquivo .rdc
        nome_rdc = nome_RST[:pos_ext] + '.rdc'

        # Abrindo o arquivo 
        with open(nome_rdc, 'w', encoding = 'utf-8') as rdc_file:
            # Escreve linha com formato do arquivo
            rdc_file.write('file format : IDRISI Raster A.1\n')
            # Escreve linha com o título do arquivo
            rdc_file.write('File title  : \n')

            # Escreve linha com tipo de dado
            if self.rdc_vars.tipo_dado == 1:
                rdc_file.write('data type   : integer\n')
            elif self.rdc_vars.tipo_dado == 2:
                rdc_file.write('data type   : real\n')

            # Escreve a linha com o tipo de arquivo
            rdc_file.write('file type   : binary\n')

            # Escreve a linha com o número de colunas
            self.global_vars.varaux = self.rdc_vars.ncol3
            self.rdc_vars.num = 1
            textoaux = 'columns     : ' 
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux, self.global_vars.varaux, tamnum)

            # Escreve a linha com o número de linhas
            self.global_vars.varaux = self.rdc_vars.nlin3
            self.rdc_vars.num = 1 # num = 1 : integer
            textoaux = 'rows        : ' 
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux, self.global_vars.varaux, tamnum)

            # Escreve a linha com o sistema de referência
            rdc_file.write(f'ref. system : {self.rdc_vars.sistemaref}\n')

            # Escreve a linha com a unidade de referência
            if self.global_vars.metro == 1:
                rdc_file.write('ref. units  : m\n')
            else:
                rdc_file.write('ref. units  : deg\n')
            
            # Escreve linha com distância unitária de referência
            rdc_file.write(f'unit dist.  : {1.0:<9.7f}\n')

            # Escreve linha com coordenada xmin
            self.global_vars.varaux = self.rdc_vars.Xmax3
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'max. X      : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux,self.global_vars.varaux, tamnum)

            # Escreve linha com coordenada xmax
            self.global_vars.varaux = self.rdc_vars.Xmin3
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'min. X      : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux,self.global_vars.varaux, tamnum)

            # Escreve linha com coordenada ymin
            self.global_vars.varaux = self.rdc_vars.Ymin3
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'min. Y      : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux,self.global_vars.varaux, tamnum)

            # Escreve linha com coordenada ymax
            self.global_vars.varaux = self.rdc_vars.Ymax3
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'max. Y      : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux,self.global_vars.varaux, tamnum)

            # Escreve a linha com o valor do erro dos dados
            rdc_file.write("pos'n error : unknown\n")

            # Escreve linha com resolução
            self.global_vars.varaux = self.global_vars.dx
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'resolution  : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux,self.global_vars.varaux, tamnum)
            
            # Escreve a linha com o valor mínimo dos dados
            self.global_vars.varaux = self.rdc_vars.Varmin
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'min. value  : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux,self.global_vars.varaux, tamnum)

            # Escreve a linha com o valor máximo dos dados
            self.global_vars.varaux = self.rdc_vars.Varmax
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'max. value  : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux,self.global_vars.varaux, tamnum)

            # Escreve a linha com o valor mínimo de exebição
            self.global_vars.varaux = self.rdc_vars.Varmin
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'display min : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux,self.global_vars.varaux, tamnum) 

            #  Escreve a linha com o valor máximo para exibição 
            self.global_vars.varaux = self.rdc_vars.Varmax
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'display max : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux,self.global_vars.varaux, tamnum)

            # Escreve a linha com a unidade dos dados
            rdc_file.write('value units : unspecified\n')

            # Escreve a linha com o valor do erro dos dados
            rdc_file.write('value error : unknown\n')

            # Escreve linha com sinalizador
            rdc_file.write(f'flag value  : {0:1d}\n')
            
            # Escreve a linha com a definição do sinalizador
            rdc_file.write("flag def'n  : none\n")

            # Escreve a linha com o número de categorias da legenda
            rdc_file.write(f'legend cats : {0:1d}\n')

            # Escreve a linha sobre a criação da imagem
            rdc_file.write('lineage     : This file was created automatically by an ARP and JVD PYTHON program')
        
        return nome_rdc

    def escreve_num_pix_drenagem(self):
        '''Esta função gera o mapa de numeração dos píxels da rede de drenagem'''

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        file_path = self.dlg_flow_tt.le_1_pg4.text()
        self.fn_num_pix_dren = file_path + 'num_pixels_drenagem.rst'
        
        # Define os dados a serem escritos
        dados_num_pix_dren = np.array([[float(self.global_vars.pixeldren[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver RST do GDAL
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_num_pix_dren, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_num_pix_dren)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
       
        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 1
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = self.contadren
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymax3 = self.rdc_vars.ymax
        nomeRST = self.fn_num_pix_dren 
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)

    def escreve_conectividade(self):
        """
        Esta função é responsável por formular os arquivos de saída (tanto o raster (.rst), quanto sua documentação (.rdc))
        para os dados referentes ao mapa de conectividade das cabeceiras da bacia hidrográfica
        """

        # Escrevendo o resultado do mapa de conectividade dos pixels da superficie a rede de drenagem
        file_path = self.dlg_flow_tt.le_2_pg4.text()
        self.fn_n_conect_dren = file_path + r'\num_conexao_drenagem.rst'

        # Define os dados a serem escritos
        dados_n_conect_dren = np.array([[float(self.global_vars.pixeldren[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver RST do GDAL
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_n_conect_dren, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_n_conect_dren)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Aloca as variáveis para escrita da documentação do arquivo rdc para o comprimento da foz da bacia hidrográfica
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = self.global_vars.pixeldren
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymax3 = self.rdc_vars.ymax
        nomeRST = self.fn_n_conect_dren
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)
       
    def escreve_comprimento_acumulado(self):
        """
        Esta função é responsável por formular os arquivos de saída (tanto o raster (.rst), quanto sua documentação (.rdc))
        para os dados referentes aos comprimentos da rede de drenagem da bacia hidrográfica
        """

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        file_path = self.dlg_flow_tt.le_1_pg4.text()
        self.fn_comp_acum = file_path  + r'\ComprimAcu.rst'

        # Define os dados a serem escritos
        dados_comp_acum = np.array([[float(self.global_vars.Lac[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)]) #lac n existe
        tipo_dados = gdalconst.GDT_Float32

        # Os arquivos terão formato rst
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_comp_acum, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_comp_acum)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = self.global_vars.Lac
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymax3 = self.rdc_vars.ymax
        nomeRST = self.fn_comp_acum
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)

        # Se for selecionado o check box
        if self.dlg_flow_tt.ch_4_pg4.isChecked:
            # Escrevendo o resultado do comprimento da rede de drenagem
            file_path = self.dlg_flow_tt.le_3_pg4.text()
            self.fn_comp_foz = file_path + r'\ComprimFoz.rst'
                
            # Define os dados a serem escritos
            dados_comp_foz = np.array([[float(self.global_vars.Lfoz[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
            tipo_dados = gdalconst.GDT_Float32

            # Os arquivos terão formato rst
            driver = gdal.GetDriverByName('RST')

            # Cria arquivo final
            dataset = driver.Create(self.fn_comp_foz, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)

            # Escreve os dados na banda do arquivo
            banda = dataset.GetRasterBand(1)
            banda.WriteArray(dados_comp_foz)

            # Fechando o arquivo
            dataset = None
            banda = None
            driver = None
            tipo_dados = None

            # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da foz da bacia hidrográfica
            self.global_vars.VarMM2 = self.global_vars.Lfoz
            nomeRST = self.fn_comp_foz
            self.escreve_RDC(nomeRST)

    def escreve_declivi_pixel(self):
        '''Esta função gera o mapa de numeração dos pixels da rede de drenagem'''

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        file_path = self.dlg_flow_tt.le_5_pg4.text()
        self.fn_decli_pix = file_path + r'\decliv_pixel.rst'

        # Define os dados a serem escritos
        dados_decli_pix = np.array([[float(self.global_vars.decliv_pixel[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver RST do GDAL
        driver = gdal.GetDriverByName('RST')
        # Cria arquivo final
        dataset = driver.Create(self.fn_decli_pix, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_decli_pix)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = self.global_vars.decliv_pixel
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymax3 = self.rdc_vars.ymax
        nomeRST = self.fn_decli_pix
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)

    def escreve_decliv_pixel_jus(self):
        '''Esta função gera o mapa de numeração dos pixels jusantes da rede de drenagem'''

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        file_path = self.dlg_flow_tt.le_6_pg4.text()
        self.fn_decli_pix_jus = file_path + r'\decliv_pixel_jus.rst'
        
        # Define os dados a serem escritos
        dados_decli_pix_jus = np.array([[float(self.global_vars.decliv_pixel_jus[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver RST do GDAL
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_decli_pix_jus, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_decli_pix_jus)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = self.global_vars.decliv_pixel_jus
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymax3 = self.rdc_vars.ymax
        nomeRST = self.fn_decli_pix_jus
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)
    
    def escreve_tempo_total(self):
        '''Esta função gera o mapa de conectividade dos píxels de superfície da rede de drenagem'''

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        file_path = self.dlg_flow_tt.le_7_pg4.text()
        self.fn_temp_total = file_path + r'\TempoTotal.rst'
        
        # Define os dados a serem escritos
        dados_temp_total = np.array([[float(self.global_vars.TempoTot[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)]) #tempo total não exist
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver RST do GDAL
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_temp_total, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_temp_total)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None   

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = self.global_vars.TempoTot
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymax3 = self.rdc_vars.ymax
        nomeRST = self.fn_temp_total
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)

    def save_buttons(self, line_edit):
        '''Esta função configura os botões da salvar (criar arquivo)'''
        # Seleciona o arquivo enviado pelo usuário
        while True:
            # Obtendo o caminho do arquivo a ser salvo usando um diálogo de arquivo
            file_name, _ = QFileDialog.getSaveFileName(None, "Save the file",'',"Raster Files (*.tif *.rst)")
            if file_name:
                line_edit.setText(file_name)
                break
            else:
                # O usuário não solucionou um arquivo (um caminho para salvar o arquivo de saída)
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    break


    def save_to_file(self, function, page):
        '''Esta função gera o arquivo com as informações enviadas por meio do usuário por página
        Function: Indica qual função a página pertence
                function == 1: Flow travel time;
                function == 2: Excess rainfall;
                function == 3: Flow routing
        Page: variável que identifica a página do arquivo que será escrito
                page == 1: Configurations;
                page == 2: Input Data;
                page == 3: Data Validation;
                page == 4: Run
        '''
        # Seleciona o arquivo enviado pelo usuário
        while True:
            if function == 1:
                if page == 1:
                    # Obtendo o caminho do arquivo a ser salvo usando um diálogo de arquivo
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "ftt_configuration_page", "Text Files (*.txt)")
                    # Verifica se o usuário selecionou um arquivo
                    if file_name:
                        # Armazenará as informações da primeira página
                        with open(file_name, 'w', encoding ='utf-8') as arquivo_txt:
                            arquivo_txt.write('Flow Travel Time - Configuration\n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Minimum slope surface travel time determination (m/km):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_1_pg1.text()}\n')
                            arquivo_txt.write('Maximum slope for surface travel time determination (m/km):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_2_pg1.text()}\n')
                            arquivo_txt.write('Orthogonal step for distance computation (dx):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_3_pg1.text()}\n')
                            arquivo_txt.write('Diagonal step for distance computation (dx):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_4_pg1.text()}\n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Flow direction code: \n')
                            arquivo_txt.write(f'A = {self.dlg_flow_tt.le_5_pg1.text()}\n')
                            arquivo_txt.write(f'B = {self.dlg_flow_tt.le_6_pg1.text()}\n')
                            arquivo_txt.write(f'C = {self.dlg_flow_tt.le_7_pg1.text()}\n')
                            arquivo_txt.write(f'D = {self.dlg_flow_tt.le_8_pg1.text()}\n')
                            arquivo_txt.write(f'E = {self.dlg_flow_tt.le_9_pg1.text()}\n')
                            arquivo_txt.write(f'F = {self.dlg_flow_tt.le_10_pg1.text()}\n')
                            arquivo_txt.write(f'G = {self.dlg_flow_tt.le_11_pg1.text()}\n')
                            arquivo_txt.write(f'H = {self.dlg_flow_tt.le_12_pg1.text()}\n')
                            arquivo_txt.write('lineage: This file was created automatically by an ARP and JVD QGIS plugin')
                    else:
                        # O usuário não solucionou um arquivo (um caminho para salvar o arquivo de saída)
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo
                    break

                elif page == 2:
                    # Salva as informações fornecidas na página de input
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "ftt_input_data_page", "Text Files (*.txt)")        
                    if file_name:
                            # Atribuindo o nome do arquivo(fn : file name) para escrita dos resultados da página 1
                            with open(file_name, 'w', encoding ='utf-8') as arquivo_txt:
                                arquivo_txt.write('Flow Travel Time - Input Data: \n')
                                arquivo_txt.write('\n')
                                arquivo_txt.write('Watershed delineation:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_1_pg2.text()}\n')
                                arquivo_txt.write('\nDigital elevation model:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_2_pg2.text()}\n')
                                arquivo_txt.write('\nFlow direction (RDC and RST):\n')
                                linhas_text_edit = self.dlg_flow_tt.te_1_pg2.toPlainText()
                                linhas = linhas_text_edit.split('\n')
                                arquivo_txt.write(f'=> {linhas[0]}\n=> {linhas[1]}\n')
                                arquivo_txt.write('\nRiver drainage newtwork (RDN):\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_3_pg2.text()}\n')
                                arquivo_txt.write('\nRDN segmentation into classes:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_4_pg2.text()}\n')
                                arquivo_txt.write('\nCharacteristics of RDN classes:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_7_pg2.text()}\n')
                                arquivo_txt.write('\nLand use or land corver (LULC) map:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_5_pg2.text()}\n')
                                arquivo_txt.write('\nManning roughness coeficient for each LULC:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_8_pg2.text()}\n')
                                arquivo_txt.write('\nRainfall depth for 24-h duration (mm):\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_6_pg2.text()}\n')
                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

                # elif page == 3:
                    # Salva informações página de data validation

                elif page == 4:
                    # Salva as informações fornecidas na página de run
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "ftt_run_page", "Text Files (*.txt)")
                    if file_name:
                            # Atribuindo o nome do arquivo(fn : file name) para escrita dos resultados da página 1
                            with open(file_name, 'w', encoding ='utf-8') as arquivo_txt:
                                arquivo_txt.write('Flow Travel Time - Run page: \n')
                                arquivo_txt.write('\n')
                                arquivo_txt.write('Numering pixels part of the river drainage network:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_1_pg4.text()}\n')
                                arquivo_txt.write('Areas draining directly to each pixel of the RDN:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_2_pg4.text()}\n')
                                arquivo_txt.write('Upstream flowpath length:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_3_pg4.text()}')
                                arquivo_txt.write('Downstream flowpath slope (m/m):\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_4_pg4.text()}\n')
                                arquivo_txt.write('Downstream flowpath length:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_5_pg4.text()}\n')
                                arquivo_txt.write('Slope relative to downstream pixel:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_6_pg4.text()}\n')
                                arquivo_txt.write('Flow travel time (min):\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_7_pg4.text()}\n')

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

            elif function == 2:
                    if page == 1:
                        # Salva as informações fornecidas na página de configuration: excess rainfall
                        file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "exc_rain_configuration_page", "Text Files (*.txt)")
                        if file_name:
                            with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                                arquivo_txt.write('Excess Rainfall - Configuration page\n')
                                arquivo_txt.write('\n')
                                arquivo_txt.write('Initial abstraction parameter (λ):\n')
                                arquivo_txt.write(f'=> {self.dlg_exc_rain.le_1_pg1.text()}\n')
                                arquivo_txt.write('Time step(mim):\n')
                                arquivo_txt.write(f'=> {self.dlg_exc_rain.le_2_pg1.text()}\n')
                                arquivo_txt.write('Rainfall defination:\n')
                                arquivo_txt.write('    Areal averaged:')
                                arquivo_txt.write(f'    =>{self.dlg_exc_rain.rb_1_pg1.isChecked()}')
                                arquivo_txt.write('    Spatially distributed:')
                                arquivo_txt.write(f'    =>{self.dlg_exc_rain.rb_2_pg1.isChecked()}')
                    
                    elif page == 2:
                        # Salva as informações fornecidads na página de input data: excess rainfall
                        file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "exc_rain_input_data_page", "Text Files (*.txt)")
                        if file_name:
                            with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                                arquivo_txt.write('Excess Rainfall - Input data page: \n')
                                arquivo_txt.write('\n')
                                arquivo_txt.write('Watershed delineation:\n')
                                arquivo_txt.write(f'=> {self.dlg_exc_rain.le_1_pg2.text()}\n')
                                arquivo_txt.write('Map of curve-number:\n')
                                arquivo_txt.write(f'=> {self.dlg_exc_rain.le_2_pg2.text()}\n')
                                if self.dlg_exc_rain.rb_1_pg1.isChecked():
                                    arquivo_txt.write('Areal averaged rainfall:\n')
                                    arquivo_txt.write(f'=> {self.dlg_exc_rain.le_3_pg2.text()}\n')
                                else:
                                    arquivo_txt.write('List of files with the spatially distributed rainfall:\n')
                                    arquivo_txt.write(f'=> {self.dlg_exc_rain.le_4_pg2.text()}\n')

                    # elif page == 3:   

                    elif page == 4:
                        # Salva informações da página de run : excess rainfall
                        file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "exc_rain_run_page", "Text Files (*.txt)")
                        if file_name:
                            with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                                arquivo_txt.write('Excess Rainfall - Run page: \n')
                                arquivo_txt.write('\n')
                                arquivo_txt.write('Numbering of watershed pixels:\n')
                                arquivo_txt.write(f'=> {self.dlg_exc_rain.le_1_pg4.text()}\n')
                                arquivo_txt.write('Maximum potential retention (mm):\n')
                                arquivo_txt.write(f'=> {self.dlg_exc_rain.le_2_pg4.text()}\n')
                                arquivo_txt.write('Initial abstraction (mm):\n')
                                arquivo_txt.write(f'=> {self.dlg_exc_rain.le_3_pg4.text()}\n')
                                arquivo_txt.write('Total rainfall (mm):\n')
                                arquivo_txt.write(f'=> {self.dlg_exc_rain.le_4_pg4.text()}\n')
                                arquivo_txt.write('Total excess rainfall (mm):\n')
                                arquivo_txt.write(f'=> {self.dlg_exc_rain.le_5_pg4.text()}\n')
                                arquivo_txt.write('Excess hyetographs per pixel (mm):\n')
                                arquivo_txt.write(f'=> {self.dlg_exc_rain.le_6_pg4.text()}\n')                               
    def read_from_file(self, page):
        '''Esta função é responsável por obter as informações a partir dos arquivos enviados pelo usuário
        Page: variável que identifica a página do arquivo que será escrito
                page == 1: Configurations;
                page == 2: Input Data;
                page == 3: Data Validation;
                page == 4: Run
        '''
        # Seleciona o arquivo enviado pelo usuário
        while True:
            options = QFileDialog.Options()
            directory = self.dlg_flow_tt.le_13_pg1.text()
            file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory = directory, filter="Text Files (*.txt)", options = options)
            cont = 0
            if page == 1 and file_ != '':
                # Ler as informações da página 1: configuration
                with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                    # Armazena as informações do arquivo enviado em uma lista
                    values = []
                    for line in arquivo_txt:
                        # Buscará as flag adicionada "=>" ou "="
                        if "=>" in line or '=' in line:
                            # Os primeiros 5 objetos são baseados na primeira flag
                            if cont < 4:
                                value = line.replace('=>', '').strip()
                                values.append(value)
                            # As direções de fluxo são baseadas na segunda flag
                            elif cont >= 4:
                                value_ = line.split("=")[1].strip()
                                values.append(value_)
                            cont += 1
                # Adiciona as informações lidas nas suas respectivas lineEdits
                self.dlg_flow_tt.le_1_pg1.setText(str(values[0]))
                self.dlg_flow_tt.le_2_pg1.setText(str(values[1]))
                self.dlg_flow_tt.le_3_pg1.setText(str(values[2]))
                self.dlg_flow_tt.le_4_pg1.setText(str(values[3]))
                self.dlg_flow_tt.le_5_pg1.setText(str(values[4]))
                self.dlg_flow_tt.le_6_pg1.setText(str(values[5]))
                self.dlg_flow_tt.le_7_pg1.setText(str(values[6]))
                self.dlg_flow_tt.le_8_pg1.setText(str(values[7]))
                self.dlg_flow_tt.le_9_pg1.setText(str(values[8]))
                self.dlg_flow_tt.le_10_pg1.setText(str(values[9]))
                self.dlg_flow_tt.le_11_pg1.setText(str(values[10]))
                self.dlg_flow_tt.le_12_pg1.setText(str(values[11]))
                
                break

            elif page == 2 and file_ != '':
                # Ler o arquivo da página 2: input dat
                with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                    # Armazenará os valores das linhas
                    values = []
                    for line in arquivo_txt:
                        if '=>' in line:
                            # Substitui o identificador => por uma string fazia e retira os espaços da linha
                            value = line.replace('=>', '').strip()
                            values.append(value)
                
                # Adiciona as informações lidas à seus respectivos campos
                self.dlg_flow_tt.le_1_pg2.setText(str(values[0]))
                self.dlg_flow_tt.le_2_pg2.setText(str(values[1]))
                self.dlg_flow_tt.te_1_pg2.setPlainText(str(values[2]))
                self.dlg_flow_tt.te_1_pg2.append(str(values[3]))
                self.dlg_flow_tt.le_3_pg2.setText(str(values[4]))
                self.dlg_flow_tt.le_4_pg2.setText(str(values[5]))
                self.dlg_flow_tt.le_7_pg2.setText(str(values[6]))
                # Atribui os valores do arquivo enviado a tabela em questão
                self.read_tb_from_file_2(self.dlg_flow_tt.tbw_1_pg2,values[6], 1)
                self.dlg_flow_tt.le_5_pg2.setText(str(values[7]))
                self.dlg_flow_tt.le_8_pg2.setText(str(values[8]))
                # Atribui os valores do arquivo enviado a tabela em questão
                self.read_tb_from_file_2(self.dlg_flow_tt.tbw_2_pg2,values[8],2)
                self.dlg_flow_tt.le_6_pg2.setText(str(values[9]))
                
                break               

            elif page == 4 and file_ != '':
                # Ler arquivos página 4
                with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                    # Armazenará os valores das linhas
                    values = []
                    for line in arquivo_txt:
                        if '=>' in line:
                            # Substitui o identificador => por uma string fazia e retira os espaços da linha
                            value = line.replace('=>', '').strip()
                            values.append(value)

                # Adiciona as informações lidas à seus respectivos campos            
                self.dlg_flow_tt.le_1_pg3.setText(str(values[0]))
                self.dlg_flow_tt.le_2_pg3.setText(str(values[1]))
                self.dlg_flow_tt.le_3_pg3.setText(str(values[2]))
                self.dlg_flow_tt.le_4_pg3.setText(str(values[3]))
                self.dlg_flow_tt.le_5_pg3.setText(str(values[4]))
                self.dlg_flow_tt.le_6_pg3.setText(str(values[5]))
                self.dlg_flow_tt.le_7_pg3.setText(str(values[6]))
                break
            
            else:
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    break 

    def save_table_to_file(self, table):
        '''Esta função lê as informações adicionadas às tabelas e as armazena em um arquivo'''
        while True:
            if table == 1:
                # Solicita um local de salvamento para o usuário
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "RDN_classes", "Text or CSV Files (*.txt *.csv)")
                if file_name:
                    self.dlg_flow_tt.le_7_pg2.setText(file_name)
                    # seleciona as dimensões da tabela
                    nlin_tb1 = self.dlg_flow_tt.tbw_1_pg2.rowCount()
                    ncol_tb1 = self.dlg_flow_tt.tbw_1_pg2.columnCount()

                    # Escreve o arquivo de saída
                    with open(file_name, 'w', encoding='utf-8') as arquivo_txt_csv:
                        arquivo_txt_csv.write(f'Num_classes:{nlin_tb1}\nClass ID;Slope(m/m);Manning Coef;Hydraulic radius\n')
                        # Adicionando as informações das linhas e colunas ao arquivo de saída
                        for lin in range(nlin_tb1):
                            for col in range(ncol_tb1):
                                item = self.dlg_flow_tt.tbw_1_pg2.item(lin, col)
                                # Verifica se o item existe
                                if item is not None:  
                                    arquivo_txt_csv.write(f'{item.text()}')
                                arquivo_txt_csv.write(';')  
                            arquivo_txt_csv.write('\n')
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break 

            elif table ==2:
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "Manning_roughness_coef_for_each_LULC", "Text or CSV Files (*.txt *.csv)")
                if file_name:
                    self.dlg_flow_tt.le_8_pg2.setText(file_name)
                    # seleciona as dimensões da tabela
                    nlin_tb1 = self.dlg_flow_tt.tbw_2_pg2.rowCount()
                    ncol_tb1 = self.dlg_flow_tt.tbw_2_pg2.columnCount()

                    # Escreve o arquivo de saída
                    with open(file_name, 'w', encoding='utf-8') as arquivo_txt_csv:
                        arquivo_txt_csv.write('Class ID;Class Name;Manning Coef\n')
                        # Adicionando as informações das linhas e colunas ao arquivo de saída
                        for lin in range(nlin_tb1):
                            for col in range(ncol_tb1):
                                item = self.dlg_flow_tt.tbw_2_pg2.item(lin, col)
                                # Verifica se o item existe
                                if item is not None:  
                                    arquivo_txt_csv.write(f'{item.text()}')
                                    arquivo_txt_csv.write(';')  
                            arquivo_txt_csv.write('\n')
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break 

    def read_tb_from_file(self,table, lineEdit,table_ordem):
        '''Esta função adiciona os valores do arquivo enviado pelo usuário à respectiva tabela'''
        # Seleciona o arquivo enviado pelo usuário
        options = QFileDialog.Options()
        directory = self.dlg_flow_tt.le_13_pg1.text()
        # Atualiza a flag para leitura dos dados da tabela
        self.flag = 1
        self.flag_1 = 1

        while True:
            # Solicita o arquivo
            file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory=directory, filter="Text or CSV Files (*.txt *.csv)", options=options)
            
            if file_:
                # Configura a primeira tabela
                if table_ordem == 1:
                    lineEdit.setText(file_)
                    # Abre o arquivo e processa as linhas
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                        # Lê a linha e o cabeçalho
                        self.global_vars.nclasses = arquivo_txt_csv.readline().strip().split(':')[1]
                        self.global_vars.nclasses =int(self.global_vars.nclasses)
                        arquivo_txt_csv.readline()

                        # Define o número de linhas que a tabela receberá
                        num_row_total = self.global_vars.nclasses

                        # Inicializa as listas para armazenamento das informações
                        id_class_list = []
                        Sclasse_list = []
                        Mannclasse_list = []
                        Rhclasse_list = []

                        # Iterando sobre as linhas do arquivo
                        for line in arquivo_txt_csv:
                            # Divide a linha nos espaços em branco e converte para float
                            indice, Scla, Mann, Rh = map(float, line.split())
                            # Adiciona os valores às listas
                            id_class_list.append(indice)
                            Sclasse_list.append(Scla)
                            Mannclasse_list.append(Mann)
                            Rhclasse_list.append(Rh)
                    
                    # Atualiza as variáveis gerais
                    self.global_vars.j = np.array(id_class_list)
                    self.global_vars.Sclasse = np.array(Sclasse_list)
                    self.global_vars.Mannclasse = np.array(Mannclasse_list)
                    self.global_vars.Rhclasse = np.array(Rhclasse_list)
                    
                    # Atualiza no número de linhas da tabela (recebe o número de classes dos rios da bacia hidrográfica)
                    table.setRowCount(num_row_total)
                    
                    # Coleta as dimensões da tabela
                    n_row = table.rowCount()
                    n_column = table.columnCount()

                    # Itera sobre os elementos da tabela
                    for col in range(n_column):
                        for lin in range(n_row):
                            if col == 0:
                                # Adiciona a coluna do id
                                item = QTableWidgetItem(str(id_class_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 1:
                                # Adiciona a coluna da declividade
                                item = QTableWidgetItem(str(Sclasse_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 2:
                                # Adiciona a coluna do coef de Manning  
                                item = QTableWidgetItem(str(Mannclasse_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 3:
                                # Adiciona a coluna do raio hidráulico
                                item = QTableWidgetItem(str(Rhclasse_list[lin]))
                                table.setItem(lin, col, item)               
                    break

                # Configura a segunda tabela
                else:

                    # Criando variável extra, para armazenar os tipos de uso e coeficente de Manning
                    lineEdit.setText(file_)
                    uso_manning = []
                    coef_maning = []
                    class_name = []
                    class_name_val = []
                    uso_manning_val = []
                    coef_maning_val = []

                    # Abrindo o arquivo que contém o coeficiente de Manning para os diferentes usos do solo
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                        # Amazena a linha do cabeçalho
                        firt_line = arquivo_txt_csv.readline().strip()

                        # Lê as informações de uso do solo e coeficiente de Manning 
                        for line in arquivo_txt_csv:
                            # Coletando as informações de cada linha
                            info = line.strip().split()
                            # Armazenando os valores das linhas nas suas respectivas variáveis
                            uso_manning = int(info[0])
                            coef_maning = float(info[1])
                            class_name = str(info[2])


                            # Adicionando os valores nas variáveis destinadas
                            uso_manning_val = np.append(uso_manning_val, uso_manning)
                            coef_maning_val = np.append(coef_maning_val, coef_maning)
                            class_name_val.append(class_name)

                    # Adicionando cada valor às suas respectivas variáveis
                    self.global_vars.usaux = uso_manning_val
                    self.global_vars.Mann = coef_maning_val

                    # Atualiza o número de linhas da tabela
                    table.setRowCount(len(uso_manning_val))

                    # Coleta as dimensões da tabela
                    n_row = table.rowCount()
                    n_column = table.columnCount()

                    # Adiciona as informações à tabela
                    for col in range(n_column):
                        for lin in range(n_row):
                            if col == 0:
                                # Adiciona a coluna class Id
                                item = QTableWidgetItem(str(uso_manning_val[lin]))
                                table.setItem(lin, col, item)
                            elif col == 1:
                                # Adiciona a coluna class Name
                                item = QTableWidgetItem(str(class_name_val[lin]))
                                table.setItem(lin, col, item)
                            elif col == 2:
                                # Adiciona a coluna do coef de Manning  
                                item = QTableWidgetItem(str(coef_maning_val[lin]))
                                table.setItem(lin, col, item)
                    
                    break

            else:
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    break 
                
    def read_tb_from_file_2(self,table, line_edit,table_ordem):
        '''Esta função adiciona os valores do arquivo enviado pelo usuário ao clicar no botão READ FROM FILE da página 2.
            table == 1: a tabela de referência é a tabelea das caracteristicas da rede de drenagem
            table == 2 referencia a tabela das classes e coeficientes de manning. 
            '''
        # Atribui os valores do arquivo enviado à tabela das características
        if table_ordem == 1:
            file_ = line_edit
            # Abre o arquivo e processa as linhas
            with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                # Lê a linha e o cabeçalho
                arquivo_txt_csv.readline()
                arquivo_txt_csv.readline()

                # Inicializa as listas para armazenamento das informações
                id_class_list = []
                Sclasse_list = []
                Mannclasse_list = []
                Rhclasse_list = []

                # Iterando sobre as linhas do arquivo
                for line in arquivo_txt_csv:
                    # Divide a linha nos espaços em branco e converte para float
                    indice, Scla, Mann, Rh = map(float, line.split())
                    # Adiciona os valores às listas
                    id_class_list.append(indice)
                    Sclasse_list.append(Scla)
                    Mannclasse_list.append(Mann)
                    Rhclasse_list.append(Rh)
            
            # Atualiza no número de linhas da tabela (recebe o número de classes dos rios da bacia hidrográfica)
            table.setRowCount(len(id_class_list))
            
            # Coleta as dimensões da tabela
            n_row = table.rowCount()
            n_column = table.columnCount()
            # Itera sobre os elementos da tabela
            for col in range(n_column):
                for lin in range(n_row):
                    if col == 0:
                        # Adiciona a coluna do id
                        item = QTableWidgetItem(str(id_class_list[lin]))
                        table.setItem(lin, col, item)
                    elif col == 1:
                        # Adiciona a coluna da declividade
                        item = QTableWidgetItem(str(Sclasse_list[lin]))
                        table.setItem(lin, col, item)
                    elif col == 2:
                        # Adiciona a coluna do coef de Manning  
                        item = QTableWidgetItem(str(Mannclasse_list[lin]))
                        table.setItem(lin, col, item)
                    elif col == 3:
                        # Adiciona a coluna do raio hidráulico
                        item = QTableWidgetItem(str(Rhclasse_list[lin]))
                        table.setItem(lin, col, item)               
            
        # Adiciona os dados a tabela de classes
        elif table_ordem == 2:
            
            file_ = line_edit
            # Criando variável extra, para armazenar os tipos de uso e coeficente de Manning
            uso_manning = []
            coef_maning = []
            class_name = []
            class_name_val = []
            uso_manning_val = []
            coef_maning_val = []

            # Abrindo o arquivo que contém o coeficiente de Manning para os diferentes usos do solo
            with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                # Amazena a linha do cabeçalho
                firt_line = arquivo_txt_csv.readline().strip()
                # Lê as informações de uso do solo e coeficiente de Manning 
                for line in arquivo_txt_csv:
                    # Coletando as informações de cada linha
                    info = line.strip().split()
                    # Armazenando os valores das linhas nas suas respectivas variáveis
                    uso_manning = int(info[0])
                    coef_maning = float(info[1])
                    class_name = str(info[2])
                    # Adicionando os valores nas variáveis destinadas
                    uso_manning_val = np.append(uso_manning_val, uso_manning)
                    coef_maning_val = np.append(coef_maning_val, coef_maning)
                    class_name_val.append(class_name)

            # Atualiza o número de linhas da tabela
            table.setRowCount(len(uso_manning_val))
            # Coleta as dimensões da tabela
            n_row = table.rowCount()
            n_column = table.columnCount()
            # Adiciona as informações à tabela
            for col in range(n_column):
                for lin in range(n_row):
                    if col == 0:
                        # Adiciona a coluna class Id
                        item = QTableWidgetItem(str(uso_manning_val[lin]))
                        table.setItem(lin, col, item)
                    elif col == 1:
                        # Adiciona a coluna class Name
                        item = QTableWidgetItem(str(class_name_val[lin]))
                        table.setItem(lin, col, item)
                    elif col == 2:
                        # Adiciona a coluna do coef de Manning  
                        item = QTableWidgetItem(str(coef_maning_val[lin]))
                        table.setItem(lin, col, item)

    def add_new_row(self,table):
        '''Está função adiciona uma linha a uma tabela relecionada'''
        last_row = table.rowCount()
        table.insertRow(last_row)
    
    def delete_row(self,table):
        '''Esta função deleta uma linha de uma referida tabela'''
        selected_row = table.currentRow()
        if selected_row >= 0:
            table.removeRow(selected_row)
        else:
            QMessageBox.warning(None, "Warning", "You did not select any row.")
             
    def save(self):
        '''Esta função é usada para salvar as informações adiconadas'''
        self.save_result = True

    def close_gui(self):
        '''Está função é usada para torna nulo (limpar) as informações adicionadas nos diferentes objetos da janela flow travel time'''
        # Verifica se alguma lineEdit sobreu alteração: modifica a execução da função close
        line_edit_list = [
            self.dlg_flow_tt.le_1_pg1.text(),
            self.dlg_flow_tt.le_2_pg1.text(),
            self.dlg_flow_tt.le_5_pg1.text(),
            self.dlg_flow_tt.le_6_pg1.text(),
            self.dlg_flow_tt.le_7_pg1.text(),
            self.dlg_flow_tt.le_8_pg1.text(),
            self.dlg_flow_tt.le_9_pg1.text(),
            self.dlg_flow_tt.le_10_pg1.text(),
            self.dlg_flow_tt.le_11_pg1.text(),
            self.dlg_flow_tt.le_12_pg1.text(),
            self.dlg_flow_tt.le_13_pg1.text(),
            self.dlg_flow_tt.le_1_pg2.text(),
            self.dlg_flow_tt.le_2_pg2.text(),
            self.dlg_flow_tt.le_3_pg2.text(),
            self.dlg_flow_tt.le_4_pg2.text(),
            self.dlg_flow_tt.le_5_pg2.text(),
            self.dlg_flow_tt.le_6_pg2.text(),
            self.dlg_flow_tt.le_7_pg2.text(),
            self.dlg_flow_tt.le_8_pg2.text(),
            self.dlg_flow_tt.le_1_pg4.text(),
            self.dlg_flow_tt.le_2_pg4.text(),
            self.dlg_flow_tt.le_3_pg4.text(),
            self.dlg_flow_tt.le_4_pg4.text(),
            self.dlg_flow_tt.le_5_pg4.text(),
            self.dlg_flow_tt.le_6_pg4.text(),
            self.dlg_flow_tt.le_7_pg4.text()
        ]

        # Verifica se algum elemento da lista de line_edits foi modificado
        if any(item != '' for item in line_edit_list) and  self.dlg_flow_tt.isVisible():
            while True:

                result = "Wait! You did not save your changes. Are you sure you want to close?"
                reply = QMessageBox.warning(None, "Changes not saved", result, QMessageBox.Ok | QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    break

                else: 
                    # Limpando as informações armazenadas: line edit
                    self.dlg_flow_tt.le_1_pg1.clear()
                    self.dlg_flow_tt.le_2_pg1.clear()
                    self.dlg_flow_tt.le_3_pg1.clear()
                    self.dlg_flow_tt.le_4_pg1.clear()
                    self.dlg_flow_tt.le_5_pg1.clear()
                    self.dlg_flow_tt.le_6_pg1.clear()
                    self.dlg_flow_tt.le_7_pg1.clear()
                    self.dlg_flow_tt.le_8_pg1.clear()
                    self.dlg_flow_tt.le_9_pg1.clear()
                    self.dlg_flow_tt.le_10_pg1.clear()
                    self.dlg_flow_tt.le_11_pg1.clear()
                    self.dlg_flow_tt.le_12_pg1.clear()
                    self.dlg_flow_tt.le_13_pg1.clear()

                    self.dlg_flow_tt.le_1_pg2.clear()
                    self.dlg_flow_tt.le_2_pg2.clear()
                    self.dlg_flow_tt.te_1_pg2.clear()
                    self.dlg_flow_tt.le_3_pg2.clear()
                    self.dlg_flow_tt.le_4_pg2.clear()
                    self.dlg_flow_tt.le_5_pg2.clear()
                    self.dlg_flow_tt.le_6_pg2.clear()
                    self.dlg_flow_tt.le_7_pg2.clear()
                    self.dlg_flow_tt.le_8_pg2.clear()

                    self.dlg_flow_tt.le_1_pg4.clear()
                    self.dlg_flow_tt.le_2_pg4.clear()
                    self.dlg_flow_tt.le_3_pg4.clear()
                    self.dlg_flow_tt.le_4_pg4.clear()
                    self.dlg_flow_tt.le_5_pg4.clear()
                    self.dlg_flow_tt.le_6_pg4.clear()
                    self.dlg_flow_tt.le_7_pg4.clear()

                    # Limpando as informações armazenadas: tables widgets
                    nlin_tb1 = self.dlg_flow_tt.tbw_1_pg2.rowCount()
                    ncol_tb1 = self.dlg_flow_tt.tbw_1_pg2.columnCount()
                    nlin_tb2 = self.dlg_flow_tt.tbw_2_pg2.rowCount()
                    ncol_tb2 = self.dlg_flow_tt.tbw_2_pg2.columnCount()
                    # Primeira tabela
                    for lin in range(nlin_tb1):
                        for col in range(ncol_tb1):
                            item = self.dlg_flow_tt.tbw_1_pg2.item(lin, col)
                            if item is not None:
                                item.setText('')

                    # Segunda tabela
                    for lin in range(nlin_tb2):
                        for col in range(ncol_tb2):
                            item = self.dlg_flow_tt.tbw_2_pg2.item(lin, col)
                            if item is not None:
                                item.setText('')

                    self.dlg_flow_tt.close()

                # Atualiza as variáveis para a condição de salvamento
                self.save_result = False
                self.le_edited = False
                break

        # Se não houver moficações nos objetos do plugin, a janela será fechada normalmente
        else:
            self.dlg_flow_tt.close()

    def clear_table(self,table,lineEdit):
        '''Esta função limpa os valores armazenados na respectiva tabela'''
        # Limpando as informações armazenadas: tables widgets
        nlin_tb1 = table.rowCount()
        ncol_tb1 = table.columnCount()

        # Reinicia a respectiva tabela
        for lin in range(nlin_tb1):
            for col in range(ncol_tb1):
                item = table.item(lin, col)
                if item is not None:
                    item.setText('')
        # Limpa a lineEdit
        lineEdit.clear()

    def adiciona_layer(self, file_path):
        '''Esta função adiciona um arquivo enviado às layers do atual projeto do usuário no QGIS'''
        # Adiciona o arquivo raster ao projeto do QGIS
        file_name = os.path.basename(file_path)
        layer = QgsRasterLayer(file_path, 'gdal')
        layer.setName(file_name)
        QgsProject.instance().addMapLayer(layer)

        # Atualiza a tela do QGIS
        iface.layerTreeView().refreshLayerSymbology(layer.id())

    def logging_run_page(self):
        '''Está função ativa a página de log e configura a ordem de execução das funções para o cálculo do tempo de viagem'''
        # Ativiva a página de log e limpa as informações passadas no text_edit 
        mensagem_log = None
        self.dlg_flow_tt.tabWidget.setCurrentIndex(1)
        self.dlg_flow_tt.pg_log_ftt.setEnabled(True)
        self.dlg_flow_tt.te_logg.clear()

        # Configura a progress bar
        self.dlg_flow_tt.progressBar.setRange(0, 100)
        self.dlg_flow_tt.progressBar.setValue(0)

        # Adiciona avisa acerca do tempo de processamento
        self.dlg_flow_tt.te_logg.append(mensagem_log)
        reply = QMessageBox.information(None, "Information", "This will take a few minutes (maybe hours)...", QMessageBox.Ok | QMessageBox.Cancel)
        
        # Apenas inicia o prpocessamento se o usuário estiver de acordo com o tempo de processamento
        if reply == QMessageBox.Ok:

            # Configura as informações do textEdit da referida página
            font = QFont()
            font.setPointSize(11)
            version_info = {
                "QGIS Version": '3.34.0-Prizren',
                "Qt Version": '5.15.3',
                "Python Version": '3.9.5',
                "GDAL Version": '3.8.0'}
            
            datatime_started = datetime.now().isoformat()
            mensagem_log1 = "The plugin was developed with:\n"
            mensagem_log1 += f"QGIS Version: {version_info['QGIS Version']}\n"
            mensagem_log1 += f"Qt Version: {version_info['Qt Version']}\n"
            mensagem_log1 += f"Python Version: {version_info['Python Version']}\n"
            mensagem_log1 += f"GDAL Version: {version_info['GDAL Version']}\n"
            mensagem_log1 += "--------------------------------------------------------\n"
            mensagem_log1 += f"Algorithm started at: {datatime_started}\n"
            mensagem_log1 += "--------------------------------------------------------\n"

            # Cria condição de parada da execução: se o usuário clicar no botão cancel da página de log
            while True:
                # Método usado para permitir a iteração do usuário enquanto o programa está em execução
                QApplication.processEvents()
                self.dlg_flow_tt.btn_cancel_log.clicked.connect(lambda: self.cancel_log_page())

                # Verifica a existência de incoerências nas informações fornecidas pelo usuário
                list_line_edit_value_pg1 = [self.dlg_flow_tt.le_5_pg1.text(),
                                            self.dlg_flow_tt.le_6_pg1.text(),
                                            self.dlg_flow_tt.le_7_pg1.text(),
                                            self.dlg_flow_tt.le_8_pg1.text(),
                                            self.dlg_flow_tt.le_9_pg1.text(),
                                            self.dlg_flow_tt.le_10_pg1.text(),
                                            self.dlg_flow_tt.le_11_pg1.text(),
                                            self.dlg_flow_tt.le_12_pg1.text()
                                        ]
                duplicate = []
                # Verifica se há duplicatas no código
                for i in range(len(list_line_edit_value_pg1)):
                    for j in range(i+1,len(list_line_edit_value_pg1)):
                        if list_line_edit_value_pg1[i] == list_line_edit_value_pg1[j]:
                            # Para os elementos iguais, armazena eles em uma lista
                            duplicate.append(list_line_edit_value_pg1[i])

                if any(item == '' for item in duplicate):
                    self.dlg_flow_tt.pages_flow_tt.setCurrentIndex(0)
                    # Vefica se os códigos das diferções de drenagem foram corretamente enviados
                    QMessageBox.warning(self.dlg_flow_tt, 'Warning', "Direction codes might not None.")
                    return

                elif duplicate and all(item != '' for item in duplicate):
                    self.dlg_flow_tt.pages_flow_tt.setCurrentIndex(0)
                    # O usuário enviou 2 valores semelhantes, será mostrado uma mensagem de erro
                    QMessageBox.warning(self.dlg_flow_tt, 'Warning', f"The value(s) '{duplicate}' is(are) (a) duplicate(s)! Direction codes do not accept duplicates.")
                    return
                    
                else:
                    # Se não existir erros nas informações enviadas, será mostrada a página de log e o programa será executado
                    self.dlg_flow_tt.pg_par_ftt.setEnabled(False)

                    # Adiciona as mensagem de log ao text edit e configura a função run
                    self.dlg_flow_tt.te_logg.append(mensagem_log1)

                    # ---Entradas---
                    mensagem_log = "READING INPUT FILES...\n"
                    self.leh_bacia()
                    self.leh_direcoes_de_fluxo()
                    self.leh_modelo_numerico_dTerreno()
                    self.leh_drenagem()
                    self.leh_uso_do_solo()
                    self.dlg_flow_tt.te_logg.append(mensagem_log)

                    if self.flag == 0:
                        # O usuário digitou as informações
                        self.leh_valores_table_1()
                    
                    if self.flag_1 == 0:
                        # O usuário digitou as informações
                        self.leh_valores_table_2()

                    self.leh_precipitacao_24h()

                    # Atualiza a progress bar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 5)

                    # ---Cálculos---
                    mensagem_log = 'PROCESSING...\n'
                    self.dlg_flow_tt.te_logg.append(mensagem_log)
                    if self.global_vars.unidaderef3 == 'deg':
                        # sistema em graus, assumindo latlong
                        self.global_vars.metro = 0
                    else:
                        # sistema em metros
                        # se sistema de referencia em metros, fazer metro=1 (não faz projeção)
                        # caso contrário (se metro=0), assume que está graus e faz projeção para metros
                        self.global_vars.metro = 1

                    mensagem_log = 'Processing NumeraPix...\n'
                    self.dlg_flow_tt.te_logg.append(mensagem_log)
                    # self.numera_pixel()

                    # Atualiza a progress bar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    mensagem_log = 'Processing DistDren...\n' 
                    self.dlg_flow_tt.te_logg.append(mensagem_log)
                    # self.dist_drenagem()

                    # Atualiza a progress bar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    mensagem_log = 'Processing DistTrecho...\n'
                    self.dlg_flow_tt.te_logg.append(mensagem_log)
                    # self.dist_trecho()
                    
                    # Atualiza a progress bar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    mensagem_log = 'Processing TempoSup...\n'
                    self.dlg_flow_tt.te_logg.append(mensagem_log)
                    # self.tempo_sup()
                    
                    # Atualiza a progress bar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    mensagem_log = 'Processing ComprimAcu...\n'
                    self.dlg_flow_tt.te_logg.append(mensagem_log)
                    # self.comprimento_acumulado()
                    
                    # Atualiza a progress bar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    mensagem_log = 'Processing TempoCanal...\n'
                    self.dlg_flow_tt.te_logg.append(mensagem_log)
                    # self.tempo_canal()
                    
                    # Atualiza a progress bar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)
                    
                    # Atualiza a progress bar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    mensagem_log = 'Processig TempoTotal...\n'
                    self.dlg_flow_tt.te_logg.append(mensagem_log)
                    # self.tempo_total()
                    
                    # Atualiza a progress bar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    # Saídas
                    mensagem_log = 'WRITING OUTPUT FILES...\n'
                    self.dlg_flow_tt.te_logg.append(mensagem_log)

                    if self.dlg_flow_tt.ch_1_pg4.isChecked():
                        # Cria o arquivo selecionado
                        self.escreve_num_pix_drenagem()

                    if self.dlg_flow_tt.ch_2_pg4.isChecked():
                        # Cria o arquivo selecionado
                        self.escreve_conectividade()

                    if self.dlg_flow_tt.ch_3_pg4.isChecked():
                        # Cria o arquivo selecionado
                        self.escreve_comprimento_acumulado()

                    if self.dlg_flow_tt.ch_5_pg4.isChecked():
                        # Cria o arquivo selecionado
                        self.escreve_declivi_pixel()

                    if self.dlg_flow_tt.ch_6_pg4.isChecked():
                        # Cria o arquivo selecionado
                        self.escreve_decliv_pixel_jus()

                    if self.dlg_flow_tt.ch_7_pg4.isChecked():
                        # Cria o arquivo selecionado
                        self.escreve_tempo_total()

                    # Atualiza a progress bar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    mensagem_log = 'ADDING FILES SELECTED TO PROJECT LAYERS IN QGIS...\n'
                    self.dlg_flow_tt.te_logg.append(mensagem_log)

                    if self.dlg_flow_tt.rb_1_pg4.isChecked():
                        # Adiciona os arquivos gerados as layers do respectivo projeto do QGIS

                        if self.dlg_flow_tt.ch_1_pg4.isChecked() and self.fn_num_pix_dren  != '':
                            # Adiciona o arquivo selecionado: num_pix_dren
                            self.adiciona_layer(self.fn_num_pix_dren)
                            mensagem_log = 'Added...\n'
                            self.dlg_flow_tt.te_logg.append(mensagem_log)

                        if self.dlg_flow_tt.ch_2_pg4.isChecked() and self.fn_n_conect_dren  != '':
                            # Adiciona o arquivo selecionado: num_conexao_dren
                            self.adiciona_layer(self.fn_n_conect_dren)
                            mensagem_log = 'Added...\n'
                            self.dlg_flow_tt.te_logg.append(mensagem_log)

                        if self.dlg_flow_tt.ch_3_pg4.isChecked() and self.fn_comp_acum != '':
                            # Adiciona o arquivo selecionado
                            self.adiciona_layer(self.fn_comp_acum)
                            mensagem_log = 'Added...\n'
                            self.dlg_flow_tt.te_logg.append(mensagem_log)

                        if self.dlg_flow_tt.ch_4_pg4.isChecked() and self.fn_comp_foz != '':
                            # Adiciona o arquivo selecionado
                            self.adiciona_layer(self.fn_comp_foz)
                            mensagem_log = 'Added...\n'
                            self.dlg_flow_tt.te_logg.append(mensagem_log)

                        if self.dlg_flow_tt.ch_5_pg4.isChecked() and self.fn_decli_pix != '':
                            # Adiciona o arquivo selecionado
                            self.adiciona_layer(self.fn_decli_pix)
                            mensagem_log = 'Added...\n'
                            self.dlg_flow_tt.te_logg.append(mensagem_log)

                        if self.dlg_flow_tt.ch_6_pg4.isChecked() and self.fn_decli_pix_jus != '':
                            # Adiciona o arquivo selecionado
                            self.adiciona_layer(self.fn_decli_pix_jus)
                            mensagem_log = 'Added...\n'
                            self.dlg_flow_tt.te_logg.append(mensagem_log)

                        if self.dlg_flow_tt.ch_7_pg4.isChecked() and self.fn_temp_total != '':
                            # Adiciona o arquivo selecionado
                            self.adiciona_layer(self.fn_temp_total)
                            mensagem_log = 'Added...\n'
                            self.dlg_flow_tt.te_logg.append(mensagem_log)

                    # Atualiza a progress bar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 5)

                    # Adiciona as informação ao text edit
                    self.dlg_flow_tt.te_logg.append(mensagem_log)
                    QMessageBox.information(None, "Information", "Operation completed successfully!", )

                    break
        else:
            # O usuário selecionou a opção para cancelar
            self.dlg_flow_tt.tabWidget.setCurrentIndex(0)

    def cancel_log_page(self):
        '''Esta função configura o botão de cancelar da página de log'''
        mensagem_log = None
        # Cria texto formatado para adicionar ao text edit? mensagem de aviso
        mensagem_log = '<font>\nATTENTION: stopping FLOW TRAVEL TIME process...</font>'

        # Adiciona o texto formatado no QTextEdit
        self.dlg_flow_tt.te_logg.insertHtml(mensagem_log)

        # Reativa a página de parametros
        self.dlg_flow_tt.pg_par_ftt.setEnabled(True)

        # Desativa a página de log 
        self.dlg_flow_tt.pg_log_ftt.setEnabled(False)

    def run(self):
        """Esta é a função principal do plugin, todas as funcionalidades propostas anteriormente serão efetivadas na função run"""
        
        # Verifica se a interface já foi mostrada anteriormente
        if not hasattr(self, 'dlg_hidro_pixel') or not  self.dlg_hidro_pixel.isVisible():
            # Inicializa self.dlg_hidro_pixel apenas se ainda não estiver inicializado ou se estiver fechado
            self.dlg_hidro_pixel = HidroPixelDialog()
            # Mostra a interface gráfica
            self.dlg_hidro_pixel.show()
            QApplication.processEvents()

            # Desativa a página de log, só será ativada após clicar no botão run
            self.dlg_flow_tt.pg_log_ftt.setEnabled(False)
            # Cria as flags para configurar a leitura dos dados da tabela
            self.flag = 0
            self.flag_1 = 0

            # Configura botões do menu do hidropixel
            self.dlg_hidro_pixel.btn_flow_trav.clicked.connect(lambda: self.dlg_flow_tt.show())
            self.dlg_hidro_pixel.btn_exes_rain.clicked.connect(lambda: self.dlg_exc_rain.show())
            self.dlg_hidro_pixel.btn_flow_rout.clicked.connect(lambda: self.dlg_flow_rout.show())
            # self.dlg_hidro_pixel.btn_help.clicked.connect()

            '''Configura os botões da página da rotina do flow travel time'''
            self.dlg_flow_tt.btn_config.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg1_config))      
            self.dlg_flow_tt.btn_input_data.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg2_in_data))
            self.dlg_flow_tt.btn_data_va_tool.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg3_data_val_tool))
            self.dlg_flow_tt.btn_run.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg4_run))

            # Configura os botões da página configuration: flow travel time
            self.dlg_flow_tt.tbtn_pg1_1.clicked.connect(lambda: self.carrega_work_folder(self.dlg_flow_tt.le_13_pg1))
            
            # Configura os botões da página input data : flow travel time
            self.dlg_flow_tt.tbtn_pg2_1.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_1_pg2))
            self.dlg_flow_tt.tbtn_pg2_2.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_2_pg2))
            self.dlg_flow_tt.tbtn_pg2_3.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.te_1_pg2, qtd = 2))
            self.dlg_flow_tt.tbtn_pg2_4.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_3_pg2))
            self.dlg_flow_tt.tbtn_pg2_5.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_4_pg2))
            self.dlg_flow_tt.tbtn_pg2_6.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_5_pg2))

            # Configura os botões da página run page: flow travel time
            self.dlg_flow_tt.tbtn_pg4_1.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_1_pg4))
            self.dlg_flow_tt.tbtn_pg4_2.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_2_pg4))
            self.dlg_flow_tt.tbtn_pg4_3.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_3_pg4))
            self.dlg_flow_tt.tbtn_pg4_4.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_4_pg4))
            self.dlg_flow_tt.tbtn_pg4_5.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_5_pg4))
            self.dlg_flow_tt.tbtn_pg4_6.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_6_pg4))
            self.dlg_flow_tt.tbtn_pg4_7.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_7_pg4))

            # configura botões de salvar e salvar para um arquivo: flow travel time
            self.dlg_flow_tt.btn_save_file_pg1.clicked.connect(lambda: self.save_to_file(1))
            self.dlg_flow_tt.btn_save_file_pg2.clicked.connect(lambda: self.save_to_file(2))
            self.dlg_flow_tt.btn_save_file_pg4.clicked.connect(lambda: self.save_to_file(4))

            # Configura botão para ler informações de uma arquivo enviado : flow travel time
            self.dlg_flow_tt.btn_read_pg1.clicked.connect(lambda: self.read_from_file(1))
            self.dlg_flow_tt.btn_read_pg2.clicked.connect(lambda: self.read_from_file(2))
            self.dlg_flow_tt.btn_read_pg4.clicked.connect(lambda: self.read_from_file(4))

            # Configura botões das tabelas : flow travel time
            self.dlg_flow_tt.btn_read_t1.clicked.connect(lambda: self.read_tb_from_file(self.dlg_flow_tt.tbw_1_pg2,self.dlg_flow_tt.le_7_pg2, 1))
            self.dlg_flow_tt.btn_read_t2.clicked.connect(lambda: self.read_tb_from_file(self.dlg_flow_tt.tbw_2_pg2,self.dlg_flow_tt.le_8_pg2,2))
            self.dlg_flow_tt.btn_save_file_t1.clicked.connect(lambda: self.save_table_to_file(1))
            self.dlg_flow_tt.btn_save_file_t2.clicked.connect(lambda: self.save_table_to_file(2))
            self.dlg_flow_tt.btn_add_row_1.clicked.connect(lambda: self.add_new_row(self.dlg_flow_tt.tbw_1_pg2))
            self.dlg_flow_tt.btn_add_row_2.clicked.connect(lambda: self.add_new_row(self.dlg_flow_tt.tbw_2_pg2))
            self.dlg_flow_tt.btn_del_row_1.clicked.connect(lambda: self.delete_row(self.dlg_flow_tt.tbw_1_pg2))
            self.dlg_flow_tt.btn_del_row_2.clicked.connect(lambda: self.delete_row(self.dlg_flow_tt.tbw_2_pg2))
            
            # Configura botões de salvar das diferentes páginas : flow travel time
            self.dlg_flow_tt.btn_save_pg1.clicked.connect(lambda: self.save())
            self.dlg_flow_tt.btn_save_pg2.clicked.connect(lambda: self.save())
            self.dlg_flow_tt.btn_save_pg4.clicked.connect(lambda: self.save())

            # Configura os botões de limpeza das variáveis : flow travel time
            self.dlg_flow_tt.btn_clear_1.clicked.connect(lambda: self.clear_table(self.dlg_flow_tt.tbw_1_pg2,self.dlg_flow_tt.le_7_pg2))
            self.dlg_flow_tt.btn_clear_2.clicked.connect(lambda: self.clear_table(self.dlg_flow_tt.tbw_2_pg2,self.dlg_flow_tt.le_8_pg2))

            # configura botões da página run : flow travel time
            self.dlg_flow_tt.btn_close_pg4.clicked.connect(self.close_gui)
            
            # Configura run button : flow travel time
            self.dlg_flow_tt.btn_run_2.clicked.connect(lambda: self.logging_run_page())

            # Configura botões da página de log: : flow travel time
            self.dlg_flow_tt.ch_1_pg4.setChecked(False)  
            self.dlg_flow_tt.ch_2_pg4.setChecked(False)  
            self.dlg_flow_tt.ch_3_pg4.setChecked(False)  
            self.dlg_flow_tt.ch_4_pg4.setChecked(False)  
            self.dlg_flow_tt.ch_5_pg4.setChecked(False)  
            self.dlg_flow_tt.ch_6_pg4.setChecked(False)  
            self.dlg_flow_tt.ch_7_pg4.setChecked(False)

            # Configura botões página de log: : flow travel time
            self.dlg_flow_tt.btn_cancel_log.clicked.connect(self.cancel_log_page)
            self.dlg_flow_tt.btn_close_log.clicked.connect(self.close_gui)

            '''Configura os botões da página da rotina excess rainfall'''
            self.dlg_exc_rain.btn_config.clicked.connect(lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg1_config))      
            self.dlg_exc_rain.btn_input_data.clicked.connect(lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg2_in_data))
            self.dlg_exc_rain.btn_data_va_tool.clicked.connect(lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg3_data_val_tool))
            self.dlg_exc_rain.btn_run.clicked.connect(lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg4_run))

            # Configura botões da página de configuration: excess rainfall
            self.dlg_exc_rain.tbtn_pg1_1.clicked.connect(lambda: self.carrega_work_folder(self.dlg_exc_rain.le_13_pg1))

            '''Configura os botões da página da rotina flow routing'''
            self.dlg_flow_rout.btn_config.clicked.connect(lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg1_config))      
            self.dlg_flow_rout.btn_input_data.clicked.connect(lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg2_in_data))
            self.dlg_flow_rout.btn_data_va_tool.clicked.connect(lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg3_data_val_tool))
            self.dlg_flow_rout.btn_run.clicked.connect(lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg4_run))    

            # Configura botões da página de configuration: flow routing
            self.dlg_flow_rout.tbtn_pg1_1.clicked.connect(lambda: self.carrega_work_folder(self.dlg_flow_rout.le_13_pg1))

            '''Menu Hidropixel Plugin'''
            # Run the dialog event loop
            self.dlg_hidro_pixel.exec_()
            self.close_gui()
            self.dlg_exc_rain.close()
            self.dlg_flow_rout.close()