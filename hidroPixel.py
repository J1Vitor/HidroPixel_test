# -*- coding: utf-8 -*-
"""
/***************************************************************************
 HidroPixel
 Add the description
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2023 by João Vitor & Adriano Rolim
        email                : jvds@academico.ufpb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt import uic
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QRegularExpression
from qgis.PyQt.QtGui import QIcon, QRegExpValidator, QIntValidator, QFont
from qgis.PyQt.QtWidgets import QApplication, QMainWindow, QAction, QFileDialog, QMessageBox, QTableWidgetItem, QWidget, QStackedWidget
from qgis.core import QgsMessageLog, Qgis
from qgis.utils import iface



# Import the code for the dialog
import os.path
import sys, os
import logging
from .hidroPixel_dialog import HidroPixelDialog
from pathlib import Path
from datetime import datetime
from hidropixel.modulos_files.RDC_variables import RDCVariables
from hidropixel.modulos_files.global_variables import GlobalVariables

# Initialize Qt resources from file resources.py
from .resources import *

# Importing libs
import numpy as np
from osgeo import ogr, gdal

class HidroPixel:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'HidroPixel_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&HidroPixel')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Criando instâncias das classes
        self.global_vars = GlobalVariables()
        self.rdc_vars = RDCVariables()
            
        # Inicia a interface gráfica da rotina flow travel time
        file_path = os.path.dirname(__file__)
        ui_file = os.path.join(file_path,'hidroPixel_dialog_flow_tt.ui')

        # Mostrando a seção da rotina flow travel time
        self.dlg_flow_tt = uic.loadUi(ui_file)
        self.save_result = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('HidroPixel', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/hidroPixel/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'HidroPixel Plugin'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&HidroPixel'),
                action)
            self.iface.removeToolBarIcon(action)

    def carrega_work_folder(self):
        '''Esta função define a pasta padrão tanto para buscar, quanto para salvar os arquivos'''
        # Define as variáveis e configurações da janela de escolha do arquivo
        pasta = None
        self.dlg_flow_tt.le_13_pg1.setText('')
        options = QFileDialog.Options()
        pasta = QFileDialog.getExistingDirectory(None, caption = 'Select your work folder!', options = options)

        if pasta != '':
            # Se o usário enviar um arquivo, este será armazenado na sua referida line edit
            self.dlg_flow_tt.le_13_pg1.setText(pasta)
        else:
            # Caso contrário, será mostrada uma mensagem de aviso
            result ="Wait! You did not select any folder."
            QMessageBox.warning(None, "No folder selected", result)

        return pasta

    def carrega_arquivos(self, lineEdit, file_type="raster", qtd=1):
        """Esta função é utilizada para adicionar os arquivos enviados pelo usuário ao plugin"""
        # Define as variáveis e configurações da janela de escolha do arquivo
        file_ = None
        options = QFileDialog.Options()
        directory = self.dlg_flow_tt.le_13_pg1.text()

        while True:  # Loop até que o usuário selecione um arquivo ou cancele
            if qtd == 2:
                file_, _ = QFileDialog.getOpenFileNames(None, caption="Select the files!", directory=directory, filter="Raster or RDC file (*.tif *.rst *.rdc)", options=options)
                if file_:
                    lineEdit.setPlainText("\n".join(file_))
                    self.rdc_vars.nomeRDC = file_[0] if file_ else None
                    self.rdc_vars.nomeRST = file_[1] if len(file_) > 1 else None
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No file selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break  
            else:
                # Janela de diálogo com o Usuário
                if file_type == "raster".lower():
                    file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory=directory, filter="Raster Files (*.tif *.rst)", options=options)
                elif file_type == "text".lower():
                    file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory=directory, filter="Text Files (*.txt)", options=options)

                # Verificar se algum arquivo foi selecionado
                if file_:
                    # Adiciona o arquivo selecionado a lineEdit
                    lineEdit.setText(file_)
                    return file_
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break 

    def leh_bacia(self):
        """Esta função é utilizada para ler as informações da bacia hidrográfica (arquivo .rst)"""
        
        # Arquivo raster enviado pelo usuário
        arquivo = self.dlg_flow_tt.le_1_pg2.text()
        # Tratamento de erros: verifica se o arquivo foi corretamente enviado
        if arquivo:
            # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
            rst_file_bacia = gdal.Open(arquivo)

            # Lendo os dados raster como um array 
            dados_lidos_bacia = rst_file_bacia.GetRasterBand(1).ReadAsArray()
            
            # Tratamento de erro: verifica se o arquivo foi aberto corretamente
            if rst_file_bacia is not None:

                # atualizando os valores das variáveis para coletar o número de linhas e colunas do arquivo raster lido
                self.rdc_vars.nlin = rst_file_bacia.RasterYSize               
                self.rdc_vars.ncol = rst_file_bacia.RasterXSize

                # Determinando o numéro de elementos contidos no arquivo raster
                num_elements_bacia = dados_lidos_bacia.size

                # Tratamento de erros: verifica se o número de elementos (pixel) do arquivo está de acordo com as dimensões da matriz da bacia hidrográfica
                if num_elements_bacia != self.rdc_vars.nlin * self.rdc_vars.ncol:
                    result = f"ERROR! As dimensões do arquivo raster ({self.rdc_vars.nlin},{self.rdc_vars.ncol}) são diferentes do número total de \
                        elementos {num_elements_bacia}. Assim, não é possível ler o arquivo raster '{arquivo}' e armazená-lo na matriz destinada."
                    QMessageBox.warning(None, "ERROR!", result)
                else:
                    # Reorganizando os dados lidos da bacia em uma nova matriz chamada bacia.

                    # global_vars.bacia = dados_lidos_bacia
                    self.global_vars.bacia = dados_lidos_bacia
                    # Fechando o dataset GDAL

                    rst_file_bacia = None
            else:
                """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
                resulte = f"Failde to open the raster file: {arquivo}"
                QMessageBox.warning(None, "ERROR!", resulte)

        else:
            result ="Nenhum arquivo foi selecionado!"
            QMessageBox.warning(None, "ERROR!", result)

    def leh_valore_table_1(self):
        '''Esta função coleta as informações adicionadas nos itens da tabela da característica dos rios e adiciona em suas variáveis'''

        # Verifica a dimensão da tabela
        nlin_tb = self.dlg_flow_tt.tbw_1_pg2.rowCount()
        ncol_tb = self.dlg_flow_tt.tbw_1_pg2.columnCount()

        # Define variáveis para obtenção das informações
        id_class = []
        slope_class = []
        mann_coef_class = []
        hydraul_rad_class = []
        item = 0

        # Itera sobre os itens da tabela
        for col in range(ncol_tb):
            for lin in range(nlin_tb):
                item_tb = self.dlg_flow_tt.tbw_1_pg2.item(lin,col).text()

                if item_tb is not None:
                    # coleta o item da celula atual e tenta converter para float
                    try:
                        item_tb = float(self.dlg_flow_tt.tbw_1_pg2.item(lin,col).text())

                    except ValueError:
                        result = f'The value(s) {item_tb} is not a valid number! Please, add a valid information'
                        QMessageBox.warning(None, "ERROR!", result)
                        break

                    # coleta o id das classes
                    if col == 0:
                        id_class.append(item_tb)

                    # coleta a inclinação
                    elif col == 1:
                        slope_class.append(item_tb)
                    
                    # coleta o coeficiente de Manning
                    elif col == 2:
                        mann_coef_class.append(item_tb)
                    
                    # coleta o raio hidráulico
                    elif col == 3:
                        hydraul_rad_class.append(item_tb)
        # Atualiza a variável 
        # Atualiza as variáveis globais com os valores enviados
        self.global_vars.j = np.array(id_class)
        self.global_vars.Sclasse = np.array(slope_class)
        self.global_vars.Mannclasse = np.array(mann_coef_class)
        self.global_vars.Rhclasse = np.array(hydraul_rad_class)

    def leh_classes_rios(self):
        """Esta função é utilizada para ler as informações acerca da classe dos rios da bacia hidrográfica (arquivo raster -  .rst)"""
        
        # Abrindo o arquivo com as informações acerca das classes dos rios
        arquivo = self.dlg_flow_tt.le_4_pg2.text()

        # Tratamento de erros: verifica se o arquivo foi corretamente enviado
        if arquivo:
            # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
            rst_file_claRIO = gdal.Open(arquivo)
            
            # Lendo os dados raste como um array 
            dados_lidos_raster_claRIO = rst_file_claRIO.GetRasterBand(1).ReadAsArray()

            #  Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
            if rst_file_claRIO is not None:
                # Reorganizando os dados lidos em uma nova matriz, essa possui as informações sobre as classes dos rios
                self.global_vars.classerio = dados_lidos_raster_claRIO
                # Fechando o dataset GDAL referente ao arquivo raster
                rst_file_claRIO = None
            else:
                # Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro
                resulte = f"Failde to open the raster file: {arquivo}"
                QMessageBox.warning(None, "ERROR!", resulte)
                
        else:
            # Exibe uma mensagem de erro
            result ="Nenhum arquivo foi selecionado!"
            QMessageBox.warning(None, "ERROR!", result)

    def leh_direcoes_de_fluxo(self):
        """Esta função é utilizada para ler as informações acerca da direção de escoamento dos rios (arquivo raster - .rst)"""

        # Definindo a numeração das direções &
        # Definindo a posição relativa dos pixels vizinhos
        # lin viz = lin centro + dlin(i)
        # col viz = col centro + dcol(i)
        
        self.global_vars.dlin = {
                            1: -1,
                            2: 0,
                            4: 1,
                            8: 1,
                            16: 1,
                            32: 0,
                            64: -1,
                            128: -1
                            }
        self.global_vars.dcol = {
                            1: 1,
                            2: 1,
                            4: 1,
                            8: 0,
                            16: -1,
                            32: -1,
                            64: -1,
                            128: 0
                            }

       
        # ATENÇÃO PARA O VALOR NUMÉRICO DAS DIRECÕES
        # ---------------------------------------------------------
        # - G  H  A      ArcView:  32 64 128    MGB-IPH:  64  128  1 -
        # - F  *  B                16  *  1               32   *   2 -
        # - E  D  C                 8  4  2               16   8   4 -

        # Recebendo os arquivos necessários: função run
        if self.rdc_vars.nomeRDC and self.rdc_vars.nomeRST:

            # Verificando a extensão do arquivo: ordem de leitura, 1st o arquivo rdc
            exten1 = Path(self.rdc_vars.nomeRDC).suffix.lower()
            exten2 = Path(self.rdc_vars.nomeRST).suffix.lower()
            # Verifica se o primeiro arquivo é .rdc e o segundo .rst
            if exten1 == ".rdc" and exten2 == ".rst":
                self.rdc_vars.nomeRDC, self.rdc_vars.nomeRST = self.rdc_vars.nomeRDC, self.rdc_vars.nomeRST
            # Verifica se o primeiro arquivo é .rst e o segundo .rdc, caso contrário, troca os nomes
            elif exten1 == ".rst" and exten2 == ".rdc":
                self.rdc_vars.nomeRDC, self.rdc_vars.nomeRST = self.rdc_vars.nomeRST, self.rdc_vars.nomeRDC

            # Abrindo o arquivo RDC
            arquivo = self.rdc_vars.nomeRDC
            with open(arquivo, 'r',  encoding='iso-8859-1') as rdc_file:
                # Separando os dados do arquivo RDC em função das linhas que contém alguma das palavras abaixo
                k_words = ["columns", "rows", "ref. system", "ref. units", "min. X", "max. X", "min. Y", "max. Y", "resolution"]
                lines_RDC = [line.strip() for line in rdc_file.readlines() if any(word in line for word in k_words)]
                
                # Iterando sobre a lista de lines_rdc para guardas as informações das palavras da lista (k_words) nas ruas respectivas variáveis
                for line in lines_RDC:
                    # Separando as linhas de acordo com o refencial (:)
                    split_line = line.split(":")
                    # Armazenando o primeiro valor da linha (antes do sinal ":")em uma variável e retirando os espaços (caracter) do inicio e fim da linha repartida
                    key = split_line[0].strip()
                    # Armazenando o segundo valor da linha (antes do sinal ":") em uma variáveis e retirando os espaços (caracter) do inicio e fim da linha repartida
                    value = split_line[-1].strip()

                    # Estrutura condicional para verificar quais são as informações de cada linha e armazenando elas em suas respectivas variáveis
                    if key == "rows":
                        self.rdc_vars.nlin = int(value)
                    elif key == "columns":
                        self.rdc_vars.ncol = int(value)
                    elif key == "ref. system":
                        self.rdc_vars.sistemaref = value
                    elif key == "ref. units":
                        self.rdc_vars.unidaderef3 = value
                    elif key == "min. X":
                        self.rdc_vars.xmin = float(value)
                    elif key == "max. X":
                        self.rdc_vars.xmax = float(value)
                    elif key == "min. Y":
                        self.rdc_vars.ymin = float(value)
                    elif key == "max. Y":
                        self.rdc_vars.ymax = float(value)
                    elif key == "resolution":
                        self.global_vars.dx = float(value)
            
            # Atualizando algumas variáveis com as informações coletadas do arquivo RDC
            self.global_vars.Xres2 = self.global_vars.dx
            self.global_vars.Xres = float(self.global_vars.Xres2)
            self.global_vars.Yres = self.global_vars.Xres

            # Abrindo o arquivo raster
            rst_file_dir = gdal.Open(self.rdc_vars.nomeRST)
            # Lendo os dados raster como um array
            dados_lidos_direcoes = rst_file_dir.GetRasterBand(1).ReadAsArray()

            # Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
            if rst_file_dir is not None:
                # Reorganizando os dados lidos na matriz destinadas às informações da drenagem da bacia hidrográfica
                self.global_vars.direcoes = dados_lidos_direcoes

                # Fechando o dataset GDAL referente ao arquivo raster
                rst_file_dir = None
            else:
                """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
                resulte = f"Failde to open the raster file: {self.rdc_vars.nomeRST}"
                QMessageBox.warning(None, "ERROR!", resulte)

            # Verificação do valor da variável maxdir
            self.global_vars.maxdir = np.amax(self.global_vars.direcoes)

            # Iniciando a iterações com base nas linhas e colunas
            if self.global_vars.maxdir > 128:
                # Mapeamento das direções de fluxo do tipo idrisi
                A = self.dlg_flow_tt.le_5_pg1.text()
                B = self.dlg_flow_tt.le_6_pg1.text()
                C = self.dlg_flow_tt.le_7_pg1.text()
                D = self.dlg_flow_tt.le_8_pg1.text()
                E = self.dlg_flow_tt.le_9_pg1.text()
                F = self.dlg_flow_tt.le_10_pg1.text()
                G = self.dlg_flow_tt.le_11_pg1.text()
                H = self.dlg_flow_tt.le_12_pg1.text()
                valores = [A, B, C, D, E, F, G, H]
                chaves = [45, 90, 135, 180, 225, 270, 315, 360]
                value_error = [valor for valor in valores if type(valor) != int]

                # Dicionário com as combinações das direções de fluxo
                idrisi_map = {}
                for chave, valor in zip(chaves, valores):
                    try:
                        idrisi_map[chave] = int(valor) #devem ser diferentes entre si, i+1 != i e i-1
                    except ValueError:
                        result = f'The value(s) "{value_error}" is(are) not (a) valid integer number(s)!'
                        QMessageBox.warning(None, "ERROR!", result)
                
                for lin in range(self.rdc_vars.nlin):
                    for col in range(self.rdc_vars.ncol):
                        # Verifica se o valor atual da variável maxdir está presente no mapeamento
                        if self.global_vars.direcoes[lin, col] in idrisi_map:
                            # Atualiza o valor do elemento atual da matriz dir de acordo com os novos valores
                            self.global_vars.direcoes[lin, col] = idrisi_map[self.global_vars.direcoes[lin, col]]


            # Tratamento das direções na borda
            self.global_vars.direcoes[0, :] = 128
            self.global_vars.direcoes[-1, :] = 8
            self.global_vars.direcoes[:, 0] = 32
            self.global_vars.direcoes[:, -1] = 2

    def leh_drenagem(self):
        """Esta função é utilizada para ler as informações acerca da drenagem dos rios (arquivo raster - .rst)"""

        # Obtendo o arquivo referente as calasses dos rios da bacia hidrográfica
        arquivo = self.dlg_flow_tt.le_3_pg2.text()
        # Abrindo o arquivo raster com as informações acerda do sistema de drenagem da bacia hidrográfica
        rst_file_drenagem = gdal.Open(arquivo)
        
        # Lendo os dados raster como um array
        dados_lidos_drenagem = rst_file_drenagem.GetRasterBand(1).ReadAsArray()

        # Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_drenagem is not None:
            # Reorganizando os dados lidos na matriz destinadas às informações da drenagem da bacia hidrográfica
            self.global_vars.dren = dados_lidos_drenagem
            
            # Fechando o dataset GDAl referente ao arquivo raster
            rst_file_drenagem = None
        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {arquivo}"
            QMessageBox.warning(None, "ERROR!", resulte)


    def leh_modelo_numerico_dTerreno(self):
        """Esta função é utilizada para ler as informações acerca do modelo numérico do terreno (arquivo raster - .rst)"""

        # Obtendo o arquivo referente ao MDE da bacia hidrográfica
        arquivo = self.dlg_flow_tt.le_2_pg2.text()

        # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
        rst_file_MDE = gdal.Open(arquivo)

        # Lendo os dados raster como um array
        dados_lidos_MDE = rst_file_MDE.GetRasterBand(1).ReadAsArray()

        #  Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_MDE is not None:
            # Reoganizando os dados lidos em uma nova matriz que possuirá os dados ligados ao MDE da baciaa hidrográfica
            self.global_vars.MDE = dados_lidos_MDE

            # Fechando o dataset GDAL
            rst_file_MDE = None
        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {arquivo}"
            QMessageBox.warning(None, "ERROR!", resulte)

    def leh_precipitacao_24h(self):
        """Esta função é utilizada para ler as informações acerca da precipitação das últimas 24 horas, P24 (arquivo texto - .txt)"""

        # Armazenando o valor da precipitação de 24 horas em uma variável específica
        self.global_vars.P24 = float(self.dlg_flow_tt.le_6_pg2.text())

    def leh_uso_do_solo(self):
        """Esta função é utilizada para ler as informações acerca do uso do solo (arquivo raster - .rst)"""

        # Obtendo o arquivo raster referente ao uso do solo
        arquivo = self.dlg_flow_tt.le_5_pg2.text()

        # Abrindo o arquivo raster com as informações acerda do uso do solo da bacia hidrográfica
        rst_file_usoSolo = gdal.Open(arquivo)

        # Lendo os dados do arquivo raster como um array
        dados_lidos_usoSolo = rst_file_usoSolo.GetRasterBand(1).ReadAsArray()

        # Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_usoSolo is not None:
            # Reorganizando os dados lidos na matriz destinadas às informações da drenagem da bacia hidrográfica
            self.global_vars.usosolo = dados_lidos_usoSolo

            # Inicializando as variáveis fundamentais
            self.global_vars.Nusomax = np.amax(self.global_vars.usosolo)

        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {arquivo}"
            QMessageBox.warning(None, "ERROR!", resulte)

                  
    def leh_valores_table_2(self):
        '''Esta função coleta as informações adicionadas nos itens da tabela das classes do uso e ocupação do solo e adiciona em suas variáveis'''
        # Verifica a dimensão da tabela
        nlin_tb = self.dlg_flow_tt.tbw_2_pg2.rowCount()
        ncol_tb = self.dlg_flow_tt.tbw_2_pg2.columnCount()

        # Cria variáveis necessárias
        uso_manning_val = []
        coef_maning_val = []

        # Itera sobre os itens da tabela
        for col in range(ncol_tb):
            for lin in range(nlin_tb):
                item_tb = self.dlg_flow_tt.tbw_2_pg2.item(lin,col).text()

                if item_tb is not None:
                    
                    # Coleta os ID's das classes
                    if col == 0:
                        # coleta o item da celula atual e tenta converter para int
                        try:
                            item_tb = int(self.dlg_flow_tt.tbw_2_pg2.item(lin,col).text())

                        except ValueError:
                            result = f'The value(s) {item_tb} is not a valid number! Please, add a valid information'
                            QMessageBox.warning(None, "ERROR!", result)
                            break

                        # Armazena o valor do ID em sua variável
                        uso_manning_val.append(item_tb)
                    
                    # Coleta os valores dos coeficiente de Mannning por classe
                    if col == 2:
                        # coleta o item da celula atual e tenta converter para float
                        try:
                            item_tb = float(self.dlg_flow_tt.tbw_2_pg2.item(lin,col).text())

                        except ValueError:
                            result = f'The value(s) {item_tb} is not a valid number! Please, add a valid information'
                            QMessageBox.warning(None, "ERROR!", result)
                            break

                        # Armazena o valor do coef. de Manning em sua variável
                        coef_maning_val.append(item_tb)   
        # Adicionando cada valor às suas respectivas variáveis
        self.global_vars.usaux = uso_manning_val
        self.global_vars.Mann = coef_maning_val

    def project(self,x1, x2, y1,y2,tipo2,dist2,lado2,diagonal2):
        """Esta função calcula as distâncias sobre a superfície considerando o elipsóide WGS84"""
        # Definindo as constantes
        PI = 3.141592
        A = 6378.137 #comprimento do semi eixo maior do elipsóide (km)
        B = 6358.752 #comprimento do semi eixo menor do elipsóide (km)

        # Iniciando os cálulos
        ylat = (y1 + y2) / 2

        # Definição do achatamento do elipsóide
        f = (A - B) / A 
        # Determinando o quadrado da excentricidade
        e2 = (2*f) - (f**2) 
        # Determinando o raio da curvatura da Terra na latitude ylat
        rn = A / ((1 - e2*(np.sin(ylat)))**0.2) 

        # Calculando o raio da circunferência de um círculo determinado pelo plano que corta o elipsóide na latitude ylat
        raio_circ = rn*np.cos(ylat)
        dgx = x2 - x1
        dgy = y1 - y2

        dx = raio_circ*dgx*(PI/180.0)
        dy = rn*dgy*(PI/180.0)

        # Verificando o conteúdo da vairável tipo2 e atualizando a distanância com base nele
        if tipo2 == 1:
            dist2 = dx*lado2
        elif tipo2 == 2:
            dist2 = dy*lado2
        elif tipo2 == 3:
            dist2 = np.sqrt(dx**2+dy**2)*diagonal2/1.414

        self.global_vars.dist_2 = dist2

        return dist2

    def comprimento_acumulado(self,lado):
        """Esta função calcula o comprimento acumulado da rede de drenagem, ou seja, dos diferentes cursos d'água presentes na bacia hidrográfica."""
        self.Lfoz = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol), dtype=np.float64)
        self.Lac = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol), dtype=np.float64)
        self.global_vars.lado = lado
        self.global_vars.diagonal = lado*np.sqrt(2.0)
        
        # Iniciando a iteração para varrer todos os elementos da bacia hidrográfica
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Delimitando apenas os elementos que estão presentes na bacia hidrográfica
                if self.global_vars.bacia[lin,col] == 1:
                    # Coletando as informações referentes ao sistema de drenagem da bacia hidrográfica
                    if self.global_vars.dren[lin,col] == 1:
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.caminho = 0
                        
                        while self.global_vars.caminho == 0:

                            # Criando condição de parada
                            condicao = self.global_vars.linaux <= 1 or self.global_vars.linaux >= self.rdc_vars.nlin \
                            or self.global_vars.colaux<=1 or self.global_vars.colaux>= self.rdc_vars.ncol \
                            or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux] == 0

                            if condicao:
                                self.global_vars.caminho = 1

                            else:
                                # Continuar caminho: determina a contagem das distâncias projetadas (WGS84) e \
                                # determina as coordenadas verticais do pixel+

                                self.global_vars.Xesq = self.rdc_vars.xmin + (self.global_vars.colaux - 1)*self.global_vars.Xres
                                self.global_vars.Xdir = self.global_vars.Xesq + self.global_vars.Xres
                                self.global_vars.Yinf = self.global_vars.ymax - self.global_vars.linaux*self.global_vars.Yres
                                self.global_vars.Ysup = self.global_vars.Yinf + self.global_vars.Yres

                                # Determinando a posição relativa ao pixel anterior
                                condicao2 = self.global_vars.linaux2 == self.global_vars.linaux or self.global_vars.colaux2 == self.global_vars.colaux
                                if condicao2:
                                    if self.global_vars.linaux2 == self.global_vars.linaux:
                                        self.rdc_vars.tipo = 1
                                    else:
                                        self.rdc_vars.tipo = 2
                                else:
                                    self.rdc_vars.tipo = 3

                                # Deteminando a distância incremental projetada
                                if self.global_vars.metro == 0:
                                    self.global_vars.auxdist = self.project(self.global_vars.Xesq,
                                                                        self.global_vars.Xdir,
                                                                        self.global_vars.Ysup,
                                                                        self.global_vars.Yinf,
                                                                        self.rdc_vars.tipo,
                                                                        self.global_vars.auxdist,
                                                                        self.global_vars.lado,
                                                                        self.global_vars.diagonal)
                                    
                                else:
                                    if self.rdc_vars.tipo == 1 or self.rdc_vars.tipo == 2:
                                        self.global_vars.auxdist = self.global_vars.dx*self.global_vars.lado

                                    else:
                                        self.global_vars.auxdist = self.global_vars.dx*self.global_vars.diagonal
                                        
                                # Atualizando o comprimento do rio desde o pixel inicial
                                self.global_vars.tamcam += self.global_vars.auxdist
                                self.global_vars.tamfoz = self.global_vars.tamcam

                                # Condição para verificar se o tamanho do rio é maior que o armazenameto do pixel
                                condicao3 = self.global_vars.tamcam > self.Lac[self.global_vars.linaux, self.global_vars.colaux]
                                if condicao3:
                                    # O valor do pixel é armazenado em um novo rio
                                    self.Lac[self.global_vars.linaux, self.global_vars.colaux] = self.global_vars.tamcam
                                
                                # Armazena o pixel contabilizado
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux

                                # determina o próximo píxel do caminho
                                self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux, self.global_vars.colaux]
                                self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                                self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]
                                # JVD: alocação redundante(caminho = 0)
                                self.global_vars.sda = 0

                        # Atulizando a variável lfoz
                        self.Lfoz[lin, col] = self.global_vars.tamfoz
                        

    def numera_pixel(self):
        '''
        Esta função enumera os píxels presentes na rede de drenagem
        '''
        # self.cabeceira = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol), dtype=np.int32)
        self.contadren = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol), dtype=np.float64)
        self.numcabe = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol), dtype=np.float64)
        self.cabeceira = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.numcabeaux = 0
        
        # Enumerando os píxels pertencentes à bacia e à rede de drenagem
        pix_bacia_e_dren = (self.global_vars.bacia == 1) & (self.global_vars.dren == 1)

        self.rdc_vars.cont += np.sum(pix_bacia_e_dren)

        self.contadren[pix_bacia_e_dren] = self.rdc_vars.cont

        pixel_dren = np.where(self.global_vars.dren == 1)
        self.lincontadren = np.array(pixel_dren[0])
        self.colcontadren = np.array(pixel_dren[1])


        # Numeração dos píxels internos a bacia: São chamados de cabeceira, pois o caminho do fluxo é iniciado a partir de cada um deles
        for col in range(1, self.rdc_vars.ncol - 1):
            for lin in range(1, self.rdc_vars.nlin - 1):
            
                # Atualizará apenas os píxel que estão na bacia hidrográfica(cabeceira == 1)
                if self.global_vars.bacia[lin][col] == 1:
                    # A priori, todos os píxels serão considerados de cabeceira
                    self.cabeceira[lin][col] = 1
                    # Cria vizinhança 3x3 para estudar a direção de fluxo do píxel central.
                    for linaux in range(lin - 1, lin + 2):
                        for colaux in range(col - 1, col + 2):
                            # Para cada vizinho, verifica a direção de fluxo dela e para qual pixel ele drena
                            self.global_vars.diraux = self.global_vars.direcoes[linaux][colaux]
                            self.global_vars.linaux2 = linaux + self.global_vars.dlin[self.global_vars.diraux]
                            self.global_vars.colaux2 = colaux + self.global_vars.dcol[self.global_vars.diraux]

                            # Se algum vizinho drenar para o central em análise, este não é de cabeceira
                            if self.global_vars.linaux2 == lin and self.global_vars.colaux2 == col:
                                self.cabeceira[lin][col] = 0

                    # Contagem de píxels que são cabeceira
                    if self.cabeceira[lin][col] == 1:
                        self.numcabeaux += 1
                        self.numcabe[lin][col] = self.numcabeaux

        # Atualiza variáveis globais
        self.global_vars.numcabe = self.numcabe
        self.global_vars.Ncabec = self.numcabeaux

    def dist_drenagem(self):
        """Esta funçao determina a distância incremental percorrida pela água na rede de drenagem,
            assim como a declividade pixel a pixel"""

        self.DIST = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.pixeldren = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.Difcota = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol)) 
        self.DECLIVpixjus = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.lado = 1 
        self.global_vars.diagonal = np.sqrt(2)
        a = 0
        # iterando sobre os elementos do arquivo raster
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Relaizando operações no apenas na região da bacia hidográfica
                if self.global_vars.bacia[lin][col] == 1:
                    self.global_vars.linaux = lin
                    self.global_vars.colaux = col
                    self.global_vars.caminho = 0
                    self.global_vars.tamcam = 0.0

                    if self.global_vars.dren[lin][col] == 1:
                        self.global_vars.caminho = 1

                    else:
                        while self.global_vars.caminho == 0:
                            
                            condicao = (self.global_vars.linaux<= 1
                            or self.global_vars.linaux>=self.rdc_vars.nlin
                            or self.global_vars.colaux<=1 or self.global_vars.colaux>= self.rdc_vars.ncol
                            or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux]==0)

                            # Verificando a resposta da variável condicao
                            if condicao:
                                self.global_vars.caminho = 1
                            
                            else:
                                # Criando a segunda condição: 
                                # valores pertencentes ao sistema de drenagem da bacia
                                condicao2 = self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux]== 1

                                if condicao2:
                                    # Após alocação do pixel da rede de drenagem: encerra o processo de busca
                                    self.global_vars.caminho = 1
                                    self.DIST[lin][col] = self.global_vars.tamcam
                                    self.pixeldren[lin][col] = self.contadren[self.global_vars.linaux][self.global_vars.colaux]
                                else:
                                    self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                                    self.global_vars.caminho = 0
                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.linaux2 = self.global_vars.linaux

                                    self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                                    self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]

                                    # Calculando a distância incremental percorrida &
                                    # Contabilizar distancias projetadas (WGS84) &
                                    # Determina coordenadas vertices do pixel
                                    self.global_vars.Xesq = self.rdc_vars.xmin + (self.global_vars.colaux2 - 1) * self.global_vars.Xres
                                    self.global_vars.Xdir = self.global_vars.Xesq + self.global_vars.Xres
                                    self.global_vars.Yinf = self.rdc_vars.ymax - self.global_vars.linaux2 * self.global_vars.Yres
                                    self.global_vars.Ysup = self.global_vars.Yinf + self.global_vars.Yres

                                    # Determina a posição relativa ao píxel anterior
                                    condicao3 = self.global_vars.linaux2 == self.global_vars.linaux or self.global_vars.colaux2 == self.global_vars.colaux
                                    if condicao3:
                                        if self.global_vars.linaux2 == self.global_vars.linaux:
                                            self.rdc_vars.tipo = 1
                                        else:
                                            self.rdc_vars.tipo = 2
                                    else:
                                        self.rdc_vars.tipo = 3

                                    # Determinando a distância incremental projetada
                                    if self.global_vars.metro == 0:
                                        self.global_vars.auxdist = self.project(self.global_vars.Xesq,
                                                           self.global_vars.Xdir,
                                                           self.global_vars.Ysup,
                                                           self.global_vars.Yinf,
                                                           self.rdc_vars.tipo,
                                                           self.global_vars.auxdist,
                                                           self.global_vars.lado,
                                                           self.global_vars.diagonal)
                                    else:
                                        condicao4 = self.rdc_vars.tipo == 1 or self.rdc_vars.tipo == 2
                                        if  condicao4:
                                            self.global_vars.auxdist = self.global_vars.dx * self.global_vars.lado
                                        else:
                                            self.global_vars.auxdist = self.global_vars.dx * self.global_vars.diagonal
                                    
                                    # atualiza o comprimento do rio desde o pixel inicial
                                    self.global_vars.tamcam += self.global_vars.auxdist

                                    # ARPdeclivjus
                                    if self.global_vars.tipo_decliv == 4:
                                        # calcula declividade do pixel relativo ao pixel de jusante (este pixel)
                                        self.global_vars.Lincr = self.global_vars.auxdist
                                        self.Difcota = self.global_vars.MDE[self.global_vars.linaux2][self.global_vars.colaux2] - self.global_vars.MDE[self.global_vars.linaux][self.global_vars.colaux]
                                        self.DECLIVpixjus[self.global_vars.linaux2][self.global_vars.colaux2] = self.Difcota/self.global_vars.Lincr*1000.0
                                        self.global_vars.Streaux = self.DECLIVpixjus[self.global_vars.linaux2][self.global_vars.colaux2]
                                        self.global_vars.Ltreaux = self.global_vars.Lincr
                                        self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux2][self.global_vars.colaux2]
                                        self.global_vars.Smin = 10 #em m/km

                                        if self.global_vars.Streaux < self.global_vars.Smin:
                                            self.global_vars.Streaux = self.global_vars.Smin
                                        
                                        self.global_vars.Smax = 600 #em m/km
                                        if self.global_vars.Streaux > self.global_vars.Smax:
                                            self.global_vars.Streaux = self.global_vars.Smax

                                        # JVD: correção da indexação para o python (inicia no zero)
                                        self.global_vars.TSpix = 5.474 * ((self.global_vars.Mann[self.global_vars.usaux - 1] *self.global_vars.Ltreaux)**0.8) \
                                            / ((self.global_vars.P24**0.5)*((self.global_vars.Streaux/1000.0)**0.4))


    def dist_trecho(self):
        ''' Esta função determina a distânica percorrida (trechos que são cabeceira => drenam para outros pixels) por cada trecho do pixel mais distante até o exitório'''
        self.global_vars.numtre = 0
        self.global_vars.numtreauxmax = 0
        condicao1 = None
        
        #ARPlidar: loop para contar o número máximo de trechos 
        for col in range(1, self.rdc_vars.ncol - 1):
            for lin in range(1, self.rdc_vars.nlin - 1):
                # Ações realizadas apenas na região da bacia
                if self.global_vars.bacia[lin][col] == 1:
                    # ARPlidar
                    if self.global_vars.numcabe[lin][col] > 0:
                        self.global_vars.numcabeaux = self.global_vars.numcabe[lin][col]
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.linaux2 = lin
                        self.global_vars.colaux2 = col
                        self.global_vars.linaux3 = lin
                        self.global_vars.colaux3 = col
                        self.global_vars.numtreaux = 0
                        self.global_vars.caminho = 0
                        self.global_vars.usaux = self.global_vars.usosolo[lin][col]
                        self.global_vars.usaux2 = self.global_vars.usaux

                        # ARPlidar
                        # Grava qual trecho o píxel em questão pertence
                        self.global_vars.numtreaux2 = 1

                        while self.global_vars.caminho == 0:
                            self.global_vars.diraux = self.global_vars.direcoes[lin][col]
                            self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                            self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]

                            condicao1 = self.global_vars.usaux != self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]
                            condicao2 = self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] == 1
                           
                            if condicao1 or condicao2:
                                # Mudou o uso do solo ou alcançou a rede de drenagem, 
                                # então terminou um trecho no píxel anterior
                                self.global_vars.numtreaux += 1
                                if self.global_vars.numtreaux > self.global_vars.numtreauxmax:
                                    self.global_vars.numtreauxmax = self.global_vars.numtreaux
                                # ARPlidar: incluindo o teste da bacia
                                condicao3 = self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] == 1 or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux] == 1
                                if condicao3:
                                    self.global_vars.caminho = 1
                                else:
                                    # Continua o caminho, porém em um trecho novo
                                    self.global_vars.linaux2 = self.global_vars.linaux
                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.linaux3 = self.global_vars.linaux
                                    self.global_vars.colaux3 = self.global_vars.colaux
                                    self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]
                                    # ARPdecliv
                                    # Grava qual trecho o píxel em questão pertence
                                    self.global_vars.numtreaux2 += 1
                            else:
                                # Vai continuar caminhando, mas grava o valor do par (lin,col) do último píxel acessado
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux
                                self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]
        
        self.global_vars.Ntre = self.global_vars.numtreaux + 1
        # Percorrendo o caminho desde as cabeceiras e granvando as distâncias relativas de cada trecho de uso do solo contínuo
        self.global_vars.numtre = 0
        self.global_vars.refcabtre = 0
        
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Verificando os elementos da região da bacia
                if self.global_vars.numcabe[lin][col] > 0:
                    self.global_vars.numcabeaux = self.global_vars.numcabe[lin][col]
                    self.global_vars.linaux = lin
                    self.global_vars.colaux = col
                    self.global_vars.linaux2 = lin
                    self.global_vars.colaux2 = col
                    self.global_vars.linaux3 = lin
                    self.global_vars.colaux3 = col
                    self.global_vars.numtreaux = 0
                    self.global_vars.caminho = 0
                    self.global_vars.usaux = self.global_vars.usosolo[lin][col]
                    self.global_vars.usaux2 = self.global_vars.usaux

                    # ARPdecliv
                    # Grava qual trecho o píxel em questão pertence
                    self.global_vars.numtreaux2 = 1 
                    self.global_vars.TREpix[self.global_vars.linaux2][self.global_vars.colaux2]

                    while self.global_vars.caminho == 0:
                        self.global_vars.diraux = self.global_vars.direcoes[lin][col]
                        self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                        self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]

                        if condicao1 or condicao2:
                            # Mudou o tipo de uso do solo ou alcançou a rede de drenagem,
                            # então terminou o trecho no píxel anterior
                            self.global_vars.numtreaux +=1
                            self.global_vars.numtre[self.global_vars.numtreaux] = self.global_vars.numtreaux
                            self.global_vars.Ltre[self.global_vars.numtreaux][self.global_vars.numtreaux] = self.global_vars.DIST[self.global_vars.linaux3][self.global_vars.colaux3] \
                                                                                                            - self.global_vars.DIST[self.global_vars.linaux][self.global_vars.colaux] 
                            # Grava a distância (DIST) do último píxel do trecho
                            self.global_vars.DISTult[self.global_vars.numtreaux][self.global_vars.numtreaux] = self.global_vars.DIST[self.global_vars.linaux][self.global_vars.colaux]
                            self.global_vars.cotaini[self.global_vars.numtreaux][self.global_vars.numtreaux] = self.global_vars.MDE[self.global_vars.linaux][self.global_vars.colaux]
                            self.global_vars.cotafim = [self.global_vars.numtreaux][self.global_vars.numtreaux] = self.global_vars.MDE[self.global_vars.linaux][self.global_vars.colaux]
                            
                            a1 = (self.global_vars.cotaini[self.global_vars.numtreaux][self.global_vars.numtreaux] - self.global_vars.cotafim[self.global_vars.numtreaux][self.global_vars.numtreaux])
                            b1 = self.global_vars.Ltre[self.global_vars.numtreaux][self.global_vars.numtreaux]*1000.0
                            self.global_vars.Stre[self.global_vars.numtreaux][self.global_vars.numtreaux] = a1 / b1
                            self.global_vars.usotre[self.global_vars.numtreaux][self.global_vars.numtreaux] = self.global_vars.usaux

                            # ARPlidar: adiciona a bacia como condição
                            condicao4 = self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] == 1 or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux]
                            if condicao4:
                                self.global_vars.caminho = 1
                                self.global_vars.refcabtre[self.global_vars.linaux3][self.global_vars.colaux3] = self.global_vars.numtreaux
                                self.global_vars.refcabtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux
                            else:
                                # Vai continuar o cominho, mas em um novo trecho
                                self.global_vars.refcabtre[self.global_vars.linaux3][self.global_vars.colaux3] = self.global_vars.numtreaux
                                self.global_vars.refcabtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux

                                self.global_vars.linaux3 = self.global_vars.linaux
                                self.global_vars.colaux3 = self.global_vars.colaux
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux
                                self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                                # ARPdecliv
                                # Grava qual trecho o píxel em questão pertence
                                self.global_vars.numtreaux2 += 1
                                self.global_vars.TREpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux2
                        else:
                            # Vai continuar caminhando, mas grava o valor do par (lin,col) do último píxel acessado
                            self.global_vars.refcabtre[self.global_vars.linaux3][self.global_vars.colaux3] = self.global_vars.numtreaux + 1
                            self.global_vars.refcabtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux + 1
                            
                            self.global_vars.linaux2 = self.global_vars.linaux
                            self.global_vars.colaux2 = self.global_vars.colaux
                            self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                            # ARPdecliv
                            # Grava qual trecho o píxel em questão pertence
                            self.global_vars.TREpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux2

        # Percorre novamente o caminho desde às cabeceiras, gravando distancias relativas de cada pixel dentro de cada trecho de uso do solo continuo 
        self.global_vars.DISTtre = 0
        self.global_vars.CABEpix = 0
        self.global_vars.DECLIVpix = 0

        # Percorrendo os elementos da bacia hidrográfica
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Os cálculos são executados apenas na região da bacia hidrográfica
                if self.global_vars.bacia[lin][col] == 1:
                    # ARPlidar
                    if self.global_vars.numcabe[lin][col] > 0:
                        self.global_vars.numcabeaux = self.global_vars.numcabe[lin][col]
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.linaux2 = lin
                        self.global_vars.colaux2 = col
                        self.global_vars.linaux3 = lin
                        self.global_vars.colaux3 = col
                        self.global_vars.numtreaux = 0
                        self.global_vars.caminho = 0
                        self.global_vars.usaux = self.global_vars.usosolo[lin][col]
                        self.global_vars.usaux2 = self.global_vars.usaux

                        # Grava a distância do píxel relativo ao trecho
                        self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.DIST[lin][col] - self.global_vars.DISTult[self.global_vars.numcabeaux][1]

                        # ARPdecliv: calcula a declividade do píxel relativo ao último píxel do trecho
                        c1 = (self.global_vars.MDE[self.global_vars.linaux2][self.global_vars.colaux2] - self.global_vars.cotafim[self.global_vars.numcabeaux][1])
                        d1 = self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2]*1000.0 
                        self.global_vars.DECLIVpix[[self.global_vars.linaux2][self.global_vars.colaux2]] = c1 / d1

                        # Grava qual cabeceira o píxel em questão faz parte
                        self.global_vars.CABEpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numcabeaux

                        while self.global_vars.caminho == 0:
                            self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                            self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                            self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]
                            
                            if condicao1 or condicao2:
                                # Mudou o tipo de uso do solo ou alcançou a rede de drenagem, 
                                # então terminou um trecho no píxel anterior
                                self.global_vars.numtreaux += 1
                                self.global_vars.numtre[self.global_vars.numtreaux] = self.global_vars.numtreaux
                                
                                # Grava a distância do píxel relativo ao trecho
                                self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux] = self.global_vars.DIST[self.global_vars.linaux][self.global_vars.colaux] - self.global_vars.DISTult[self.global_vars.numcabeaux][self.global_vars.numcabeaux + 1]

                                self.global_vars.usotre[self.global_vars.numcabeaux][self.global_vars.numcabeaux] = self.global_vars.usaux

                                # ARPlidar: adiciona a bacia hidrográfica como uma condição
                                if self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] ==1 or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux] == 1:
                                    self.global_vars.caminho = 1
                                else:
                                    # Vai continuar o caminho, porém em um novo trecho
                                    self.global_vars.linaux3 = self.global_vars.linaux
                                    self.global_vars.colaux3 = self.global_vars.colaux
                                    self.global_vars.linaux2 = self.global_vars.linaux
                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                                    # Grava qual cabeceira o píxel em questão faz parte
                                    self.global_vars.CABEpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numcabeaux

                                    # Calcula a declividade do píxel relativo ao último píxel do trecho
                                    e1 = self.global_vars.MDE[self.global_vars.linaux2][self.global_vars.colaux2] - self.global_vars.cotafim[self.global_vars.numcabeaux][self.global_vars.numcabeaux + 1] 
                                    f1 = self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2]*1000.0
                                    self.global_vars.DECLIVpix[self.global_vars.linaux2][self.global_vars.colaux2] = e1 / f1

                            else:
                                # Vai continuar caminhando, e grava os valores dos pares (nlin,ncol) do último píxel que passou           
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux
                                self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                                # Grava qual cabeceira o píxel em questão pertence
                                self.global_vars.CABEpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numcabeaux

                                # Grava a DIST do píxel relativo ao trecho
                                self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.DIST[self.global_vars.linaux2][self.global_vars.colaux2] \
                                                                                                               - self.global_vars.DISTult[self.global_vars.numcabeaux][self.global_vars.numcabeaux + 1]

                                # ARPdecliv: Calcula a declividade o píxel relativo ao último píxel do trecho  
                                g1 = self.global_vars.MDE[self.global_vars.linaux2][self.global_vars.colaux2] - self.global_vars.cotafim[self.global_vars.numcabeaux][self.global_vars.numcabeaux + 1]
                                h1 = self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2]*1000.0
                                self.global_vars.DECLIVpix[self.global_vars.linaux2][self.global_vars.colaux2] =  g1/h1
        
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Os cálculo são realizados apenas na região da baica hidrográficia 
                if self.global_vars.bacia[lin][col] == 1:
                    # ARPlidar
                    if self.global_vars.numcabe[lin][col] > 0:
                        self.global_vars.numcabeaux = self.global_vars.numcabe[lin][col]
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.linaux2 = lin
                        self.global_vars.colaux2 = col
                        self.global_vars.linaux3 = lin
                        self.global_vars.colaux3 = col
                        self.global_vars.numtreaux = 0
                        self.global_vars.caminho = 0
                        self.global_vars.usaux = self.global_vars.usosolo[lin][col]
                        self.global_vars.usaux2 = self.global_vars.usaux

                        # ARPdecliv
                        self.global_vars.numtreaux2 = 1

                        # Para o cálculo da média aritmética
                        self.global_vars.Somaaux[self.global_vars.numcabeaux][self.global_vars.numcabeaux2] += self.global_vars.DECLIVpix[lin][col]
                        self.global_vars.contaaux[self.global_vars.numcabeaux][self.global_vars.numcabeaux2] = self.global_vars.Somaaux[self.global_vars.numcabeaux][self.global_vars.numcabeaux2] + 1

                        # Para o cálculo da média ponderada
                        self.global_vars.Somaauxpond[self.global_vars.numcabeaux][self.global_vars.numcabeaux2] += self.global_vars.DECLIVpix[lin][col] * self.global_vars.DISTtre[lin][col]
                        self.global_vars.SomaauxDist[self.global_vars.numcabeaux][self.global_vars.numcabeaux2] += self.global_vars.DISTtre[lin][col]

                        while self.global_vars.caminho == 0:
                            self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                            self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                            self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]
                            

                            if condicao1 or condicao2:
                                # Mudou o tipo de uso do solo ou alcançou a rede de drenagem, 
                                # então terminou um trecho no píxel anterior
                                self.global_vars.numtreaux += 1
                                 # ARPlidar: adiciona a bacia hidrográfica como uma condição
                                if self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] ==1 or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux] == 1:
                                    self.global_vars.caminho = 1
                                else:
                                    # Vai continuar o caminho, porém em um novo trecho
                                    self.global_vars.linaux3 = self.global_vars.linaux
                                    self.global_vars.colaux3 = self.global_vars.colaux
                                    self.global_vars.linaux2 = self.global_vars.linaux
                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                                    # ARPdecliv: grava qual trecho o píxel em questão pertence
                                    self.global_vars.numtreaux2 += 1

                                    # ARPdecliv: para a média aritmética
                                    self.global_vars.Somaaux[self.global_vars.numcabeaux][self.global_vars.numcabeaux2] += self.global_vars.DECLIVpix[self.global_vars.linaux][self.global_vars.colaux]
                                    self.global_vars.contaaux[self.global_vars.numcabeaux][self.global_vars.numcabeaux2] += 1

                                    # ARPdecliv: para a média ponderada
                                    self.global_vars.Somaauxpond[self.global_vars.numcabeaux][self.global_vars.numcabeaux2] += self.global_vars.DECLIVpix[self.global_vars.linaux][self.global_vars.colaux] * self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux]
                                    self.global_vars.SomaauxDist[self.global_vars.numcabeaux][self.global_vars.numcabeaux2] += self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux]
                            
                            else:
                                # Vai continuar caminhando, e grava os valores dos pares (nlin,ncol) do último píxel que passou           
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux
                                self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]


                                # ARPdecliv: para a média aritmética
                                self.global_vars.Somaaux[self.global_vars.numcabeaux][self.global_vars.numcabeaux2] += self.global_vars.DECLIVpix[self.global_vars.linaux][self.global_vars.colaux]
                                self.global_vars.contaaux[self.global_vars.numcabeaux][self.global_vars.numcabeaux2] += 1

                                # ARPdecliv: para a média ponderada
                                self.global_vars.Somaauxpond[self.global_vars.numcabeaux][self.global_vars.numcabeaux2] += self.global_vars.DECLIVpix[self.global_vars.linaux][self.global_vars.colaux] * self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux]
                                self.global_vars.SomaauxDist[self.global_vars.numcabeaux][self.global_vars.numcabeaux2] += self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux]
                            
        # Escrevendo o arquivo de análise dos trechos
        with open('analise_declividades_trechos.txt', 'w') as arquivo_txt:
            # Escrevendo o cabeçalho do arquivo: formatação deve ser precisa!
            arquivo_txt.write('{:<14}{:<14}{:<14}{:<14}{:<14}\n'.format('Num_pixel', 'Num_trecho', 'Decliv_1', 'Decliv_2', 'Decliv_3'))
            
            for self.global_vars.numcabeaux in range(self.global_vars.Ncabec):
                self.global_vars.numcabeaux = self.global_vars.numtre[self.global_vars.numcabeaux]

                for t in range(self.global_vars.numtreaux):
                    self.global_vars.Streaux = self.global_vars.Somaaux[self.global_vars.numcabeaux][t] / self.global_vars.contaaux[self.global_vars.numcabeaux][t]
                    self.global_vars.Streaux2 = self.global_vars.Somaauxpond[self.global_vars.numcabeaux][t] / self.global_vars.SomaauxDist[self.global_vars.numcabeaux][t]
                    # Escrevendo as linhas do arquivo conforme os valores das variáveis
                    arquivo_txt.write('{:<14}{:<14}{:<14.4f}{:<14.4f}{:<14.4f}\n'.format(self.global_vars.numcabeaux, t, self.global_vars.Stre[self.global_vars.numcabeaux][t], self.global_vars.Streaux, self.global_vars.Streaux2))

                    if self.global_vars.tipo_decliv == 3:
                        self.global_vars.Stre[self.global_vars.numcabeaux][t] = self.global_vars.Streaux
                    elif self.global_vars.tipo_decliv == 2:
                        self.global_vars.Stre[self.global_vars.numcabeaux][t] = self.global_vars.Streaux2
    
    def tempo_canal(self):
        '''
        Esta função é responsável por determinar o tempo de derlocamento da foz até o exutório da bacia hidrográfica
        '''
        condicao = None
        condicao2 = None
        self.classerio_aux = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # O cáclulos são executados apenas na região da bacia
                if self.global_vars.bacia[lin][col] == 1:
                    # ainda, os cálculos acontecerão na rede de drenagem da bacia hidrográfica
                    if  self.global_vars.dren[lin][col] == 1:
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.linaux1 = lin
                        self.global_vars.colaux1 = col
                        self.global_vars.linaux2 = lin
                        self.global_vars.colaux2 = col
                        self.global_vars.caminho = 0
                        self.global_vars.Tempoauxac = 0

                        # Guarda as características do tipo de trecho que o píxel em questão faz parte
                        self.classerio_aux = self.global_vars.classerio[lin][col]

                        while self.global_vars.caminho == 0:
                            condicao = self.global_vars.linaux < 1 or self.global_vars.linaux > self.rdc_vars.nlin or self.global_vars.colaux < 1 or self.global_vars.colaux > self.rdc_vars.ncol    
                            
                            if condicao:
                                self.global_vars.caminho = 1

                                # Contabilizando o último trecho
                                self.global_vars.Lfozaux1 = self.Lfoz[self.global_vars.linaux1][self.global_vars.colaux1]
                                self.global_vars.Lfozaux2 = self.Lfoz[self.global_vars.linaux2][self.global_vars.colaux2]
                                # Determina a diferença entre o píxel do Lfoz inicial e o do final
                                self.global_vars.Laux = self.global_vars.Lfozaux1 - self.global_vars.Lfozaux2
                                
                                # A declividade(Saux), o coeficiente de Manning(naux) e o raio hidráulico(Rhaux) são aqueles do tipo de rio (rede de drenagem)
                                self.global_vars.Saux = self.global_vars.Sclasse[self.classerio_aux]
                                self.global_vars.naux = self.global_vars.Mannclasse[self.classerio_aux]
                                self.global_vars.Rhaux = self.global_vars.Rhclasse[self.classerio_aux]

                                # Determinando a velocidade do percurso
                                condicao1 = self.global_vars.linaux2 == self.global_vars.linaux and self.global_vars.colaux2 == self.global_vars.colaux1
                                if condicao1:
                                    self.global_vars.Velaux = 0
                                    self.global_vars.Tempoaux = 0
                                else:
                                    self.global_vars.Velaux = self.global_vars.Rhaux ** (2.0/3.0)*self.global_vars.Saux**(1.0/2.0)/self.global_vars.naux
                                    
                                    # Calculando o tempo de deslocamento do percuso em min 
                                    # em que: Laux em metros e Velaux em m/s; resultado em min
                                    self.global_vars.Tempoaux = self.global_vars.Laux / self.global_vars.Velaux / 60.0
                                
                                # O tempo é acocumulado desde o primeiro percurso
                                self.global_vars.Tempoauxac += self.global_vars.Tempoaux
                            
                                # Após o fim do traçado desde o inicío do píxel, o tempo será armazenado e o acumulador zerado
                                self.global_vars.TempoRio[lin][col] = self.global_vars.Tempoauxac
                                self.global_vars.Tempoauxac = 0
                        
                            else:
                                condicao2 = self.global_vars.classerio[self.global_vars.linaux][self.global_vars.colaux] != self.classerio_aux
                                # Checando se o caminho ainda está no trecho de mesma classe
                                if condicao2:
                                    self.global_vars.Lfozaux1 = self.Lfoz[self.global_vars.linaux1][self.global_vars.colaux1]
                                    self.global_vars.Lfozaux2 = self.Lfoz[self.global_vars.linaux2][self.global_vars.colaux2]
                                    # Determina a diferença entre o píxel do Lfoz inicial e o do final
                                    self.global_vars.Laux = self.global_vars.Lfozaux1 - self.global_vars.Lfozaux2
                                    
                                    # A declividade(Saux), o coeficiente de Manning(naux) e o raio hidráulico(Rhaux) são aqueles do tipo de rio (rede de drenagem)
                                    self.global_vars.Saux = self.global_vars.Sclasse[self.classerio_aux]
                                    self.global_vars.naux = self.global_vars.Mannclasse[self.classerio_aux]
                                    self.global_vars.Rhaux = self.global_vars.Rhclasse[self.classerio_aux]

                                    # Determinando a velocidade do percurso
                                    condicao1 = self.global_vars.linaux2 == self.global_vars.linaux and self.global_vars.colaux2 == self.global_vars.colaux1
                                    if condicao1:
                                        self.global_vars.Velaux = 0
                                        self.global_vars.Tempoaux = 0
                                    else:
                                        self.global_vars.Velaux = self.global_vars.Rhaux ** (2.0/3.0)*self.global_vars.Saux**(1.0/2.0)/self.global_vars.naux
                                        
                                        # Calculando o tempo de deslocamento do percuso em min 
                                        # em que: Laux em metros e Velaux em m/s; resultado em min
                                        self.global_vars.Tempoaux = self.global_vars.Laux / self.global_vars.Velaux / 60.0
                                    
                                    # O tempo é acocumulado desde o primeiro percurso
                                    self.global_vars.Tempoauxac += self.global_vars.Tempoaux

                                    # Atualizando o novo ponto de partida
                                    self.global_vars.linaux1 = self.global_vars.linaux
                                    self.global_vars.colaux1 = self.global_vars.colaux
                                    self.classerio_aux = self.global_vars.classerio[self.global_vars.linaux1][self.global_vars.colaux1]
                                
                                # Armazenando o píxel contabilizado
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux  

                                # Deteminando o próximo píxel do caminho
                                self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                                self.global_vars.caminho = 0 
                                self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                                self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]
    def tempo_sup(self):
        """
        Esta função função determina o tempo de concentração/escoamento para os píxels da superfície da rede de drenagem (aqueles que não são canais)
        """
        for lin in range(self.rdc_vars.nlin):
            for col in range(self.global_vars):
                if self.global_vars.Ncabec[lin][col] > 0:
                    self.global_vars.numcabeaux = self.global_vars.numcabe[lin][col]
                    self.global_vars.lincabe[self.global_vars.numcabeaux] = lin
                    self.global_vars.colcabe[self.global_vars.numcabeaux] = col


        for self.global_vars.numcabeaux in range(self.global_vars.Ncabec):
            self.global_vars.numtreaux = self.global_vars.numtre[self.global_vars.numcabeaux]

            for t in range(self.global_vars.numtreaux):
                self.global_vars.usaux = self.global_vars.numtre[self.global_vars.numcabeaux][t]
                self.global_vars.Ltreaux = self.global_vars.Ltre[self.global_vars.numcabeaux][t]
                self.global_vars.Streaux = self.global_vars.Stre[self.global_vars.numcabeaux][t] 

                if self.global_vars.Streaux > 0:
                    # Determinando o Ts
                    self.global_vars.TS[self.global_vars.numcabeaux][t] = 5.474 * ((self.global_vars.Mann[self.global_vars.usaux]*self.global_vars.Ltreaux)**0.8)/((self.global_vars.P24**0.5)*((self.global_vars.Streaux/1000.0)**0.4))
                else:
                    self.global_vars.TS[self.global_vars.numcabeaux][t] = 0
                
                self.global_vars.TScabe[self.global_vars.numcabeaux] += self.global_vars.TS[self.global_vars.numcabeaux][t]
            
            lin1 = self.global_vars.lincabe[self.global_vars.numcabeaux]
            col1 = self.global_vars.colcabe[self.global_vars.numcabeaux]
            self.global_vars.TScabe2d[lin1][col1] = self.global_vars.TScabe[self.global_vars.numcabeaux]
        
        for lin in range(self.rdc_vars.nlin):
            for col in range(self.rdc_vars.ncol):
                # As ações são baseadas na região da bacia hidrográfica
                if self.global_vars.bacia[lin][col]:
                    self.global_vars.numcabeaux = self.global_vars.CABEpix[lin][col]
                    self.global_vars.Taux = 0

                    # Verificando se o píxel é válido e executando cabeceiras
                    if self.global_vars.numcabeaux > 0 and self.global_vars.numcabe[lin][col] == 0:
                        
                        self.global_vars.t = self.global_vars.refcabtre[lin][col]
                        self.global_vars.Ltreaux = self.global_vars.Ltre[self.global_vars.numcabeaux][self.global_vars.t]
                        self.global_vars.Ttreaux = self.global_vars.TS[self.global_vars.numcabeaux][self.global_vars.t]
                        self.global_vars.DISTtreaux = self.global_vars.DISTtre[lin][col]
                        # Subtipodecliv='a'
                        self.global_vars.Taux = self.global_vars.DISTtreaux * self.global_vars.Ttreaux / self.global_vars.Ltreaux

                        # ARPdecliv
                        if self.global_vars.subtipodecliv == 'b':
                            self.global_vars.Streaux = self.global_vars.Stre[self.global_vars.numcabeaux][t]
                            self.global_vars.usaux = self.global_vars.usotre
                            
                            if self.global_vars.Streaux > 0:
                                self.global_vars.Taux = 5.474 * ((self.global_vars.Mann[self.global_vars.usaux] * self.global_vars.DISTtreaux)**0.8) / ((self.global_vars.P24**0.5)*((self.global_vars.Streaux / 1000.0)**0.4))
                            else:
                                self.global_vars.Taux = 0

                        self.global_vars.numtreaux = self.global_vars.numtre[self.global_vars.numcabeaux]

                        if self.global_vars.t < self.global_vars.numtreaux:
                            tt = self.global_vars.t + 1
                            for tt in range(self.global_vars.numtreaux):
                                self.global_vars.Taux += self.global_vars.TS[self.global_vars.numcabeaux][tt]
                        
                        self.global_vars.TSnaocabe2d[lin][col] = self.global_vars.Taux

        self.global_vars.TStodos2d = self.global_vars.TSnaocabe2d + self.global_vars.TScabe2d
        if self.global_vars.tipo_decliv == 4:
            # zerando as variáveis usadas
            self.global_vars.TSnaocabe2d = None
            self.global_vars.TStodos2d = None
            self.global_vars.TScabe2d = None
            self.global_vars.TScabe = None

            for col in range(self.rdc_vars.ncol):
                for lin in range(self.rdc_vars.nlin):
                    # Exclindo a região fora da bacia
                    self.global_vars.linaux = lin
                    self.global_vars.colaux = col
                    self.global_vars.caminho = 0 
                    self.global_vars.tempocam = 0.0
                    
                    # Para píxels que representam a rede de drenagem
                    if self.global_vars.dren[lin][col]== 1:
                        self.global_vars.caminho = 1
                    else:
                        while self.global_vars.caminho == 0:
                            condicao = self.global_vars.linaux <= 1 or self.global_vars.linaux >=self.rdc_vars.nlin or self.global_vars.colaux <= 1 or self.global_vars.colaux >=self.rdc_vars.nlin
                            if condicao:
                                self.global_vars.caminho = 1
                            else:
                                if self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux]:
                                    # Alcançou a rede de drenagem: encerra a busca
                                    self.global_vars.caminho = 1
                                    self.global_vars.TSpixacum[lin][col] = self.global_vars.tempocam
                                else:
                                    self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                                    self.global_vars.caminho = 0

                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.linaux2 = self.global_vars.linaux
                                    # Calculando a distância incremental percorrida
                                    self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                                    self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]

                                    # Atualizando o tempo de escoamento desde o píxel inicial
                                    self.global_vars.tempocam += self.global_vars.TSpix[self.global_vars.linaux2][self.global_vars.colaux2]

    def tempo_total(self):
        '''
        Esta função determina o tempo total de escoamento (tempo de concentração) da bacia hidrográfica
        '''
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Os procedimentos são realizados ao longo da bacia hidrográfica
                if self.global_vars.bacia[lin][col] == 1:
                    # Ainda, as verificaçãoes seão baseadas na rede de drenagem
                    if self.global_vars.dren[lin][col] == 1:
                        self.global_vars.TempoTot[lin][col] = self.global_vars.TempoRio[lin][col]
                    else:
                        # ARPlidar
                        self.global_vars.pixel_ref_dren = self.global_vars.pixeldren[lin][col]
                        self.global_vars.ll = self.global_vars.lincontadren[self.global_vars.pixel_ref_dren]
                        self.global_vars.cc = self.global_vars.colcontadren[self.global_vars.pixel_ref_dren]
                        self.global_vars.auxTempoCanal = self.global_vars.TempoRio[self.global_vars.ll][self.global_vars.cc]
                    
                    if self.global_vars.tipo_decliv == 4:
                        self.global_vars.TempoTot[lin][col] = self.global_vars.TSpixacum[lin][col] + self.global_vars.auxTempoCanal

    def min_max(self):
        """
        Esta função determinar os limites das variáveis varMax e varMin 
        """
        self.rdc_vars.Varmax = -1.0e7
        self.rdc_vars.Varmin = 1.0e7

        if self.rdc_vars.tipoMM == 2:
            for col in range(self.rdc_vars.ncol3):
                for lin in range(self.rdc_vars.nlin3):
                    if self.rdc_vars.VarMM2[lin][col] > self.rdc_vars.Varmax:
                        self.rdc_vars.Varmax = self.rdc_vars.VarMM2[lin][col]
                    
                    elif self.rdc_vars.VarMM2[lin][col] < self.rdc_vars.Varmin:
                        self.rdc_vars.Varmin = self.rdc_vars.VarMM2[lin][col]

            for col in range(self.rdc_vars.ncol3):
                for lin in range(self.rdc_vars.nlin3):
                    if self.rdc_vars.VarMM3[lin][col][self.rdc_vars.i3] > self.rdc_vars.Varmax:
                        self.rdc_vars.Varmax = self.rdc_vars.VarMM3[lin][col][self.rdc_vars.i3]
                        
                    elif self.rdc_vars.VarMM3[lin][col][self.rdc_vars.i3] < self.rdc_vars.Varmin:
                        self.rdc_vars.Varmin = self.rdc_vars.VarMM3[lin][col][self.rdc_vars.i3]
    
    def tamanho_numero(self, varaux, num):
        '''Esta função determina quais sãos os maiores valores do raster em questão'''
        negativo = None
        nzeros = None
        pp = None
        varaux2 = None 
        limsup = None
        
        if varaux < 0:
            negativo = 1
        else:
            negativo = 0
        
        varaux2 = np.abs(varaux)
        
        for pp in range(11):
            limsup = 10.0**pp
            if varaux2 < limsup:
                nzeros = pp
                break
        # Se o valor for inteiro
        if num == 1:
            if nzeros == 0:
                self.global_vars.tamnum = 1 + negativo
            else:
                self.global_vars.tamnum = nzeros + negativo
        # Se o valor for real
        else:
            if nzeros == 0:
                self.global_vars.tamnum = 8 + 1 + negativo
            else:
                self.global_vars.tamnum = 8 + nzeros + negativo     

        return self.global_vars.tamnum

    def aux_RDC(self, file_, textoaux, varaux, tamnum):
        """
        Esta função é responsável por formatar as informações dos arquivos de saida do programa
        """
        if tamnum == 1:
            file_.write(f'{textoaux:14s}{varaux:1d}\n')
            return file_
        elif tamnum == 2:
            file_.write(f'{textoaux:14s}{varaux:2d}\n')
            return file_
        elif tamnum == 3:
            file_.write(f'{textoaux:14s}{varaux:3d}\n')
            return file_
        elif tamnum == 4:
            file_.write(f'{textoaux:14s}{varaux:4d}\n')
            return file_
        elif tamnum == 5:
            file_.write(f'{textoaux:14s}{varaux:5d}\n')
            return file_
        elif tamnum == 6:
            file_.write(f'{textoaux:14s}{varaux:7d}\n')
            return file_
        elif tamnum == 8:
            file_.write(f'{textoaux:14s}{varaux:8d}\n')
            return file_
        elif tamnum == 9:
            file_.write(f'{textoaux:14s}{varaux:9.7f}\n')
            return file_
        elif tamnum == 10:
            file_.write(f'{textoaux:14s}{varaux:10.7f}\n')
            return file_
        elif tamnum == 11:
            file_.write(f'{textoaux:14s}{varaux:11.7f}\n')
            return file_
        elif tamnum == 12:
            file_.write(f'{textoaux:14s}{varaux:12.7f}\n')
            return file_
        elif tamnum == 13:
            file_.write(f'{textoaux:14s}{varaux:13.7f}\n')
            return file_
        elif tamnum == 14:
            file_.write(f'{textoaux:14s}{varaux:14.7f}\n')
            return file_
        elif tamnum == 15:
            file_.write(f'{textoaux:14s}{varaux:15.7f}\n')
            return file_
        elif tamnum == 16:
            file_.write(f'{textoaux:14s}{varaux:16.7f}\n')
            return file_
        elif tamnum == 17:
            file_.write(f'{textoaux:14s}{varaux:17.7f}\n')
            return file_
        elif tamnum == 18:
            file_.write(f'{textoaux:14s}{varaux:18.7f}\n')
            return file_
        elif tamnum == 19:
            file_.write(f'{textoaux:14s}{varaux:19.7f}\n')
            return file_

    def escreve_RDC(self, nome_RST):
        """
        Esta função constrói os arquivos de saída das diferentes funcionalidades do programa
        """
        # Identifica a posição da extensão no arquivo .rst
        pos_ext = nome_RST.find('.rst')

        # Atribui o nome do arquivo .rst ao novo arquivo .rdc
        nome_rdc = nome_RST[:pos_ext] + '.rdc'

        # Abrindo o arquivo 
        with open(nome_rdc, 'w') as rdc_file:
            # Escreve linha com formato do arquivo
            rdc_file.write(f'file format : IDRISI Raster A.1\n')
            # Escreve linha com o título do arquivo
            rdc_file.write(f'File title  : \n')

            # Escreve linha com tipo de dado
            if self.rdc_vars.tipo_dado == 1:
                rdc_file.write(f'data type   : integer\n')
            elif self.rdc_vars.tipo_dado == 2:
                rdc_file.write(f'data type   : real\n')

            # Escreve a linha com o tipo de arquivo
            rdc_file.write(f'file type   : binary\n')

            # Escreve a linha com o número de colunas
            self.global_vars.varaux = self.rdc_vars.ncol3
            self.rdc_vars.num = 1
            textoaux = 'columns     : ' 
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux, self.global_vars.varaux, tamnum)

            # Escreve a linha com o número de linhas
            self.global_vars.varaux = self.rdc_vars.nlin3
            self.rdc_vars.num = 1 # num = 1 : integer
            textoaux = 'rows        : ' 
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux, self.global_vars.varaux, tamnum)

            # Escreve a linha com o sistema de referência
            rdc_file.write(f'ref. system : {self.rdc_vars.sistemaref}\n')

            # Escreve a linha com a unidade de referência
            if self.global_vars.metro == 1:
                rdc_file.write(f'ref. units  : m\n')
            else:
                rdc_file.write(f'ref. units  : deg\n')
            
            # Escreve linha com distância unitária de referência
            rdc_file.write(f'unit dist.  : {1.0:<9.7f}\n')

            # Escreve a linha com o valor mínimo dos dados
            self.global_vars.varaux = self.rdc_vars.Varmin
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'min. value  : '
            tamnum = self.global_vars.tamnum(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux,self.global_vars.varaux, tamnum)

            # Escreve a linha com o valor máximo dos dados
            self.global_vars.varaux = self.rdc_vars.Varmax
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'max. value  : '
            tamnum = self.global_vars.tamnum(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux,self.global_vars.varaux, tamnum)

            # Escreve a linha com o valor mínimo de exebição
            self.global_vars.varaux = self.rdc_vars.Varmin
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'display min : '
            tamnum = self.global_vars.tamnum(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux,self.global_vars.varaux, tamnum) 

            #  Escreve a linha com o valor máximo para exibição 
            self.global_vars.varaux = self.rdc_vars.Varmax
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'display max : '
            tamnum = self.global_vars.tamnum(self.global_vars.varaux, self.rdc_vars.num)
            self.aux_RDC(rdc_file, textoaux,self.global_vars.varaux, tamnum)

            # Escreve a linha com a unidade dos dados
            rdc_file.write(f'value units : unspecified\n')

            # Escreve a linha com o valor do erro dos dados
            rdc_file.write(f'value error : unknown\n')

            # Escreve a linha com a definição do sinalizador
            rdc_file.write(f'flag value  : {0:1d}\n')

            # Escreve a linha com o número de categorias da legenda
            rdc_file.write(f'legend cats : {0:1d}')

            # Escreve a linha sobre a criação da imagem
            rdc_file.write(f'lineage     : This file was created automatically by an ARP and JVD PYTHON program')
        
        return nome_rdc

    def escreve_comprimento_acumulado(self):
        """
        Esta função é responsável por formular os arquivos de saída (tanto o raster (.rst), quanto sua documentação (.rdc))
        para os dados referentes aos comprimentos da rede de drenagem da bacia hidrográfica
        """
        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        fn_comp_acum = 'ComprimAcu.rst'
        # Possivelmente será alterado, a depender dos resultados das variáveis Lac e Lfoz
        with open(fn_comp_acum, 'wb') as arquivo1:
            # Escrevendo o resultado do comprimento da rede de drenagem
            for lin in range(self.rdc_vars.nlin):
                dados_comp_acum = [float(self.global_vars.Lac[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo1.write(bytes(dados_comp_acum))

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.Lac)
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymin3 = self.rdc_vars.ymax
        nomeRST = fn_comp_acum
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)

        # Escrevendo o resultado do comprimento da rede de drenagem
        fn_comp_foz = 'ComprimFoz.rst'
        with open(fn_comp_foz, 'wb') as arquivo2:
            for lin in range(self.rdc_vars.nlin):
                dados_comp_foz = [float(self.global_vars.Lfoz[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo2.write(bytes(dados_comp_foz))
        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da foz da bacia hidrográfica
        self.global_vars.VarMM2 = float(self.global_vars.Lfoz)
        nomeRST = fn_comp_foz
        self.escreve_RDC(nomeRST)

    def escreve_conectividade(self):
        """
        Esta função é responsável por formular os arquivos de saída (tanto o raster (.rst), quanto sua documentação (.rdc))
        para os dados referentes ao mapa de conectividade das cabeceiras da bacia hidrográfica
        """
        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        fn_cab_pix = 'CABEpix.rst'
        # Possivelmente será alterado, a depender dos resultados das variáveis Lac e Lfoz
        with open(fn_cab_pix, 'wb') as arquivo1:
            # Escrevendo o resultado do comprimento da rede de drenagem
            for lin in range(self.rdc_vars.nlin):
                dados_cab_pix = [float(self.global_vars.CABEpix[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo1.write(bytes(dados_cab_pix))

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.CABEpix)
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymin3 = self.rdc_vars.ymax
        nomeRST = fn_cab_pix
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)

        # Escrevendo o resultado do mapa de conectividade dos pixels da superficie a rede de drenagem
        fn_n_conect_dren = 'num_conexao_drenagem.rst'
        with open(fn_n_conect_dren, 'wb') as arquivo2:
            for lin in range(self.rdc_vars.nlin):
                dados_n_conect_dren = [float(self.global_vars.pixeldren[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo2.write(bytes(dados_n_conect_dren))
        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da foz da bacia hidrográfica
        self.global_vars.VarMM2 = float(self.global_vars.pixeldren)
        nomeRST = fn_n_conect_dren
        self.escreve_RDC(nomeRST)

    def escreve_dados_trecho(self):
        # Esta função escreve os dados de saída referentes aos diferentes trechos dos canais da bacia hidrográfica
        with open('dados_trechos_superf.txt') as arquivo_txt:
            arquivo_txt.write('{:<10}{:<6}{:<6}{:<10}{:<10}{:<12}{:<6}\n'.format('Cabeceira', 'Trecho', 'L(m)', 'Z_ini(m)', 'Z_fim(m)','Decliv(m/km)', 'Uso'))
            
            for self.global_vars.numcabeaux in range(self.global_vars.Ncabec):
                self.global_vars.numcabeaux = self.global_vars.numtre[self.global_vars.numcabeaux]

            for t in range(self.global_vars.numtreaux):
                if self.global_vars.usotre[self.global_vars.numcabeaux][t] == 0:
                        result = f"Press OK to continue..."
                        reply = QMessageBox.warning(None, "Zero Value", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Ok:
                            pass
                        
                # Escrevendo as linhas do arquivo conforme os valores das variáveis
                arquivo_txt.write('{:<10}{:<6}{:<10.2f}{:<10.2f}{:<10.2f}{:<12.6f}{:<6}\n'.format(self.global_vars.numcabeaux, t, self.global_vars.Ltre[self.global_vars.numcabeaux][t], self.global_vars.cotaini[self.global_vars.numcabeaux][t], self.global_vars.cotafim[self.global_vars.numcabeaux][t],\
                                                                                    self.global_vars.Stre[self.global_vars.numcabeaux][t],self.global_vars.usotre[self.global_vars.numcabeaux][t]))

    def escreve_declivi_pixel(self):
        '''Esta função gera o mapa de numeração dos pixels da rede de drenagem'''
        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        fn_decli_pix = 'decliv_pixel.rst'
        # Possivelmente será alterado, a depender dos resultados das variáveis Lac e Lfoz
        with open(fn_decli_pix, 'wb') as arquivo1:
            # Escrevendo o resultado do comprimento da rede de drenagem
            for lin in range(self.rdc_vars.nlin):
                dados_decli_pix = [float(self.global_vars.decliv_pixel[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo1.write(bytes(dados_decli_pix))

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.decliv_pixel)
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymin3 = self.rdc_vars.ymax
        nomeRST = fn_decli_pix
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)

    def escreve_decliv_pixel_jus(self):
        '''Esta função gera o mapa de numeração dos pixels jusantes da rede de drenagem'''
        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        fn_decli_pix_jus = 'decliv_pixel_jus.rst'
        # Possivelmente será alterado, a depender dos resultados das variáveis Lac e Lfoz
        with open(fn_decli_pix_jus, 'wb') as arquivo1:
            # Escrevendo o resultado do comprimento da rede de drenagem
            for lin in range(self.rdc_vars.nlin):
                dados_decli_pix_jus = [float(self.global_vars.decliv_pixel_jus[lin][col]) for col in range(self.rdc_vars.ncol)] #'''AQUIII'''
                arquivo1.write(bytes(dados_decli_pix_jus))

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.decliv_pixel_jus)
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymin3 = self.rdc_vars.ymax
        nomeRST = fn_decli_pix_jus
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)
    
    def escreve_dist_rel_trechos(self):
        '''Esta função gera o arquivo com as distânicas relativas dentro do trecho'''
        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        fn_dist_rel_tre = 'DISTtre.rst'
        # Possivelmente será alterado, a depender dos resultados das variáveis Lac e Lfoz
        with open(fn_dist_rel_tre, 'wb') as arquivo1:
            # Escrevendo o resultado do comprimento da rede de drenagem
            for lin in range(self.rdc_vars.nlin):
                dados_dist_rel_tre = [float(self.global_vars.DISTtre[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo1.write(bytes(dados_dist_rel_tre))

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.DISTtre)
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymin3 = self.rdc_vars.ymax
        nomeRST = fn_dist_rel_tre
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)

    def escreve_num_pix_cabec(self):
        '''Esta função escreve a numeração das cabeceiras'''
        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        fn_num_cab = 'NUM_CABECEIRAS.rst'
        # Possivelmente será alterado, a depender dos resultados das variáveis Lac e Lfoz
        with open(fn_num_cab , 'wb') as arquivo1:
            # Escrevendo o resultado do comprimento da rede de drenagem
            for lin in range(self.rdc_vars.nlin):
                dados_num_cab = [float(self.global_vars.numcabe[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo1.write(bytes(dados_num_cab))

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.numcabe)
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymin3 = self.rdc_vars.ymax
        nomeRST = fn_num_cab 
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)

    def escreve_num_pix_drenagem(self):
        '''Esta função gera o mapa de numeração dos píxels da rede de drenagem'''
        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        fn_num_pix_dren = 'num_pixels_drenagem.rst'
        # Possivelmente será alterado, a depender dos resultados das variáveis Lac e Lfoz
        with open(fn_num_pix_dren, 'wb') as arquivo1:
            # Escrevendo o resultado do comprimento da rede de drenagem
            for lin in range(self.rdc_vars.nlin):
                dados_num_pix_dren = [float(self.global_vars.contadren[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo1.write(bytes(dados_num_pix_dren))

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 1
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.contadren)
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymin3 = self.rdc_vars.ymax
        nomeRST = fn_num_pix_dren 
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)

    def escreve_num_trechos(self):
        '''Esta função escreve a numeração dos trechos'''
        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        fn_num_tre = 'num_pixels_drenagem.rst'
        # Possivelmente será alterado, a depender dos resultados das variáveis Lac e Lfoz
        with open(fn_num_tre, 'wb') as arquivo1:
            # Escrevendo o resultado do comprimento da rede de drenagem
            for lin in range(self.rdc_vars.nlin):
                dados_num_tre = [float(self.global_vars.refcabtre[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo1.write(bytes(dados_num_tre))

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 1
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.refcabtre)
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymin3 = self.rdc_vars.ymax
        nomeRST = fn_num_tre 
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)
    
    def escreve_tempo_canal(self):
        '''Esta função escreve os dados referentes aos cálculos do tempo de concentração para os canais da rede de drenagem da 
            bacia hidrográfica'''
        self.global_vars.TempoRioR = float(self.global_vars.TempoRio)

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        fn_temp_canal = 'TempoCanal.rst'
        # Possivelmente será alterado, a depender dos resultados das variáveis Lac e Lfoz
        with open(fn_temp_canal, 'wb') as arquivo1:
            # Escrevendo o resultado do comprimento da rede de drenagem
            for lin in range(self.rdc_vars.nlin):
                dados_temp_canal = [float(self.global_vars.TempoRioR[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo1.write(bytes(dados_temp_canal))

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.TempoRioR)
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymin3 = self.rdc_vars.ymax
        nomeRST = fn_temp_canal
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)

    def escreve_tempo_sup(self):
        '''Esta função constrói o mapa dos tempos de deslocamento da água para os píxel de superfícies'''
        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        fn_temp_sup = 'TempoSup_por_cabeceira.rst'
        with open(fn_temp_sup, 'wb') as arquivo1:
            # Escrevendo o resultado do comprimento da rede de drenagem
            for lin in range(self.rdc_vars.nlin):
                dados_temp_sup = [float(self.global_vars.TScabe2d[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo1.write(bytes(dados_temp_sup))

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.TScabe2d)
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymin3 = self.rdc_vars.ymax
        nomeRST = fn_temp_sup
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)

        # TempoS de deslocamento no mapa - píxels não fazem parte da cabeceira
        fn_temp_sup_Ncabe = 'TempoSup_nao_de_cabeceira.rst'
        with open(fn_temp_sup_Ncabe, 'wb') as arquivo2:
        # Escrevendo o resultado do comprimento da rede de drenagem
            for lin in range(self.rdc_vars.nlin):
                dados_temp_sup_Ncabe = [float(self.global_vars.TSnaocabe2d[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo2.write(bytes(dados_temp_sup_Ncabe))

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem    
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.TSnaocabe2d)   
        nomeRST = fn_temp_sup_Ncabe
        self.escreve_RDC(nomeRST)

        # TempoS de deslocamento no mapa - todos os píxels
        fn_temp_sup_td = 'TempoSup_todos.rst'
        with open(fn_temp_sup_td, 'wb') as arquivo3:
        # Escrevendo o resultado do comprimento da rede de drenagem
            for lin in range(self.rdc_vars.nlin):
                dados_temp_sup_td = [float(self.global_vars.TStodos2d[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo3.write(bytes(dados_temp_sup_td))

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem    
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.TStodos2d)   
        nomeRST = fn_temp_sup_td
        self.escreve_RDC(nomeRST)

    def escreve_tempo_total(self):
        '''Esta função gera o mapa de conectividade dos píxels de superfície da rede de drenagem'''
        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        fn_temp_total = 'TempoTotal.rst'
        with open(fn_temp_total, 'wb') as arquivo1:
            # Escrevendo o resultado do comprimento da rede de drenagem
            for lin in range(self.rdc_vars.nlin):
                dados_temp_total = [float(self.global_vars.TempoTot[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo1.write(bytes(dados_temp_total))

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.TempoTot)
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymin3 = self.rdc_vars.ymax
        nomeRST = fn_temp_total
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)

    def escreve_tre_cabec(self):
        '''Esta função gera o arquivo que possui as informações acerca dos trechos das cabeceiras'''
        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        fn_tre_cabec = 'relacao_trechos_cabec.txt'
        with open(fn_tre_cabec, 'w', encoding = 'utf-8') as arquivo_txt:
            arquivo_txt.write('{:<12}{:<12}'.format('Cabeceira', 'Num.trechos'))
            for self.global_vars.numcabeaux in range(self.global_vars.Ncabec):
                arquivo_txt.write(f'{self.global_vars.numcabeaux:12d}{self.global_vars.numtre[self.global_vars.numcabeaux]:12d}')
        return arquivo_txt
    
    def escreve_trecho_pixel(self):
        '''Esta função gera o mapa de conectividade das cabeceiras'''
        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        fn_tre_pix = 'TREpix.rst'
        with open(fn_tre_pix, 'wb') as arquivo1:
            for lin in range(self.rdc_vars.nlin):
                dados_tre_pix = [float(self.global_vars.TREpix[lin][col]) for col in range(self.rdc_vars.ncol)]
                arquivo1.write(bytes(dados_tre_pix))


        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 1
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.TREpix)
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymin3 = self.rdc_vars.ymax
        nomeRST = fn_tre_pix
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)
    
    def escreve_TS_pix_acum(self):
        '''Esta função gera os arquivos com os resultados para o tempo de concentração/escoamento'''
        # Atribuindo o nome do arquivo(fn : file name) para escrita dos resultados
        fn_temp_pix_jus = 'tempo_pixel_jus.rst'
        with open(fn_temp_pix_jus, 'wb') as arquivo1:
            for lin in range(self.rdc_vars.nlin):
                dados_temp_pix_jus = [float(self.global_vars.TSpix[lin][col] for col in range(self.rdc_vars.ncol))]
                arquivo1.write(bytes(dados_temp_pix_jus))
        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = float(self.global_vars.TSpix)
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymin3 = self.rdc_vars.ymax
        nomeRST = fn_temp_pix_jus
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)

        fn_temp_pix_jus_acum = 'tempo_pixel_jus_acum.rst'
        with open(fn_temp_pix_jus_acum, 'wb') as arquivo2:
            for lin in range(self.rdc_vars.nlin):
                dados_temp_pix_jus_acum = [float(self.global_vars.TSpixacum[lin][col] for col in range(self.rdc_vars.ncol))]
                arquivo2.write(bytes((dados_temp_pix_jus_acum)))

        self.global_vars.VarMM2 = float(self.global_vars.TSpixacum)
        nomeRST = fn_temp_pix_jus
        self.escreve_RDC(nomeRST)

    def save_buttons(self, line_edit):
        '''Esta função configura os botões da salvar (criar arquivo)'''
        # Seleciona o arquivo enviado pelo usuário
        while True:
            # Obtendo o caminho do arquivo a ser salvo usando um diálogo de arquivo
            file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "Text Files (*.txt)")
            if file_name:
                line_edit.setText(file_name)
                break
            else:
                # O usuário não solucionou um arquivo (um caminho para salvar o arquivo de saída)
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    break


    def save_to_file(self, page):
        '''Esta função gera o arquivo com as informações enviadas por meio do usuário por página
        Page: variável que identifica a página do arquivo que será escrito
                page == 1: Configurations;
                page == 2: Input Data;
                page == 3: Data Validation;
                page == 4: Run
        '''
        # Seleciona o arquivo enviado pelo usuário
        while True:
            if page == 1:
                # Obtendo o caminho do arquivo a ser salvo usando um diálogo de arquivo
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "ftt_configuration_page", "Text Files (*.txt)")
                # Verifica se o usuário selecionou um arquivo
                if file_name:
                    # Armazenará as informações da primeira página
                    with open(file_name, 'w', encoding ='utf-8') as arquivo_txt:
                        arquivo_txt.write('Flow Travel Time - Configuration\n')
                        arquivo_txt.write('\n')
                        arquivo_txt.write('Minimum slope surface travel time determination (m/km):\n')
                        arquivo_txt.write(f'=> {self.dlg_flow_tt.le_1_pg1.text()}\n')
                        arquivo_txt.write('Maximum slope for surface travel time determination (m/km):\n')
                        arquivo_txt.write(f'=> {self.dlg_flow_tt.le_2_pg1.text()}\n')
                        arquivo_txt.write('Orthogonal step for distance computation (dx):\n')
                        arquivo_txt.write(f'=> {self.dlg_flow_tt.le_3_pg1.text()}\n')
                        arquivo_txt.write('Diagonal step for distance computation (dx):\n')
                        arquivo_txt.write(f'=> {self.dlg_flow_tt.le_4_pg1.text()}\n')
                        arquivo_txt.write('\n')
                        arquivo_txt.write('Flow direction code: \n')
                        arquivo_txt.write(f'A = {self.dlg_flow_tt.le_5_pg1.text()}\n')
                        arquivo_txt.write(f'B = {self.dlg_flow_tt.le_6_pg1.text()}\n')
                        arquivo_txt.write(f'C = {self.dlg_flow_tt.le_7_pg1.text()}\n')
                        arquivo_txt.write(f'D = {self.dlg_flow_tt.le_8_pg1.text()}\n')
                        arquivo_txt.write(f'E = {self.dlg_flow_tt.le_9_pg1.text()}\n')
                        arquivo_txt.write(f'F = {self.dlg_flow_tt.le_10_pg1.text()}\n')
                        arquivo_txt.write(f'G = {self.dlg_flow_tt.le_11_pg1.text()}\n')
                        arquivo_txt.write(f'H = {self.dlg_flow_tt.le_12_pg1.text()}\n')
                        arquivo_txt.write('lineage: This file was created automatically by an ARP and JVD QGIS plugin')
                else:
                    # O usuário não solucionou um arquivo (um caminho para salvar o arquivo de saída)
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break
                # Encerra a chamada da tela de seleção de arquivo
                break

            elif page == 2:
                # Salva as informações fornecidas na página de input
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "ftt_input_data_page", "Text Files (*.txt)")        
                if file_name:
                        # Atribuindo o nome do arquivo(fn : file name) para escrita dos resultados da página 1
                        with open(file_name, 'w', encoding ='utf-8') as arquivo_txt:
                            arquivo_txt.write('Flow Travel Time - Input Data: \n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Watershed delineation:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_1_pg2.text()}\n')
                            arquivo_txt.write('Digital elevation model:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_2_pg2.text()}\n')
                            arquivo_txt.write('Flow direction (RDC and RST):\n')
                            linhas_text_edit = self.dlg_flow_tt.te_1_pg2.toPlainText()
                            linhas = linhas_text_edit.split('\n')
                            arquivo_txt.write(f'=> {linhas[0]}\n=> {linhas[1]}')
                            arquivo_txt.write('River drainage newtwork (RDN):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_3_pg2.text()}\n')
                            arquivo_txt.write('RDN segmentation into classes:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_4_pg2.text()}\n')
                            arquivo_txt.write('Characteristics of RDN classes:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_7_pg2.text()}\n')
                            arquivo_txt.write('Land use or land corver (LULC) map:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_5_pg2.text()}\n')
                            arquivo_txt.write('Manning roughness coeficient for each LULC:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_8_pg2.text()}\n')
                            arquivo_txt.write('Rainfall depth for 24-h duration:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_6_pg2.text()}\n')
                else:
                    # Caso o usuário não selecione um arquivo
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break
                # Encerra a chamada da tela de seleção de arquivo 
                break

            # elif page == 3:
                # Salva informações página de data validation

            elif page == 4:
                # Salva as informações fornecidas na página de run
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "ftt_run_page", "Text Files (*.txt)")
                if file_name:
                        # Atribuindo o nome do arquivo(fn : file name) para escrita dos resultados da página 1
                        with open(file_name, 'w', encoding ='utf-8') as arquivo_txt:
                            arquivo_txt.write('Flow Travel Time - Run page: \n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Numering pixels part of the river drainage network:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_1_pg4.text()}\n')
                            arquivo_txt.write('Areas draining directly to each pixel of the RDN:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_2_pg4.text()}\n')
                            arquivo_txt.write('Upstream flowpath length:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_3_pg4.text()}')
                            arquivo_txt.write('Downstream flowpath slope (m/m):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_4_pg4.text()}\n')
                            arquivo_txt.write('Downstream flowpath length:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_5_pg4.text()}\n')
                            arquivo_txt.write('Slope relative to downstream pixel:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_6_pg4.text()}\n')
                            arquivo_txt.write('Flow travel time (min):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_7_pg4.text()}\n')

                else:
                    # Caso o usuário não selecione um arquivo
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break
                # Encerra a chamada da tela de seleção de arquivo 
                break
    
    def read_from_file(self, page):
        '''Esta função é responsável por obter as informações a partir dos arquivos enviados pelo usuário
        Page: variável que identifica a página do arquivo que será escrito
                page == 1: Configurations;
                page == 2: Input Data;
                page == 3: Data Validation;
                page == 4: Run
        '''
        # Seleciona o arquivo enviado pelo usuário
        while True:
            options = QFileDialog.Options()
            directory = self.dlg_flow_tt.le_13_pg1.text()
            file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory = directory, filter="Text Files (*.txt)", options = options)
            cont = 0
            if page == 1 and file_ != '':
                # Ler as informações da página 1: configuration
                with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                    # Armazena as informações do arquivo enviado em uma lista
                    values = []
                    for line in arquivo_txt:
                        # Buscará as flag adicionada "=>" ou "="
                        if "=>" in line or '=' in line:
                            # Os primeiros 5 objetos são baseados na primeira flag
                            if cont < 4:
                                value = line.replace('=>', '').strip()
                                values.append(value)
                            # As direções de fluxo são baseadas na segunda flag
                            elif cont >= 4:
                                value_ = line.split("=")[1].strip()
                                values.append(value_)
                            cont += 1
                # Adiciona as informações lidas nas suas respectivas lineEdits
                self.dlg_flow_tt.le_1_pg1.setText(str(values[0]))
                self.dlg_flow_tt.le_2_pg1.setText(str(values[1]))
                self.dlg_flow_tt.le_3_pg1.setText(str(values[2]))
                self.dlg_flow_tt.le_4_pg1.setText(str(values[3]))
                self.dlg_flow_tt.le_5_pg1.setText(str(values[4]))
                self.dlg_flow_tt.le_6_pg1.setText(str(values[5]))
                self.dlg_flow_tt.le_7_pg1.setText(str(values[6]))
                self.dlg_flow_tt.le_8_pg1.setText(str(values[7]))
                self.dlg_flow_tt.le_9_pg1.setText(str(values[8]))
                self.dlg_flow_tt.le_10_pg1.setText(str(values[9]))
                self.dlg_flow_tt.le_11_pg1.setText(str(values[10]))
                self.dlg_flow_tt.le_12_pg1.setText(str(values[11]))
                break

            elif page == 2 and file_ != '':
                # Ler o arquivo da página 2: input dat
                with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                    # Armazenará os valores das linhas
                    values = []
                    for line in arquivo_txt:
                        if '=>' in line:
                            # Substitui o identificador => por uma string fazia e retira os espaços da linha
                            value = line.replace('=>', '').strip()
                            values.append(value)
                
                # Adiciona as informações lidas à seus respectivos campos
                self.dlg_flow_tt.le_1_pg2.setText(str(values[0]))
                self.dlg_flow_tt.le_2_pg2.setText(str(values[1]))
                self.dlg_flow_tt.te_1_pg2.setPlainText(str(values[2]))
                self.dlg_flow_tt.te_1_pg2.append(f'\n{str(values[3])}')
                self.dlg_flow_tt.le_3_pg2.setText(str(values[4]))
                self.dlg_flow_tt.le_4_pg2.setText(str(values[5]))
                self.dlg_flow_tt.le_7_pg2.setText(str(values[6]))
                # Atribui os valores do arquivo enviao a tabela em questão
                sel
                self.dlg_flow_tt.le_5_pg2.setText(str(values[7]))
                self.dlg_flow_tt.le_6_pg2.setText(str(values[9]))
                self.dlg_flow_tt.le_8_pg2.setText(str(values[8]))
                break               

            elif page == 4 and file_ != '':
                # Ler arquivos página 4
                with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                    # Armazenará os valores das linhas
                    values = []
                    for line in arquivo_txt:
                        if '=>' in line:
                            # Substitui o identificador => por uma string fazia e retira os espaços da linha
                            value = line.replace('=>', '').strip()
                            values.append(value)

                # Adiciona as informações lidas à seus respectivos campos            
                self.dlg_flow_tt.le_1_pg3.setText(str(values[0]))
                self.dlg_flow_tt.le_2_pg3.setText(str(values[1]))
                self.dlg_flow_tt.le_3_pg3.setText(str(values[2]))
                self.dlg_flow_tt.le_4_pg3.setText(str(values[3]))
                self.dlg_flow_tt.le_5_pg3.setText(str(values[4]))
                self.dlg_flow_tt.le_6_pg3.setText(str(values[5]))
                self.dlg_flow_tt.le_7_pg3.setText(str(values[6]))
                break
            
            else:
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    break 

    def save_table_to_file(self, table):
        '''Esta função lê as informações adicionadas às tabelas e as armazena em um arquivo'''
        while True:
            if table == 1:
                # Solicita um local de salvamento para o usuário
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "RDN_classes", "Text or CSV Files (*.txt *.csv)")
                if file_name:
                    self.dlg_flow_tt.le_7_pg2.setText(file_name)
                    # seleciona as dimensões da tabela
                    nlin_tb1 = self.dlg_flow_tt.tbw_1_pg2.rowCount()
                    ncol_tb1 = self.dlg_flow_tt.tbw_1_pg2.columnCount()

                    # Escreve o arquivo de saída
                    with open(file_name, 'w', encoding='utf-8') as arquivo_txt_csv:
                        arquivo_txt_csv.write(f'Num_classes:{nlin_tb1}\nClass ID;Slope(m/m);Manning Coef;Hydraulic radius\n')
                        # Adicionando as informações das linhas e colunas ao arquivo de saída
                        for lin in range(nlin_tb1):
                            for col in range(ncol_tb1):
                                item = self.dlg_flow_tt.tbw_1_pg2.item(lin, col)
                                # Verifica se o item existe
                                if item is not None:  
                                    arquivo_txt_csv.write(f'{item.text()}')
                                arquivo_txt_csv.write(';')  
                            arquivo_txt_csv.write('\n')
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break 

            elif table ==2:
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "Manning_roughness_coef_for_each_LULC", "Text or CSV Files (*.txt *.csv)")
                if file_name:
                    self.dlg_flow_tt.le_8_pg2.setText(file_name)
                    # seleciona as dimensões da tabela
                    nlin_tb1 = self.dlg_flow_tt.tbw_2_pg2.rowCount()
                    ncol_tb1 = self.dlg_flow_tt.tbw_2_pg2.columnCount()

                    # Escreve o arquivo de saída
                    with open(file_name, 'w', encoding='utf-8') as arquivo_txt_csv:
                        arquivo_txt_csv.write(f'Class ID;Class Name;Manning Coef\n')
                        # Adicionando as informações das linhas e colunas ao arquivo de saída
                        for lin in range(nlin_tb1):
                            for col in range(ncol_tb1):
                                item = self.dlg_flow_tt.tbw_2_pg2.item(lin, col)
                                # Verifica se o item existe
                                if item is not None:  
                                    arquivo_txt_csv.write(f'{item.text()}')
                                    arquivo_txt_csv.write(';')  
                            arquivo_txt_csv.write('\n')
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break 

    def read_tb_from_file(self,table, lineEdit,table_ordem):
        '''Esta função adiciona os valores do arquivo enviado pelo usuário à respectiva tabela'''
        # Seleciona o arquivo enviado pelo usuário
        options = QFileDialog.Options()
        directory = self.dlg_flow_tt.le_13_pg1.text()
        # Atualiza a flag para leitura dos dados da tabela
        self.flag = 1
        self.flag_1 = 1

        while True:
            # Solicita o arquivo
            file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory=directory, filter="Text or CSV Files (*.txt *.csv)", options=options)
            
            if file_:
                # Configura a primeira tabela
                if table_ordem == 1:

                    lineEdit.setText(file_)
                    # Abre o arquivo e processa as linhas
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                        # Lê a linha e o cabeçalho
                        self.global_vars.nclasses = arquivo_txt_csv.readline().strip().split(':')[1]
                        self.global_vars.nclasses =int(self.global_vars.nclasses)
                        arquivo_txt_csv.readline()
                        # Define o número de linhas que a tabela receberá
                        num_row_total = self.global_vars.nclasses

                        # Inicializa as listas para armazenamento das informações
                        id_class_list = []
                        Sclasse_list = []
                        Mannclasse_list = []
                        Rhclasse_list = []

                        # Iterando sobre as linhas do arquivo
                        for line in arquivo_txt_csv:
                            # Divide a linha nos espaços em branco e converte para float
                            indice, Scla, Mann, Rh = map(float, line.split())
                            # Adiciona os valores às listas
                            id_class_list.append(indice)
                            Sclasse_list.append(Scla)
                            Mannclasse_list.append(Mann)
                            Rhclasse_list.append(Rh)
                    
                    # Atualiza as variáveis gerais
                    self.global_vars.j = np.array(id_class_list)
                    self.global_vars.Sclasse = np.array(Sclasse_list)
                    self.global_vars.Mannclasse = np.array(Mannclasse_list)
                    self.global_vars.Rhclasse = np.array(Rhclasse_list)
                    
                    # Atualiza no número de linhas da tabela (recebe o número de classes dos rios da bacia hidrográfica)
                    table.setRowCount(self.global_vars.nclasses)
                    
                    # Coleta as dimensões da tabela
                    n_row = table.rowCount()
                    n_column = table.columnCount()

                    # Itera sobre os elementos da tabela
                    for col in range(n_column):
                        for lin in range(n_row):
                            if col == 0:
                                # Adiciona a coluna do id
                                item = QTableWidgetItem(str(id_class_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 1:
                                # Adiciona a coluna da declividade
                                item = QTableWidgetItem(str(Sclasse_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 2:
                                # Adiciona a coluna do coef de Manning  
                                item = QTableWidgetItem(str(Mannclasse_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 3:
                                # Adiciona a coluna do raio hidráulico
                                item = QTableWidgetItem(str(Rhclasse_list[lin]))
                                table.setItem(lin, col, item)               
                    break

                    # Configura a segunda tabela
                else:
                    # Criando variável extra, para armazenar os tipos de uso e coeficente de Manning
                    uso_manning = []
                    coef_maning = []
                    class_name = []
                    class_name_val = []
                    uso_manning_val = []
                    coef_maning_val = []
                    # Abrindo o arquivo que contém o coeficiente de Manning para os diferentes usos do solo
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                        # Amazena a linha do cabeçalho
                        firt_line = arquivo_txt_csv.readline().strip()

                        # Lê as informações de uso do solo e coeficiente de Manning 
                        for line in arquivo_txt_csv:
                            # Coletando as informações de cada linha
                            info = line.strip().split()
                            # Armazenando os valores das linhas nas suas respectivas variáveis
                            uso_manning = int(info[0])
                            coef_maning = float(info[1])
                            class_name = str(info[2])


                            # Adicionando os valores nas variáveis destinadas
                            uso_manning_val = np.append(uso_manning_val, uso_manning)
                            coef_maning_val = np.append(coef_maning_val, coef_maning)
                            class_name_val.append(class_name)

                    # Adicionando cada valor às suas respectivas variáveis
                    self.global_vars.usaux = uso_manning_val
                    self.global_vars.Mann = coef_maning_val

                    # Atualiza o número de linhas da tabela
                    table.setRowCount(len(uso_manning_val))

                    # Coleta as dimensões da tabela
                    n_row = table.rowCount()
                    n_column = table.columnCount()

                    # Adiciona as informações à tabela
                    for col in range(n_column):
                        for lin in range(n_row):
                            if col == 0:
                                # Adiciona a coluna class Id
                                item = QTableWidgetItem(str(uso_manning_val[lin]))
                                table.setItem(lin, col, item)
                            elif col == 1:
                                # Adiciona a coluna class Name
                                item = QTableWidgetItem(str(class_name_val[lin]))
                                table.setItem(lin, col, item)
                            elif col == 2:
                                # Adiciona a coluna do coef de Manning  
                                item = QTableWidgetItem(str(coef_maning_val[lin]))
                                table.setItem(lin, col, item)
                    
                    break

            else:
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    break 
        # Atualiza a flag para leitura dos dados da tabela
        self.flag = 0
        self.flag_1 = 0

    def add_new_row(self,table):
        '''Está função adiciona uma linha a uma tabela relecionada'''
        last_row = table.rowCount()
        table.insertRow(last_row)
    
    def delete_row(self,table):
        '''Esta função deleta uma linha de uma referida tabela'''
        selected_row = table.currentRow()
        if selected_row >= 0:
            table.removeRow(selected_row)
        else:
            QMessageBox.warning(None, "Warning", "You did not select any row.")
             
    def save(self):
        '''Esta função é usada para salvar as informações adiconadas'''
        self.save_result = True

    def close_gui(self):
        '''Está função é usada para torna nulo (limpar) as informações adicionadas nos diferentes objetos da janela flow travel time'''
        # Verifica se o botão de salvar foi clicado: modifica a execução da função close

        if self.save_result == True or self.le_edited == False:
            self.dlg_flow_tt.close()

        else:
            while True:

                result = "Wait! You did not save your changes. Are you sure you want to close?"
                reply = QMessageBox.warning(None, "Changes not saved", result, QMessageBox.Ok | QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    break

                else: 
                    # Limpando as informações armazenadas: line edit
                    self.dlg_flow_tt.le_1_pg1.clear()
                    self.dlg_flow_tt.le_2_pg1.clear()
                    self.dlg_flow_tt.le_3_pg1.clear()
                    self.dlg_flow_tt.le_4_pg1.clear()
                    self.dlg_flow_tt.le_5_pg1.clear()
                    self.dlg_flow_tt.le_6_pg1.clear()
                    self.dlg_flow_tt.le_7_pg1.clear()
                    self.dlg_flow_tt.le_8_pg1.clear()
                    self.dlg_flow_tt.le_9_pg1.clear()
                    self.dlg_flow_tt.le_10_pg1.clear()
                    self.dlg_flow_tt.le_11_pg1.clear()
                    self.dlg_flow_tt.le_12_pg1.clear()
                    self.dlg_flow_tt.le_13_pg1.clear()

                    self.dlg_flow_tt.le_1_pg2.clear()
                    self.dlg_flow_tt.le_2_pg2.clear()
                    self.dlg_flow_tt.te_1_pg2.clear()
                    self.dlg_flow_tt.le_3_pg2.clear()
                    self.dlg_flow_tt.le_4_pg2.clear()
                    self.dlg_flow_tt.le_5_pg2.clear()
                    self.dlg_flow_tt.le_6_pg2.clear()
                    self.dlg_flow_tt.le_7_pg2.clear()
                    self.dlg_flow_tt.le_8_pg2.clear()

                    self.dlg_flow_tt.le_1_pg4.clear()
                    self.dlg_flow_tt.le_2_pg4.clear()
                    self.dlg_flow_tt.le_3_pg4.clear()
                    self.dlg_flow_tt.le_4_pg4.clear()
                    self.dlg_flow_tt.le_5_pg4.clear()
                    self.dlg_flow_tt.le_6_pg4.clear()
                    self.dlg_flow_tt.le_7_pg4.clear()

                    # Limpando as informações armazenadas: tables widgets
                    nlin_tb1 = self.dlg_flow_tt.tbw_1_pg2.rowCount()
                    ncol_tb1 = self.dlg_flow_tt.tbw_1_pg2.columnCount()
                    nlin_tb2 = self.dlg_flow_tt.tbw_2_pg2.rowCount()
                    ncol_tb2 = self.dlg_flow_tt.tbw_2_pg2.columnCount()
                    # Primeira tabela
                    for lin in range(nlin_tb1):
                        for col in range(ncol_tb1):
                            item = self.dlg_flow_tt.tbw_1_pg2.item(lin, col)
                            if item is not None:
                                item.setText('')

                    # Segunda tabela
                    for lin in range(nlin_tb2):
                        for col in range(ncol_tb2):
                            item = self.dlg_flow_tt.tbw_2_pg2.item(lin, col)
                            if item is not None:
                                item.setText('')

                    self.dlg_flow_tt.close()
                    break
        # Atualiza as variáveis para a condição de salvamento
        self.save_result = False
        self.le_edited = False
            

    def clear_table(self,table,lineEdit):
        '''Esta função limpa os valores armazenados na respectiva tabela'''
        # Limpando as informações armazenadas: tables widgets
        nlin_tb1 = table.rowCount()
        ncol_tb1 = table.columnCount()

        # Reinicia a respectiva tabela
        for lin in range(nlin_tb1):
            for col in range(ncol_tb1):
                item = table.item(lin, col)
                if item is not None:
                    item.setText('')
        # Limpa a lineEdit
        lineEdit.clear()

    def changed(self):
        '''Esta função modifica a condição da variável le_edited referenciando a modificação da line edit,
           verifica condição de salvamento;
           Se le_changed == True => bloqueia o fechamento direto da página
           se le_changed == False => fecha a página diretamente '''
        self.le_edited = True

    def logging_run_page(self):
        '''Está função ativa a página de log e configura a ordem de execução das funções para o cálculo do tempo de viagem'''
        # Limpa as informações passadas no text_edit
        self.dlg_flow_tt.pg_par_ftt.clear()

        # Cria condição de parada da execução: se o usuário clicar no botão cancel da página de log
        while self.run_condicao:
            # Método usado para permitir a iteração do usuário enquanto o programa está em execução
            QApplication.processEvents() 
            # Verifica a existência de incoerências nas informações fornecidas pelo usuário
            list_line_edit_value_pg1 = [self.dlg_flow_tt.le_5_pg1.text(),
                                        self.dlg_flow_tt.le_6_pg1.text(),
                                        self.dlg_flow_tt.le_7_pg1.text(),
                                        self.dlg_flow_tt.le_8_pg1.text(),
                                        self.dlg_flow_tt.le_9_pg1.text(),
                                        self.dlg_flow_tt.le_10_pg1.text(),
                                        self.dlg_flow_tt.le_11_pg1.text(),
                                        self.dlg_flow_tt.le_12_pg1.text()
                                    ]
            duplicate = []
            # Verifica se há duplicatas no código
            for i in range(len(list_line_edit_value_pg1)):
                for j in range(i+1,len(list_line_edit_value_pg1)):
                    if list_line_edit_value_pg1[i] == list_line_edit_value_pg1[j]:
                        # Para os elementos iguais, armazena eles em uma lista
                        duplicate.append(list_line_edit_value_pg1[i])

            if any(item == '' for item in duplicate):
                self.dlg_flow_tt.pages_flow_tt.setCurrentIndex(0)
                # Vefica se os códigos das diferções de drenagem foram corretamente enviados
                QMessageBox.warning(self.dlg_flow_tt, 'Warning', f"Direction codes might not None.")
                return

            elif duplicate and all(item != '' for item in duplicate):
                self.dlg_flow_tt.pages_flow_tt.setCurrentIndex(0)
                # O usuário enviou 2 valores semelhantes, será mostrado uma mensagem de erro
                QMessageBox.warning(self.dlg_flow_tt, 'Warning', f"The value(s) '{duplicate}' is(are) (a) duplicate(s)! Direction codes do not accept duplicates.")
                return
            else:

                # Se não existir erros nas informações enviadas, será mostrada a página de log e o programa será executado
                self.dlg_flow_tt.tabWidget.setCurrentIndex(1)
                self.dlg_flow_tt.pg_par_ftt.setEnabled(False)
                font = QFont()
                font.setPointSize(10)
                version_info = {
                    "QGIS Version": '3.34.0-Prizren',
                    "Qt Version": '5.15.3',
                    "Python Version": '3.9.5',
                    "GDAL Version": '3.8.0'}

                # Configura as informações do textEdit da referida página
                datatime_started = datetime.now().isoformat()
                mensagem_log = f"The plugin was developed with:\n"
                mensagem_log += f"QGIS Version: {version_info['QGIS Version']}\n"
                mensagem_log += f"Qt Version: {version_info['Qt Version']}\n"
                mensagem_log += f"Python Version: {version_info['Python Version']}\n"
                mensagem_log += f"GDAL Version: {version_info['GDAL Version']}\n"
                mensagem_log += "--------------------------------------------------------\n"
                mensagem_log += f"Algorithm started at: {datatime_started}\n"

                # Adiciona as mensagem de log ao text edit e configura a função run
                self.dlg_flow_tt.te_logg.append(mensagem_log)

                # ---Entradas---
                mensagem_log += f"READING INPUT FILES...\n"
                self.leh_bacia()
                self.leh_direcoes_de_fluxo()
                self.leh_modelo_numerico_dTerreno()
                self.leh_drenagem()
                self.leh_uso_do_solo()

                if self.flag == 0:
                    # O usuário digitou as informações
                    self.leh_valore_table_1() 
                
                if self.flag_1 == 0:
                    # O usuário digitou as informações
                    self.leh_valores_table_2()

                self.leh_precipitacao_24h()

                # ---Cálculos---
                mensagem_log += f'PROCESSING...\n'
                if self.global_vars.unidaderef3 == 'deg':
                    # sistema em graus, assumindo latlong
                    self.global_vars.metro = 0
                else:
                    # sistema em metros
                    # se sistema de referencia em metros, fazer metro=1 (não faz projeção)
                    # caso contrário (se metro=0), assume que está graus e faz projeção para metros
                    self.global_vars.metro = 1
                mensagem_log += f'Processing ComprimAcu...\n'
                self.comprimento_acumulado(1)
                mensagem_log += f'Processing NumeraPix...\n'
                self.numera_pixel()
                mensagem_log += f'Processing DistDren...\n' #'''AQUIII'''
                self.dist_drenagem()
                
                if self.global_vars.tipo_decliv == 4:
                    self.escreve_decliv_pixel_jus()
                mensagem_log += f'Processing DistTrecho...\n'
                self.dist_trecho()
                self.escreve_declivi_pixel()

                mensagem_log += f'Processing TempoSup...\n'
                self.tempo_sup()
                self.escreve_tre_cabec()
                self.escreve_num_trechos()
                self.escreve_dist_rel_trechos()

                # mensagem_log += f'Processing ComprimAcu...\n'
                # self.comprimento_acumulado(1)

                mensagem_log += f'Processing TempoCanal...\n'
                self.tempo_canal()

                mensagem_log += f'Processig TempoTotal...\n'
                self.tempo_total()

                # Saídas
                mensagem_log += f'WRITING OUTPUT FILES...\n'
                self.escreve_num_pix_cabec()
                self.escreve_num_pix_drenagem()
                self.escreve_conectividade()
                
                if self.global_vars.tipo_decliv == 4:
                    self.escreve_tempo_sup()
                
                self.escreve_comprimento_acumulado()
                self.escreve_tempo_canal()
                self.escreve_tempo_total()

                if self.global_vars.tipo_decliv == 4:
                    self.escreve_TS_pix_acum()

                # Adiciona as informação ao text edit
                self.dlg_flow_tt.te_logg.append(mensagem_log)

    def cancel_log_page(self):
        '''Esta função configura o botão de cancelar da página de log'''
        # Escreve a mensagem de pausa no text edit da página de log
        mansage_log = f'Attention!\nStoping FLOW TRAVEL TIME process...'

        # Reativa a página de parametros
        self.dlg_flow_tt.pg_par_ftt.setEnabled(True)

        # Para a função logging run page
        self.run_condicao = False

    def run(self):
        """Run method that performs all the real work"""

        # Sempre inicialize self.dlg_hidro_pixel
        self.dlg_hidro_pixel = HidroPixelDialog()

        # Apenas mostra a janela se for a primeira vez que o plugin é iniciado
        if self.first_start:
            self.first_start = False
                
        # Show the dialog
        self.dlg_hidro_pixel.show()

        # Cria as flags para configurar a leitura dos dados da tabela
        self.flag = 0
        self.flag_1 = 0

        # Cria flag para parar a execução da função run logging page

        # Configura os botões da página da rotina do flow travel time
        self.dlg_hidro_pixel.btn_flow_trav.clicked.connect(lambda: self.dlg_flow_tt.show())

        self.dlg_flow_tt.btn_config.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg1_config))      
        self.dlg_flow_tt.btn_input_data.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg2_in_data))
        self.dlg_flow_tt.btn_data_va_tool.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg3_data_val_tool))
        self.dlg_flow_tt.btn_run.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg4_run))

        # Configura os botões da página configuration
        self.dlg_flow_tt.tbtn_pg1_1.clicked.connect(lambda: self.carrega_work_folder())

        # Configura os botões da página input data:
        self.dlg_flow_tt.tbtn_pg2_1.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_1_pg2))
        self.dlg_flow_tt.tbtn_pg2_2.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_2_pg2))
        self.dlg_flow_tt.tbtn_pg2_3.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.te_1_pg2, qtd = 2))
        self.dlg_flow_tt.tbtn_pg2_4.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_3_pg2))
        self.dlg_flow_tt.tbtn_pg2_5.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_4_pg2))
        self.dlg_flow_tt.tbtn_pg2_6.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_5_pg2))

        # Configura os botões da página input data:
        self.dlg_flow_tt.tbtn_pg4_1.clicked.connect(lambda: self.salva_buttons(self.dlg_flow_tt.le_1_pg4))
        self.dlg_flow_tt.tbtn_pg4_2.clicked.connect(lambda: self.salva_buttons(self.dlg_flow_tt.le_2_pg4))
        self.dlg_flow_tt.tbtn_pg4_3.clicked.connect(lambda: self.salva_buttons(self.dlg_flow_tt.le_3_pg4))
        self.dlg_flow_tt.tbtn_pg4_4.clicked.connect(lambda: self.salva_buttons(self.dlg_flow_tt.le_4_pg4))
        self.dlg_flow_tt.tbtn_pg4_5.clicked.connect(lambda: self.salva_buttons(self.dlg_flow_tt.le_5_pg4))
        self.dlg_flow_tt.tbtn_pg4_6.clicked.connect(lambda: self.salva_buttons(self.dlg_flow_tt.le_6_pg4))
        self.dlg_flow_tt.tbtn_pg4_7.clicked.connect(lambda: self.salva_buttons(self.dlg_flow_tt.le_7_pg4))

        # configura botões de salvar e savar para um arquivo
        self.dlg_flow_tt.btn_save_file_pg1.clicked.connect(lambda: self.save_to_file(1))
        self.dlg_flow_tt.btn_save_file_pg2.clicked.connect(lambda: self.save_to_file(2))
        self.dlg_flow_tt.btn_save_file_pg4.clicked.connect(lambda: self.save_to_file(4))


        # Configura botão para ler informações de uma arquivo enviado
        self.dlg_flow_tt.btn_read_pg1.clicked.connect(lambda: self.read_from_file(1))
        self.dlg_flow_tt.btn_read_pg2.clicked.connect(lambda: self.read_from_file(2))
        self.dlg_flow_tt.btn_read_pg4.clicked.connect(lambda: self.read_from_file(4))

        # Configura butões das tabelas
        self.dlg_flow_tt.btn_read_t1.clicked.connect(lambda: self.read_tb_from_file(self.dlg_flow_tt.tbw_1_pg2,self.dlg_flow_tt.le_7_pg2, 1)) #argumento
        self.dlg_flow_tt.btn_read_t2.clicked.connect(lambda: self.read_tb_from_file(self.dlg_flow_tt.tbw_2_pg2,self.dlg_flow_tt.le_8_pg2,2))
        self.dlg_flow_tt.btn_save_file_t1.clicked.connect(lambda: self.save_table_to_file(1))
        self.dlg_flow_tt.btn_save_file_t2.clicked.connect(lambda: self.save_table_to_file(2))
        self.dlg_flow_tt.btn_add_row_1.clicked.connect(lambda: self.add_new_row(self.dlg_flow_tt.tbw_1_pg2))
        self.dlg_flow_tt.btn_add_row_2.clicked.connect(lambda: self.add_new_row(self.dlg_flow_tt.tbw_2_pg2))
        self.dlg_flow_tt.btn_del_row_1.clicked.connect(lambda: self.delete_row(self.dlg_flow_tt.tbw_1_pg2))
        self.dlg_flow_tt.btn_del_row_2.clicked.connect(lambda: self.delete_row(self.dlg_flow_tt.tbw_2_pg2))
        
        # Save the pages
        self.dlg_flow_tt.btn_save_pg1.clicked.connect(lambda: self.save())
        self.dlg_flow_tt.btn_save_pg2.clicked.connect(lambda: self.save())
        self.dlg_flow_tt.btn_save_pg4.clicked.connect(lambda: self.save())

        # clear all tables's values
        self.dlg_flow_tt.btn_clear_1.clicked.connect(lambda: self.clear_table(self.dlg_flow_tt.tbw_1_pg2,self.dlg_flow_tt.le_7_pg2))
        self.dlg_flow_tt.btn_clear_2.clicked.connect(lambda: self.clear_table(self.dlg_flow_tt.tbw_2_pg2,self.dlg_flow_tt.le_8_pg2))

        # close the pages and config save button
        self.save_result = False
        self.le_edited = False
        self.dlg_flow_tt.le_6_pg1.textChanged.connect(lambda: self.changed())
        self.dlg_flow_tt.btn_close_pg4.clicked.connect(lambda: self.close_gui())
        
        # Configura run button
        self.dlg_flow_tt.btn_run_2.clicked.connect(lambda: self.logging_run_page())

        # Configura botões página de log

        # Run the dialog event loop
        self.dlg_hidro_pixel.exec_()
        self.close_gui()