# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Hidropixel
 Add the description
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-29
        git sha              : $Format:%H$
        copyright            : (C) 2023 by João Vitor & Adriano Rolim
        email                : jvds@academico.ufpb.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt import uic
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QRegularExpression
from qgis.PyQt.QtGui import QIcon, QRegExpValidator, QIntValidator, QFont
from qgis.PyQt.QtWidgets import QApplication, QMainWindow, QAction, QFileDialog, QMessageBox, QTableWidgetItem, QWidget, QStackedWidget
from qgis.core import QgsMessageLog, Qgis, QgsProject, QgsRasterLayer
from qgis.utils import iface


# Import the code for the dialog
import os.path
import sys, os
import logging
from .hidroPixel_dialog import HidroPixelDialog
from pathlib import Path
from datetime import datetime
from hidropixel.modulos_files.RDC_variables import RDCVariables
from hidropixel.modulos_files.global_variables import GlobalVariables

# Initialize Qt resources from file resources.py
from .resources import *

# Importing libs
import numpy as np
from osgeo import ogr, gdal, gdalconst
from functools import wraps

class HidroPixel:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Hidropixel_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Hidropixel')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # Criando instâncias das classes
        self.global_vars = GlobalVariables()
        self.rdc_vars = RDCVariables()

        # Seleciona o diretório atual do plugin
        file_path = os.path.dirname(__file__)

        # Inicia a interface gráfica da rotina flow travel time
        ui_file = os.path.join(file_path, 'hidroPixel_dialog_flow_tt.ui')

        # Inicia a interface gráfica da rotina excess rainfall
        ui_file1 = os.path.join(file_path, 'hidroPixel_dialog_exec_rainfall.ui')

        # Inicia a interface gráfica da rotina flow routing
        ui_file2 = os.path.join(file_path, 'hidroPixel_dialog_flow_rout.ui')

        # Inicia a interface gráfica da pagina run da função rainfall interpolation
        ui_file3 = os.path.join(file_path, 'hidroPixel_dialog_run_rainfall_interpol.ui')

        # inicia instânica das diferentes routinas do plugin Hidropixel
        self.dlg_flow_tt = uic.loadUi(ui_file)
        self.dlg_exc_rain = uic.loadUi(ui_file1)
        self.dlg_flow_rout = uic.loadUi(ui_file2)
        self.dlg_rain_interpl_run = uic.loadUi(ui_file3)

        # Cria outras variáveis necessárias
        self.save_result = None
        self.classerio_aux = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        self.fn_n_conect_dren = None
        self.fn_num_pix_dren = None
        self.fn_comp_acum = None
        self.fn_comp_foz = None
        self.fn_decli_pix = None
        self.fn_decli_pix_jus = None
        self.fn_temp_total = None
        self.flag = None
        self.flag_1 = None
        self.alfa, self.delta_t, self.criterio_parada, self.beta = 0,0,0,0
        self.numero_total_pix = 0
        self.num_intervalos = 0
        self.volume_total = 0.0 
        self.quantidade_blocos_chuva = 0
        self.chuva_excedente_calc = 0
        self.blocos_vazao = 0
        self.Pexc = 0
        self.coef_c = 0
        self.coef_d = 0
        self.coef_g = 0
        self.coef_h = 0
        self.n_canal = 0
        self.comp_treco = 0
        self.sheet_flow = 0
        self.minus_slope = 0
        self.profundidade_resers = 0
        
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Hidropixel', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/hidroPixel/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Hidropixel Plugin'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Hidropixel'),
                action)
            self.iface.removeToolBarIcon(action)

    def optimize(func):
        '''Esta função utiliza métodos python para otimizar o código, gerando um cache para os resultados do usuário'''
        cache = {}

        @wraps(func)
        def wrapper(*args,**kwargs):
            key = str(args) + str(kwargs)

            if key not in cache:
                cache[key] = func(*args,**kwargs)

            return cache[key]
            
        return wrapper

    def carrega_work_folder(self, line_edit):
        '''Esta função define a pasta padrão tanto para buscar, quanto para salvar os arquivos'''
        # Define as variáveis e configurações da janela de escolha do arquivo
        pasta = None
        line_edit.setText('')
        options = QFileDialog.Options()
        pasta = QFileDialog.getExistingDirectory(None, caption = 'Select your work folder!', options = options)

        if pasta != '':
            # Se o usário enviar um arquivo, este será armazenado na sua referida line edit
            line_edit.setText(pasta)
        else:
            # Caso contrário, será mostrada uma mensagem de aviso
            result ="Wait! You did not select any folder."
            QMessageBox.warning(None, "No folder selected", result)

        return pasta

    def carrega_arquivos(self, lineEdit, file_type="raster", qtd=1):
        """Esta função é utilizada para adicionar os arquivos enviados pelo usuário ao plugin"""
        # Define as variáveis e configurações da janela de escolha do arquivo
        file_ = None
        options = QFileDialog.Options()
        directory = self.dlg_flow_tt.le_21_pg1.text()

        while True:  # Loop até que o usuário selecione um arquivo ou cancele
            if qtd == 2:
                file_, _ = QFileDialog.getOpenFileNames(None, caption="Select the files!", directory=directory, filter="Raster or RDC file (*.rst *.tif *.rdc)", options=options)
                if file_:
                    lineEdit.setPlainText("\n".join(file_))
                    self.rdc_vars.nomeRDC = file_[0] if file_ else None
                    self.rdc_vars.nomeRST = file_[1] if len(file_) > 1 else None
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No file selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break  
            else:
                # Janela de diálogo com o Usuário
                if file_type == "raster".lower():
                    file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory=directory, filter="Raster Files (*.rst *.tif)", options=options)
                elif file_type == "text".lower():
                    file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory=directory, filter="Text Files (*.txt)", options=options)

                # Verificar se algum arquivo foi selecionado
                if file_:
                    # Adiciona o arquivo selecionado a lineEdit
                    lineEdit.setText(file_)
                    return file_
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break 

    def leh_bacia(self, file_, function):
        """Esta função é utilizada para ler o arquivo raster da bacia hidrográfica (arquivo .RST)
           funciton == 1: flow travel time
           function == 2: excesse rainfall
           function == 3: flow routing"""

        arquivo = file_
        # Tratamento de erros: verifica se o arquivo foi corretamente enviado
        if arquivo:
            if function == 1:
                # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
                rst_file_bacia = gdal.Open(arquivo)

                # Lendo os dados raster como um array 
                dados_lidos_bacia = rst_file_bacia.GetRasterBand(1).ReadAsArray()
                
                # Tratamento de erro: verifica se o arquivo foi aberto corretamente
                if rst_file_bacia is not None:

                    # atualizando os valores das variáveis para coletar o número de linhas e colunas do arquivo raster lido
                    self.rdc_vars.nlin = rst_file_bacia.RasterYSize               
                    self.rdc_vars.ncol = rst_file_bacia.RasterXSize
                    self.rdc_vars.geotransform = rst_file_bacia.GetGeoTransform()
                    self.rdc_vars.projection = rst_file_bacia.GetProjection()                 
                    # Reorganizando os dados lidos da bacia em uma nova matriz chamada bacia.

                    self.global_vars.bacia = dados_lidos_bacia
                    # Fechando o dataset GDAL

                    rst_file_bacia = None

            elif function == 2 or function == 3:
                # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
                rst_file_bacia = gdal.Open(arquivo)

                # Lendo os dados raster como um array 
                dados_lidos_bacia = rst_file_bacia.GetRasterBand(1).ReadAsArray()
                
                # Tratamento de erro: verifica se o arquivo foi aberto corretamente
                if rst_file_bacia is not None:

                    # atualizando os valores das variáveis para coletar o número de linhas e colunas do arquivo raster lido
                    self.rdc_vars.nlin = rst_file_bacia.RasterYSize               
                    self.rdc_vars.ncol = rst_file_bacia.RasterXSize
                    self.rdc_vars.geotransform = rst_file_bacia.GetGeoTransform()
                    self.rdc_vars.projection = rst_file_bacia.GetProjection()  

                    # Reorganizando os dados lidos da bacia em uma nova matriz chamada bacia.
                    self.global_vars.bacia = dados_lidos_bacia

                    # Fechando o dataset GDAL
                    rst_file_bacia = None

                    print(f'Qtd pix bacia: {np.count_nonzero(self.global_vars.bacia)}\nÁrea da bacia: {(np.count_nonzero(self.global_vars.bacia))*100/1000000} Km²')

                else:
                    """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
                    resulte = f"Failde to open the raster file: {arquivo}"
                    QMessageBox.warning(None, "ERROR!", resulte)

                # Lê informações do arquivo de metadados (.rdc)
                if '.RST' in arquivo:
                    arquivo_rdc = arquivo.replace('.RST', '.RDC')
                elif '.rst' in arquivo:
                    arquivo_rdc = arquivo.replace('.rst', '.RDC')

                if os.path.exists(arquivo_rdc) and os.path.isfile(arquivo_rdc):
                    arquivo_rdc = arquivo_rdc
                else:
                    arquivo_rdc.replace('.RDC','.rdc')
                    if os.path.exists(arquivo_rdc) and os.path.isfile(arquivo_rdc):
                        arquivo_rdc = arquivo_rdc
                    else:
                        resulte = f"There is no file named {arquivo_rdc} in the same directory as {arquivo}!"
                        QMessageBox.warning(None, "ERROR!", resulte)                        

                if arquivo_rdc is not None:
                    with open(arquivo_rdc, 'r', encoding='iso-8859-1') as rdc_file:
                        # Separando os dados do arquivo RDC em função das linhas que contém alguma das palavras abaixo
                        k_words = ["columns", "rows", "ref. system", "ref. units", "min. X", "max. X", "min. Y", "max. Y", "resolution"]
                        lines_RDC = [line.strip() for line in rdc_file.readlines() if any(word in line for word in k_words)]
                        
                        # Iterando sobre a lista de lines_rdc para guardas as informações das palavras da lista (k_words) nas ruas respectivas variáveis
                        for line in lines_RDC:
                            # Separando as linhas de acordo com o refencial (:)
                            split_line = line.split(":")
                            # Armazenando o primeiro valor da linha (antes do sinal ":")em uma variável e retirando os espaços (caracter) do inicio e fim da linha repartida
                            key = split_line[0].strip()
                            # Armazenando o segundo valor da linha (antes do sinal ":") em uma variáveis e retirando os espaços (caracter) do inicio e fim da linha repartida
                            value = split_line[-1].strip()

                            # Estrutura condicional para verificar quais são as informações de cada linha e armazenando elas em suas respectivas variáveis
                            if key == "ref. system":
                                self.rdc_vars.sistemaref = value
                            elif key == "ref. units":
                                self.rdc_vars.unidaderef = value
                            elif key == "min. X":
                                self.X_minimo = float(value)
                            elif key == "max. X":
                                self.X_maximo = float(value)
                            elif key == "min. Y":
                                self.Y_minimo = float(value)
                            elif key == "max. Y":
                                self.Y_maximo = float(value)
                            elif key == "resolution":
                                self.global_vars.dx = float(value)
                    # Definição das caracteristicas do pixel
                    self.d_x = (self.X_maximo - self.X_minimo)/self.rdc_vars.ncol
                    self.d_y = (self.Y_maximo - self.Y_minimo)/self.rdc_vars.nlin    
                else:
                    # Arquivo não existente: mostra erro para usuário
                    resulte = f"There is no file named {arquivo_rdc} in the same directory as {arquivo}!"
                    QMessageBox.warning(None, "ERROR!", resulte)                 

        else:
            result ="Nenhum arquivo foi selecionado!"
            QMessageBox.warning(None, "ERROR!", result)

    def leh_valores_table_1(self):
        '''Esta função coleta as informações adicionadas nos itens da tabela da característica dos rios e adiciona em suas variáveis'''

        # Verifica a dimensão da tabela
        nlin_tb = self.dlg_flow_tt.tbw_1_pg2.rowCount()
        ncol_tb = self.dlg_flow_tt.tbw_1_pg2.columnCount()

        # Define variáveis para obtenção das informações
        id_class = []
        slope_class = []
        mann_coef_class = []
        hydraul_rad_class = []
        item = 0

        # Itera sobre os itens da tabela
        for col in range(ncol_tb):
            for lin in range(nlin_tb):
                item_tb = self.dlg_flow_tt.tbw_1_pg2.item(lin,col).text()

                if item_tb is not None:
                    # coleta o item da celula atual e tenta converter para float
                    item_tb = float(self.dlg_flow_tt.tbw_1_pg2.item(lin,col).text())

                    # coleta o id das classes
                    if col == 0:
                        id_class.append(item_tb)

                    # coleta a inclinação
                    elif col == 1:
                        slope_class.append(item_tb)
                    
                    # coleta o coeficiente de Manning
                    elif col == 2:
                        mann_coef_class.append(item_tb)
                    
                    # coleta o raio hidráulico
                    elif col == 3:
                        hydraul_rad_class.append(item_tb)
        # Atualiza a variável 
        # Atualiza as variáveis globais com os valores enviados
        self.global_vars.j = np.array(id_class)
        self.global_vars.Sclasse = np.array(slope_class)
        self.global_vars.Mannclasse = np.array(mann_coef_class)
        self.global_vars.Rhclasse = np.array(hydraul_rad_class)

    def leh_classes_rios(self):
        """Esta função é utilizada para ler as informações acerca da classe dos rios da bacia hidrográfica (arquivo raster -  .rst)"""
        
        # Abrindo o arquivo com as informações acerca das classes dos rios
        arquivo = self.dlg_flow_tt.le_4_pg2.text()

        # Tratamento de erros: verifica se o arquivo foi corretamente enviado
        if arquivo:
            # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
            rst_file_claRIO = gdal.Open(arquivo)
            
            # Lendo os dados raste como um array 
            dados_lidos_raster_claRIO = rst_file_claRIO.GetRasterBand(1).ReadAsArray()

            #  Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
            if rst_file_claRIO is not None:
                # Reorganizando os dados lidos em uma nova matriz, essa possui as informações sobre as classes dos rios
                self.global_vars.classerio = dados_lidos_raster_claRIO
                # Fechando o dataset GDAL referente ao arquivo raster
                rst_file_claRIO = None
            else:
                # Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro
                resulte = f"Failde to open the raster file: {arquivo}"
                QMessageBox.warning(None, "ERROR!", resulte)
                
        else:
            # Exibe uma mensagem de erro
            result ="Nenhum arquivo foi selecionado!"
            QMessageBox.warning(None, "ERROR!", result)

    def leh_direcoes_de_fluxo(self):
        """Esta função é utilizada para ler as informações acerca da direção de escoamento dos rios (arquivo raster - .rst)"""

        # Definindo a numeração das direções &
        # Definindo a posição relativa dos pixels vizinhos
        # lin viz = lin centro + dlin(i)
        # col viz = col centro + dcol(i)
        
        self.global_vars.dlin = {
                            1: -1,
                            2: 0,
                            4: 1,
                            8: 1,
                            16: 1,
                            32: 0,
                            64: -1,
                            128: -1
                            }
        self.global_vars.dcol = {
                            1: 1,
                            2: 1,
                            4: 1,
                            8: 0,
                            16: -1,
                            32: -1,
                            64: -1,
                            128: 0
                            }

       
        # ATENÇÃO PARA O VALOR NUMÉRICO DAS DIRECÕES
        # ---------------------------------------------------------
        # - G  H  A      ArcView:  32 64 128    MGB-IPH:  64  128  1 -
        # - F  *  B                16  *  1               32   *   2 -
        # - E  D  C                 8  4  2               16   8   4 -

        # Recebendo os arquivos necessários: função run
        linhas_text_edit = self.dlg_flow_tt.te_1_pg2.toPlainText()
        linhas = linhas_text_edit.split('\n')
        self.rdc_vars.nomeRDC = linhas[0]
        self.rdc_vars.nomeRST = linhas[1]

        if self.rdc_vars.nomeRDC !='' and self.rdc_vars.nomeRST !='':
            # Verificando a extensão do arquivo: ordem de leitura, 1st o arquivo rdc
            exten1 = Path(self.rdc_vars.nomeRDC).suffix.lower()
            exten2 = Path(self.rdc_vars.nomeRST).suffix.lower()
            # Verifica se o primeiro arquivo é .rdc e o segundo .rst
            if exten1 == ".rdc" and exten2 == ".rst":
                self.rdc_vars.nomeRDC, self.rdc_vars.nomeRST = self.rdc_vars.nomeRDC, self.rdc_vars.nomeRST
            # Verifica se o primeiro arquivo é .rst e o segundo .rdc, caso contrário, troca os nomes
            elif exten1 == ".rst" and exten2 == ".rdc":
                self.rdc_vars.nomeRDC, self.rdc_vars.nomeRST = self.rdc_vars.nomeRST, self.rdc_vars.nomeRDC

            # Abrindo o arquivo RDC
            arquivo = self.rdc_vars.nomeRDC
            with open(arquivo, 'r',  encoding='iso-8859-1') as rdc_file:
                # Separando os dados do arquivo RDC em função das linhas que contém alguma das palavras abaixo
                k_words = ["columns", "rows", "ref. system", "ref. units", "min. X", "max. X", "min. Y", "max. Y", "resolution"]
                lines_RDC = [line.strip() for line in rdc_file.readlines() if any(word in line for word in k_words)]
                
                # Iterando sobre a lista de lines_rdc para guardas as informações das palavras da lista (k_words) nas ruas respectivas variáveis
                for line in lines_RDC:
                    # Separando as linhas de acordo com o refencial (:)
                    split_line = line.split(":")
                    # Armazenando o primeiro valor da linha (antes do sinal ":")em uma variável e retirando os espaços (caracter) do inicio e fim da linha repartida
                    key = split_line[0].strip()
                    # Armazenando o segundo valor da linha (antes do sinal ":") em uma variáveis e retirando os espaços (caracter) do inicio e fim da linha repartida
                    value = split_line[-1].strip()

                    # Estrutura condicional para verificar quais são as informações de cada linha e armazenando elas em suas respectivas variáveis
                    if key == "rows":
                        self.rdc_vars.nlin = int(value)
                    elif key == "columns":
                        self.rdc_vars.ncol = int(value)
                    elif key == "ref. system":
                        self.rdc_vars.sistemaref = value
                    elif key == "ref. units":
                        self.rdc_vars.unidaderef3 = value
                    elif key == "min. X":
                        self.rdc_vars.xmin = float(value)
                    elif key == "max. X":
                        self.rdc_vars.xmax = float(value)
                    elif key == "min. Y":
                        self.rdc_vars.ymin = float(value)
                    elif key == "max. Y":
                        self.rdc_vars.ymax = float(value)
                    elif key == "resolution":
                        self.global_vars.dx = float(value)
            
            # Atualizando algumas variáveis com as informações coletadas do arquivo RDC
            self.global_vars.Xres2 = self.global_vars.dx
            self.global_vars.Xres = float(self.global_vars.Xres2)
            self.global_vars.Yres = self.global_vars.Xres

            # Abrindo o arquivo raster
            rst_file_dir = gdal.Open(self.rdc_vars.nomeRST)
            # Lendo os dados raster como um array
            dados_lidos_direcoes = rst_file_dir.GetRasterBand(1).ReadAsArray()

            # Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
            if rst_file_dir is not None:
                # Reorganizando os dados lidos na matriz destinadas às informações da drenagem da bacia hidrográfica
                self.global_vars.direcoes = dados_lidos_direcoes

                # Fechando o dataset GDAL referente ao arquivo raster
                rst_file_dir = None
            else:
                """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
                resulte = f"Failde to open the raster file: {self.rdc_vars.nomeRST}"
                QMessageBox.warning(None, "ERROR!", resulte)

            # Verificação do valor da variável maxdir
            self.global_vars.maxdir = np.amax(self.global_vars.direcoes)

            # Iniciando a iterações com base nas linhas e colunas
            if self.global_vars.maxdir > 128:
                # Mapeamento das direções de fluxo do tipo idrisi
                A = self.dlg_flow_tt.le_5_pg1.text()
                B = self.dlg_flow_tt.le_6_pg1.text()
                C = self.dlg_flow_tt.le_7_pg1.text()
                D = self.dlg_flow_tt.le_8_pg1.text()
                E = self.dlg_flow_tt.le_9_pg1.text()
                F = self.dlg_flow_tt.le_10_pg1.text()
                G = self.dlg_flow_tt.le_11_pg1.text()
                H = self.dlg_flow_tt.le_12_pg1.text()
                valores = [A, B, C, D, E, F, G, H]
                chaves = [45, 90, 135, 180, 225, 270, 315, 360]
                value_error = [valor for valor in valores if type(valor) != int]

                # Dicionário com as combinações das direções de fluxo
                idrisi_map = {}
                for chave, valor in zip(chaves, valores):
                    try:
                        idrisi_map[chave] = int(valor) #devem ser diferentes entre si, i+1 != i e i-1
                    except ValueError:
                        result = f'The value(s) "{value_error}" is(are) not (a) valid integer number(s)!'
                        QMessageBox.warning(None, "ERROR!", result)
                
                for lin in range(self.rdc_vars.nlin):
                    for col in range(self.rdc_vars.ncol):
                        # Verifica se o valor atual da variável maxdir está presente no mapeamento
                        if self.global_vars.direcoes[lin, col] in idrisi_map:
                            # Atualiza o valor do elemento atual da matriz dir de acordo com os novos valores
                            self.global_vars.direcoes[lin, col] = idrisi_map[self.global_vars.direcoes[lin, col]]


            # Tratamento das direções na borda
            self.global_vars.direcoes[0, :] = int(H)
            self.global_vars.direcoes[-1, :] = int(D)
            self.global_vars.direcoes[:, 0] = 32 int(F)
            self.global_vars.direcoes[:, -1] = 2 int(B)

    def leh_drenagem(self):
        """Esta função é utilizada para ler as informações acerca da drenagem dos rios (arquivo raster - .rst)"""

        # Obtendo o arquivo referente as calasses dos rios da bacia hidrográfica
        arquivo = self.dlg_flow_tt.le_3_pg2.text()
        # Abrindo o arquivo raster com as informações acerda do sistema de drenagem da bacia hidrográfica
        rst_file_drenagem = gdal.Open(arquivo)
        
        # Lendo os dados raster como um array
        dados_lidos_drenagem = rst_file_drenagem.GetRasterBand(1).ReadAsArray()

        # Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_drenagem is not None:
            # Reorganizando os dados lidos na matriz destinadas às informações da drenagem da bacia hidrográfica
            self.global_vars.dren = dados_lidos_drenagem
            
            # Fechando o dataset GDAl referente ao arquivo raster
            rst_file_drenagem = None
        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {arquivo}"
            QMessageBox.warning(None, "ERROR!", resulte)


    def leh_modelo_numerico_dTerreno(self):
        """Esta função é utilizada para ler as informações acerca do modelo numérico do terreno (arquivo raster - .rst)"""

        # Obtendo o arquivo referente ao MDE da bacia hidrográfica
        arquivo = self.dlg_flow_tt.le_2_pg2.text()

        # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
        rst_file_MDE = gdal.Open(arquivo)

        # Lendo os dados raster como um array
        dados_lidos_MDE = rst_file_MDE.GetRasterBand(1).ReadAsArray()

        #  Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_MDE is not None:
            # Reoganizando os dados lidos em uma nova matriz que possuirá os dados ligados ao MDE da baciaa hidrográfica
            self.global_vars.MDE = dados_lidos_MDE

            # Fechando o dataset GDAL
            rst_file_MDE = None
        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {arquivo}"
            QMessageBox.warning(None, "ERROR!", resulte)

    def leh_precipitacao_24h(self):
        """Esta função é utilizada para ler as informações acerca da precipitação das últimas 24 horas, P24 (arquivo texto - .txt)"""

        # Armazenando o valor da precipitação de 24 horas em uma variável específica
        self.global_vars.P24 = float(self.dlg_flow_tt.le_6_pg2.text())

    def leh_uso_do_solo(self):
        """Esta função é utilizada para ler as informações acerca do uso do solo (arquivo raster - .rst)"""

        # Obtendo o arquivo raster referente ao uso do solo
        arquivo = self.dlg_flow_tt.le_5_pg2.text()

        # Abrindo o arquivo raster com as informações acerda do uso do solo da bacia hidrográfica
        rst_file_usoSolo = gdal.Open(arquivo)

        # Lendo os dados do arquivo raster como um array
        dados_lidos_usoSolo = rst_file_usoSolo.GetRasterBand(1).ReadAsArray()

        # Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_usoSolo is not None:
            # Reorganizando os dados lidos na matriz destinadas às informações da drenagem da bacia hidrográfica
            self.global_vars.usosolo = dados_lidos_usoSolo

            # Inicializando as variáveis fundamentais
            self.global_vars.Nusomax = np.amax(self.global_vars.usosolo)

        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {arquivo}"
            QMessageBox.warning(None, "ERROR!", resulte)

    def leh_drainage_area(self):
        """Esta função é utilizada para ler as informações acerca do uso do solo (arquivo raster - .rst)"""

        # Obtendo o arquivo raster referente ao uso do solo
        arquivo = self.dlg_flow_tt.le_9_pg2.text()

        # Abrindo o arquivo raster com as informações acerda do uso do solo da bacia hidrográfica
        rst_file_dren_area = gdal.Open(arquivo)

        # Lendo os dados do arquivo raster como um array
        dados_lidos_dren_area = rst_file_dren_area.GetRasterBand(1).ReadAsArray()

        # Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_dren_area is not None:
            # Reorganizando os dados lidos na matriz destinadas às informações da drenagem da bacia hidrográfica
            self.global_vars.dren_area = dados_lidos_dren_area

        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {arquivo}"
            QMessageBox.warning(None, "ERROR!", resulte)

    def leh_reservoir(self):
        """Esta função é utilizada para ler as informações acerca do uso do solo (arquivo raster - .rst)"""

        # Obtendo o arquivo raster referente ao uso do solo
        arquivo = self.dlg_flow_tt.le_10_pg2.text()

        # Abrindo o arquivo raster com as informações acerda do uso do solo da bacia hidrográfica
        rst_file_reservoir = gdal.Open(arquivo)

        # Lendo os dados do arquivo raster como um array
        dados_lidos_reservoir = rst_file_reservoir.GetRasterBand(1).ReadAsArray()

        # Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
        if rst_file_reservoir is not None:
            # Reorganizando os dados lidos na matriz destinadas às informações da drenagem da bacia hidrográfica
            self.global_vars.reservoir = dados_lidos_reservoir

        else:
            """Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro"""
            resulte = f"Failde to open the raster file: {arquivo}"
            QMessageBox.warning(None, "ERROR!", resulte)
                  
    def leh_valores_table_2(self):
        '''Esta função coleta as informações adicionadas nos itens da tabela das classes do uso e ocupação do solo e adiciona em suas variáveis'''
        # Verifica a dimensão da tabela
        nlin_tb = self.dlg_flow_tt.tbw_2_pg2.rowCount()
        ncol_tb = self.dlg_flow_tt.tbw_2_pg2.columnCount()

        # Cria variáveis necessárias
        uso_manning_val = []
        coef_maning_val = []
        coef_K = []

        # Itera sobre os itens da tabela
        for col in range(ncol_tb):
            for lin in range(nlin_tb):
                item_tb = self.dlg_flow_tt.tbw_2_pg2.item(lin,col).text()

                if item_tb is not None:
                    
                    # Coleta os ID's das classes
                    if col == 0:
                        # coleta o item da celula atual e tenta converter para int
                        item_tb = int(self.dlg_flow_tt.tbw_2_pg2.item(lin,col).text())

                        # Armazena o valor do ID em sua variável
                        uso_manning_val.append(item_tb)
                    
                    # Coleta os valores dos coeficiente de Mannning por classe
                    if col == 2:
                        # coleta o item da celula atual e tenta converter para float
                        item_tb = float(self.dlg_flow_tt.tbw_2_pg2.item(lin,col).text())

                        # Armazena o valor do coef. de Manning em sua variável
                        coef_maning_val.append(item_tb)

                    if col == 3
                        # coleta o item da celula atual e tenta converter para float
                        item_tb = float(self.dlg_flow_tt.tbw_2_pg2.item(lin,col).text())

                        # Armazena o valor do coef. de Manning em sua variável
                        coef_K.append(item_tb)

        # Adicionando cada valor às suas respectivas variáveis
        self.global_vars.usaux = uso_manning_val
        self.global_vars.Mann = coef_maning_val
        self.global_vars.coef_K = coef_K

    def project(self,x1, x2, y1,y2,tipo2,dist2,lado2,diagonal2):
        """Esta função calcula as distâncias sobre a superfície considerando o elipsóide WGS84"""
        # Definindo as constantes
        PI = 3.141592
        A = 6378.137 #comprimento do semi eixo maior do elipsóide (km)
        B = 6358.752 #comprimento do semi eixo menor do elipsóide (km)

        # Iniciando os cálulos
        ylat = (y1 + y2) / 2

        # Definição do achatamento do elipsóide
        f = (A - B) / A 
        # Determinando o quadrado da excentricidade
        e2 = (2*f) - (f**2) 
        # Determinando o raio da curvatura da Terra na latitude ylat
        rn = A / ((1 - e2*(np.sin(ylat)))**0.2) 

        # Calculando o raio da circunferência de um círculo determinado pelo plano que corta o elipsóide na latitude ylat
        raio_circ = rn*np.cos(ylat)
        dgx = x2 - x1
        dgy = y1 - y2

        dx = raio_circ*dgx*(PI/180.0)
        dy = rn*dgy*(PI/180.0)

        # Verificando o conteúdo da vairável tipo2 e atualizando a distanância com base nele
        if tipo2 == 1:
            dist2 = dx*lado2
        elif tipo2 == 2:
            dist2 = dy*lado2
        elif tipo2 == 3:
            dist2 = np.sqrt(dx**2+dy**2)*diagonal2/1.414

        self.global_vars.dist_2 = dist2

        return dist2

    def comprimento_acumulado(self):
        """Esta função determina o comprimento dos pixels que fazem partes da rede de drenagem da bacia hidrográfica. Da cabeceira ao exutório em questão"""
        # Define variáveis
        Lfoz = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.Lfoz= Lfoz
        Lac = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.Lac = Lac
        Lac = None
        Lfoz = None

        # Redefinindo as respectivas variáveis
        self.global_vars.lado = float(self.dlg_flow_tt.le_3_pg1.text())
        self.global_vars.diagonal = float(self.dlg_flow_tt.le_4_pg1.text())
        
        # Iniciando a iteração para varrer todos os elementos da bacia hidrográfica
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Delimitando apenas os elementos que estão presentes na bacia hidrográfica
                if self.global_vars.bacia[lin,col] == 1:
                    # Coletando as informações referentes ao sistema de drenagem da bacia hidrográfica
                    if self.global_vars.dren[lin,col] == 1:
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.caminho = 0
                        
                        while self.global_vars.caminho == 0:

                            # Criando condição de parada
                            condicao = self.global_vars.linaux <= 1 or self.global_vars.linaux >= self.rdc_vars.nlin \
                            or self.global_vars.colaux<=1 or self.global_vars.colaux>= self.rdc_vars.ncol \
                            or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux] == 0

                            if condicao:
                                self.global_vars.caminho = 1

                            else:
                                # Continuar caminho: determina a contagem das distâncias projetadas (WGS84) e \
                                # determina as coordenadas verticais do pixel+

                                self.global_vars.Xesq = self.rdc_vars.xmin + (self.global_vars.colaux - 1)*self.global_vars.Xres
                                self.global_vars.Xdir = self.global_vars.Xesq + self.global_vars.Xres
                                self.global_vars.Yinf = self.global_vars.ymax - self.global_vars.linaux*self.global_vars.Yres
                                self.global_vars.Ysup = self.global_vars.Yinf + self.global_vars.Yres

                                # Determinando a posição relativa ao pixel anterior
                                condicao2 = self.global_vars.linaux2 == self.global_vars.linaux or self.global_vars.colaux2 == self.global_vars.colaux
                                if condicao2:
                                    if self.global_vars.linaux2 == self.global_vars.linaux:
                                        self.rdc_vars.tipo = 1
                                    else:
                                        self.rdc_vars.tipo = 2
                                else:
                                    self.rdc_vars.tipo = 3

                                # Deteminando a distância incremental projetada
                                if self.global_vars.metro == 0:
                                    self.global_vars.auxdist = self.project(self.global_vars.Xesq,
                                                                        self.global_vars.Xdir,
                                                                        self.global_vars.Ysup,
                                                                        self.global_vars.Yinf,
                                                                        self.rdc_vars.tipo,
                                                                        self.global_vars.auxdist,
                                                                        self.global_vars.lado,
                                                                        self.global_vars.diagonal)
                                    
                                else:
                                    if self.rdc_vars.tipo == 1 or self.rdc_vars.tipo == 2:
                                        self.global_vars.auxdist = self.global_vars.dx*self.global_vars.lado

                                    else:
                                        self.global_vars.auxdist = self.global_vars.dx*self.global_vars.diagonal
                                        
                                # Atualizando o comprimento do rio desde o pixel inicial
                                self.global_vars.tamcam += self.global_vars.auxdist
                                self.global_vars.tamfoz = self.global_vars.tamcam

                                # Condição para verificar se o tamanho do rio é maior que o armazenameto do pixel
                                condicao3 = self.global_vars.tamcam > self.global_vars.Lac[self.global_vars.linaux, self.global_vars.colaux]
                                if condicao3:
                                    # O valor do pixel é armazenado em um novo rio
                                    self.global_vars.Lac[self.global_vars.linaux, self.global_vars.colaux] = self.global_vars.tamcam
                                
                                # Armazena o pixel contabilizado
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux

                                # determina o próximo píxel do caminho
                                self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux, self.global_vars.colaux]
                                self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                                self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]
                                # JVD: alocação redundante(caminho = 0)
                                self.global_vars.sda = 0

                        # Atulizando a variável lfoz
                        self.global_vars.Lfoz[lin][col] = self.global_vars.tamfoz

    def numera_pixel(self):
        '''
        Esta função enumera os píxels presentes na rede de drenagem
        '''
        # Define variáveis
        self.contadren = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol), dtype=np.float64)
        self.numcabe = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol), dtype=np.float64)
        self.cabeceira = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.numcabeaux = 0
        
        # Enumerando os píxels pertencentes à bacia e à rede de drenagem
        pix_bacia_e_dren = (self.global_vars.bacia == 1) & (self.global_vars.dren == 1)

        self.rdc_vars.cont += np.sum(pix_bacia_e_dren)

        self.contadren[pix_bacia_e_dren] = self.rdc_vars.cont

        pixel_dren = np.where(self.global_vars.dren == 1)
        self.global_vars.lincontadren = np.array(pixel_dren[0])
        self.global_vars.colcontadren = np.array(pixel_dren[1])


        # Numeração dos píxels internos a bacia: São chamados de cabeceira, pois o caminho do fluxo é iniciado a partir de cada um deles
        for col in range(1, self.rdc_vars.ncol - 1):
            for lin in range(1, self.rdc_vars.nlin - 1):
            
                # Atualizará apenas os píxel que estão na bacia hidrográfica(cabeceira == 1)
                if self.global_vars.bacia[lin][col] == 1:
                    # A priori, todos os píxels serão considerados de cabeceira
                    self.cabeceira[lin][col] = 1
                    # Cria vizinhança 3x3 para estudar a direção de fluxo do píxel central.
                    for linaux in range(lin - 1, lin + 2):
                        for colaux in range(col - 1, col + 2):
                            # Para cada vizinho, verifica a direção de fluxo dela e para qual pixel ele drena
                            self.global_vars.diraux = self.global_vars.direcoes[linaux][colaux]
                            self.global_vars.linaux2 = linaux + self.global_vars.dlin[self.global_vars.diraux]
                            self.global_vars.colaux2 = colaux + self.global_vars.dcol[self.global_vars.diraux]

                            # Se algum vizinho drenar para o central em análise, este não é de cabeceira
                            if self.global_vars.linaux2 == lin and self.global_vars.colaux2 == col:
                                self.cabeceira[lin][col] = 0

                    # Contagem de píxels que são cabeceira
                    if self.cabeceira[lin][col] == 1:
                        self.numcabeaux += 1
                        self.numcabe[lin][col] = self.numcabeaux

        # Atualiza variáveis globais
        self.global_vars.numcabe = self.numcabe

        # JVD: redundancia de variáveis, Ncabe = numcabeaux
        self.global_vars.numcabeaux = self.numcabeaux

    def dist_drenagem(self):
        """Esta funçao determina a distância incremental percorrida pela água na rede de drenagem,
            assim como a declividade pixel a pixel"""

        # Redimenciona as variáveis necessárias
        dist = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        pixeldren = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.pixeldren = pixeldren
        pixeldren = None
        Difcota = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.Difcota = Difcota
        Difcota = None
        DECLIVpixjus = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.DECLIVpixjus = DECLIVpixjus
        DECLIVpixjus = None
        TSpix = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.TSpix = TSpix
        TSpix = None

        # Atualizando as referidas variáveis
        self.global_vars.lado = float(self.dlg_flow_tt.le_3_pg1.text())
        self.global_vars.diagonal = float(self.dlg_flow_tt.le_4_pg1.text())

        # iterando sobre os elementos do arquivo raster
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Relaizando operações no apenas na região da bacia hidográfica
                if self.global_vars.bacia[lin][col] == 1:
                    self.global_vars.linaux = lin
                    self.global_vars.colaux = col
                    self.global_vars.caminho = 0
                    self.global_vars.tamcam = 0.0

                    if self.global_vars.dren[lin][col] == 1:
                        self.global_vars.caminho = 1

                    else:
                        while self.global_vars.caminho == 0:
                            
                            condicao = (self.global_vars.linaux<= 1
                            or self.global_vars.linaux>=self.rdc_vars.nlin
                            or self.global_vars.colaux<=1 or self.global_vars.colaux>= self.rdc_vars.ncol
                            or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux]==0)

                            # Verificando a resposta da variável condicao
                            if condicao:
                                self.global_vars.caminho = 1
                            
                            else:
                                # Criando a segunda condição: 
                                # valores pertencentes ao sistema de drenagem da bacia
                                condicao2 = self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] == 1

                                if condicao2:
                                    # Após alocação do pixel da rede de drenagem: encerra o processo de busca
                                    self.global_vars.caminho = 1
                                    dist[lin][col] = self.global_vars.tamcam
                                    self.global_vars.pixeldren[lin][col] = self.contadren[self.global_vars.linaux][self.global_vars.colaux]
                                else:
                                    self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                                    self.global_vars.caminho = 0
                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.linaux2 = self.global_vars.linaux

                                    self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                                    self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]

                                    # Calculando a distância incremental percorrida &
                                    # Contabilizar distancias projetadas (WGS84) &
                                    # Determina coordenadas vertices do pixel
                                    self.global_vars.Xesq = self.rdc_vars.xmin + (self.global_vars.colaux2 - 1) * self.global_vars.Xres
                                    self.global_vars.Xdir = self.global_vars.Xesq + self.global_vars.Xres
                                    self.global_vars.Yinf = self.rdc_vars.ymax - self.global_vars.linaux2 * self.global_vars.Yres
                                    self.global_vars.Ysup = self.global_vars.Yinf + self.global_vars.Yres

                                    # Determina a posição relativa ao píxel anterior
                                    condicao3 = self.global_vars.linaux2 == self.global_vars.linaux or self.global_vars.colaux2 == self.global_vars.colaux
                                    if condicao3:
                                        if self.global_vars.linaux2 == self.global_vars.linaux:
                                            self.rdc_vars.tipo = 1
                                        else:
                                            self.rdc_vars.tipo = 2
                                    else:
                                        self.rdc_vars.tipo = 3

                                    # Determinando a distância incremental projetada
                                    if self.global_vars.metro == 0:
                                        self.global_vars.auxdist = self.project(self.global_vars.Xesq,
                                                           self.global_vars.Xdir,
                                                           self.global_vars.Ysup,
                                                           self.global_vars.Yinf,
                                                           self.rdc_vars.tipo,
                                                           self.global_vars.auxdist,
                                                           self.global_vars.lado,
                                                           self.global_vars.diagonal)
                                    else:
                                        condicao4 = self.rdc_vars.tipo == 1 or self.rdc_vars.tipo == 2
                                        if  condicao4:
                                            self.global_vars.auxdist = self.global_vars.dx * self.global_vars.lado
                                        else:
                                            self.global_vars.auxdist = self.global_vars.dx * self.global_vars.diagonal
                                    
                                    # atualiza o comprimento do rio desde o pixel inicial
                                    self.global_vars.tamcam += self.global_vars.auxdist

                                    # ARPdeclivjus
                                    if self.global_vars.tipo_decliv == 4:
                                        # calcula declividade do pixel relativo ao pixel de jusante (este pixel)
                                        self.global_vars.Lincr = self.global_vars.auxdist
                                        self.global_vars.Difcota = self.global_vars.MDE[self.global_vars.linaux2][self.global_vars.colaux2] - self.global_vars.MDE[self.global_vars.linaux][self.global_vars.colaux]
                                        self.global_vars.DECLIVpixjus[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.Difcota/self.global_vars.Lincr*1000.0
                                        self.global_vars.Streaux = self.global_vars.DECLIVpixjus[self.global_vars.linaux2][self.global_vars.colaux2]
                                        self.global_vars.Ltreaux = self.global_vars.Lincr
                                        self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux2][self.global_vars.colaux2]
                                        self.global_vars.Smin = float(self.dlg_flow_tt.le_1_pg1.text()) #em m/km

                                        if self.global_vars.Streaux < self.global_vars.Smin:
                                            self.global_vars.Streaux = self.global_vars.Smin
                                        
                                        self.global_vars.Smax = float(self.dlg_flow_tt.le_2_pg1.text()) #em m/km
                                        if self.global_vars.Streaux > self.global_vars.Smax:
                                            self.global_vars.Streaux = self.global_vars.Smax

                                        # JVD: correção da indexação para o python (inicia no zero)
                                        # Calcula o TS por píxel
                                        self.global_vars.TSpix[self.global_vars.linaux2][self.global_vars.colaux2] = 5.474 * ((self.global_vars.Mann[self.global_vars.usaux - 1] *self.global_vars.Ltreaux)**0.8) \
                                            / ((self.global_vars.P24**0.5)*((self.global_vars.Streaux/1000.0)**0.4))
        # Atualiza as variáveis globais
        self.global_vars.DIST = dist

    def dist_trecho(self):
        ''' Esta função determina o número dos diferentes trechos que existem na bacia hidrográfica estudada'''
        self.global_vars.numtreauxmax = 0
        TREpix = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.TREpix = TREpix
        TREpix = None
        condicao1 = None
        
        #ARPlidar: loop para contar o número máximo de trechos
        for col in range(1, self.rdc_vars.ncol):
            for lin in range(1, self.rdc_vars.nlin):

                # Ações realizadas apenas na região da bacia
                if self.global_vars.bacia[lin][col] == 1:

                    # ARPlidar
                    if self.global_vars.numcabe[lin][col] > 0:
                        self.global_vars.numcabeaux = int(self.global_vars.numcabe[lin][col])
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.linaux2 = lin
                        self.global_vars.colaux2 = col
                        self.global_vars.linaux3 = lin
                        self.global_vars.colaux3 = col
                        self.global_vars.numtreaux = 0
                        self.global_vars.caminho = 0
                        self.global_vars.usaux = self.global_vars.usosolo[lin][col]
                        self.global_vars.usaux2 = self.global_vars.usaux

                        # ARPlidar
                        # Grava qual trecho o píxel em questão pertence
                        self.global_vars.numtreaux2 = 1

                        while self.global_vars.caminho == 0:
                            self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                            self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                            self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]


                            condicao1 = self.global_vars.usaux != self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]
                            condicao2 = self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] == 1
                           
                            if condicao1 or condicao2:
                                # Mudou o uso do solo ou alcançou a rede de drenagem,
                                # então terminou um trecho no píxel anterior
                                self.global_vars.numtreaux += 1

                                if self.global_vars.numtreaux > self.global_vars.numtreauxmax:
                                    self.global_vars.numtreauxmax = self.global_vars.numtreaux

                                # ARPlidar: incluindo o teste da bacia
                                condicao3 = self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] == 1 or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux] == 0
                                if condicao3:
                                    self.global_vars.caminho = 1
                                else:
                                    # Continua o caminho, porém em um trecho novo
                                    self.global_vars.linaux2 = self.global_vars.linaux
                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.linaux3 = self.global_vars.linaux
                                    self.global_vars.colaux3 = self.global_vars.colaux
                                    self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]
                                    # ARPdecliv
                                    # Grava qual trecho o píxel em questão pertence
                                    self.global_vars.numtreaux2 += 1
                            else:
                                # Vai continuar caminhando, mas grava o valor do par (lin,col) do último píxel acessado
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux
                                self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

        self.global_vars.Ntre = self.global_vars.numtreauxmax + 1

        # Percorrendo o caminho desde as cabeceiras e granvando as distâncias relativas de cada trecho de uso do solo contínuo

        # Redimenciona variáveis necessárias
        cotaini = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.cotaini = cotaini
        containi = None
        cotafim = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.cotafim = cotafim
        cotafim = None
        Ltre = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.Ltre = Ltre
        Ltre = None
        Stre = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.Stre = Stre
        Stre = None
        usotre = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.usotre = usotre
        usotre = None
        DISTult = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.DISTult = DISTult
        DISTult = None
        refcabtre  = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        self.global_vars.refcabtre = refcabtre
        refcabtre = None
        DISTtre  = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        self.global_vars.DISTtre = DISTtre
        DECLIVpix  = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        self.global_vars.DECLIVpix = DECLIVpix
        DECLIVpix = None
        CABEpix = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        self.global_vars.CABEpix = CABEpix
        CABEpix = None

        # Continua o cálculo dos trechos
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Verificando os elementos da região da bacia
                if self.global_vars.numcabe[lin][col] > 0:
                    self.global_vars.numcabeaux = int(self.global_vars.numcabe[lin][col])
                    self.global_vars.linaux = lin
                    self.global_vars.colaux = col
                    self.global_vars.linaux2 = lin
                    self.global_vars.colaux2 = col
                    self.global_vars.linaux3 = lin
                    self.global_vars.colaux3 = col
                    self.global_vars.numtreaux = 0
                    self.global_vars.caminho = 0
                    self.global_vars.usaux = self.global_vars.usosolo[lin][col]
                    self.global_vars.usaux2 = self.global_vars.usaux

                    # ARPdecliv
                    # Grava qual trecho o píxel em questão pertence
                    self.global_vars.numtreaux2 = 1
                    self.global_vars.TREpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numcabeaux2

                    while self.global_vars.caminho == 0:
                        self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                        self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                        self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]

                        if condicao1 or condicao2:
                            # Mudou o tipo de uso do solo ou alcançou a rede de drenagem,
                            # então terminou o trecho no píxel anterior
                            self.global_vars.numtreaux +=1
                            self.global_vars.numtre[self.global_vars.numcabeaux] = self.global_vars.numtreaux
                            self.global_vars.Ltre[self.global_vars.numcabeaux][self.global_vars.numtreaux] = self.global_vars.DIST[self.global_vars.linaux3][self.global_vars.colaux3] \
                                                                                                            - self.global_vars.DIST[self.global_vars.linaux][self.global_vars.colaux] 
                                                                                                            
                            # Grava a distância (DIST) do último píxel do trecho
                            self.global_vars.DISTult[self.global_vars.numcabeaux][self.global_vars.numtreaux] = self.global_vars.DIST[self.global_vars.linaux][self.global_vars.colaux]
                            self.global_vars.cotaini[self.global_vars.numcabeaux][self.global_vars.numtreaux] = self.global_vars.MDE[self.global_vars.linaux3][self.global_vars.colaux3]
                            self.global_vars.cotafim[self.global_vars.numcabeaux][self.global_vars.numtreaux] = self.global_vars.MDE[self.global_vars.linaux][self.global_vars.colaux]
                            
                            a1 = (self.global_vars.cotaini[self.global_vars.numcabeaux][self.global_vars.numtreaux] - self.global_vars.cotafim[self.global_vars.numcabeaux][self.global_vars.numtreaux])
                            b1 = self.global_vars.Ltre[self.global_vars.numcabeaux][self.global_vars.numtreaux]*1000.0
                            self.global_vars.Stre[self.global_vars.numcabeaux][self.global_vars.numtreaux] = a1 / b1
                            self.global_vars.usotre[self.global_vars.numcabeaux][self.global_vars.numtreaux] = self.global_vars.usaux

                            # ARPlidar: adiciona a bacia como condição; chegar na rede de drenagem ou sair da baica, finaliza while
                            condicao4 = self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] == 1 or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux] == 0
                            if condicao4:
                                self.global_vars.caminho = 1
                                self.global_vars.refcabtre[self.global_vars.linaux3][self.global_vars.colaux3] = self.global_vars.numtreaux
                                self.global_vars.refcabtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux

                            else:
                                # Vai continuar o cominho, mas em um novo trecho
                                self.global_vars.refcabtre[self.global_vars.linaux3][self.global_vars.colaux3] = self.global_vars.numtreaux
                                self.global_vars.refcabtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux

                                self.global_vars.linaux3 = self.global_vars.linaux
                                self.global_vars.colaux3 = self.global_vars.colaux
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux
                                self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                                # ARPdecliv
                                # Grava qual trecho o píxel em questão pertence
                                self.global_vars.numtreaux2 += 1
                                self.global_vars.TREpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux2

                        else:
                            # Vai continuar caminhando, mas grava o valor do par (lin,col) do último píxel acessado
                            self.global_vars.refcabtre[self.global_vars.linaux3][self.global_vars.colaux3] = self.global_vars.numtreaux + 1
                            self.global_vars.refcabtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux + 1
                            
                            self.global_vars.linaux2 = self.global_vars.linaux
                            self.global_vars.colaux2 = self.global_vars.colaux
                            self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                            # ARPdecliv
                            # Grava qual trecho o píxel em questão pertence
                            self.global_vars.TREpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numtreaux2

        # Percorre novamente o caminho desde às cabeceiras, gravando distancias relativas de cada pixel dentro de cada trecho de uso do solo continuo
        # Percorrendo os elementos da bacia hidrográfica
        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Os cálculos são executados apenas na região da bacia hidrográfica
                if self.global_vars.bacia[lin][col] == 1:
                    # ARPlidar
                    if self.global_vars.numcabe[lin][col] > 0:
                        self.global_vars.numcabeaux = int(self.global_vars.numcabe[lin][col])
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.linaux2 = lin
                        self.global_vars.colaux2 = col
                        self.global_vars.linaux3 = lin
                        self.global_vars.colaux3 = col
                        self.global_vars.numtreaux = 0
                        self.global_vars.caminho = 0
                        self.global_vars.usaux = self.global_vars.usosolo[lin][col]
                        self.global_vars.usaux2 = self.global_vars.usaux

                        # Grava a distância do píxel relativo ao trecho
                        self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.DIST[lin][col] - self.global_vars.DISTult[self.global_vars.numcabeaux][1]

                        # ARPdecliv: calcula a declividade do píxel relativo ao último píxel do trecho
                        c1 = (self.global_vars.MDE[self.global_vars.linaux2][self.global_vars.colaux2] - self.global_vars.cotafim[self.global_vars.numcabeaux][1])
                        d1 = self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2]*1000.0 
                        self.global_vars.DECLIVpix[[self.global_vars.linaux2][self.global_vars.colaux2]] = c1 / d1

                        # Grava qual cabeceira o píxel em questão faz parte
                        self.global_vars.CABEpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numcabeaux

                        while self.global_vars.caminho == 0:
                            self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                            self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                            self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]
                            
                            if condicao1 or condicao2:
                                # Mudou o tipo de uso do solo ou alcançou a rede de drenagem, 
                                # então terminou um trecho no píxel anterior
                                self.global_vars.numtreaux += 1
                                self.global_vars.numtre[self.global_vars.numtreaux] = self.global_vars.numtreaux
                                
                                # Grava a distância do píxel relativo ao trecho
                                self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux] = self.global_vars.DIST[self.global_vars.linaux][self.global_vars.colaux] - self.global_vars.DISTult[self.global_vars.numcabeaux][self.global_vars.numcabeaux + 1]

                                self.global_vars.usotre[self.global_vars.numcabeaux][self.global_vars.numcabeaux] = self.global_vars.usaux

                                # ARPlidar: adiciona a bacia hidrográfica como uma condição
                                if self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] ==1 or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux] == 0:
                                    self.global_vars.caminho = 1
                                else:
                                    # Vai continuar o caminho, porém em um novo trecho
                                    self.global_vars.linaux3 = self.global_vars.linaux
                                    self.global_vars.colaux3 = self.global_vars.colaux
                                    self.global_vars.linaux2 = self.global_vars.linaux
                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                                    # Grava qual cabeceira o píxel em questão faz parte
                                    self.global_vars.CABEpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numcabeaux

                                    # Calcula a declividade do píxel relativo ao último píxel do trecho
                                    e1 = self.global_vars.MDE[self.global_vars.linaux2][self.global_vars.colaux2] - self.global_vars.cotafim[self.global_vars.numcabeaux][self.global_vars.numcabeaux + 1] 
                                    f1 = self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2]*1000.0
                                    self.global_vars.DECLIVpix[self.global_vars.linaux2][self.global_vars.colaux2] = e1 / f1

                            else:
                                # Vai continuar caminhando, e grava os valores dos pares (nlin,ncol) do último píxel que passou           
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux
                                self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                                # Grava qual cabeceira o píxel em questão pertence
                                self.global_vars.CABEpix[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.numcabeaux

                                # Grava a DIST do píxel relativo ao trecho
                                self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2] = self.global_vars.DIST[self.global_vars.linaux2][self.global_vars.colaux2] \
                                                                                                               - self.global_vars.DISTult[self.global_vars.numcabeaux][self.global_vars.numtreaux + 1]

                                # ARPdecliv: Calcula a declividade o píxel relativo ao último píxel do trecho  
                                g1 = self.global_vars.MDE[self.global_vars.linaux2][self.global_vars.colaux2] - self.global_vars.cotafim[self.global_vars.numcabeaux][self.global_vars.numtreaux + 1]
                                h1 = self.global_vars.DISTtre[self.global_vars.linaux2][self.global_vars.colaux2]*1000.0
                                self.global_vars.DECLIVpix[self.global_vars.linaux2][self.global_vars.colaux2] =  g1/h1
        
        # Redimenciona variáveis necessárias
        Somaaux = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.Somaaux = Somaaux
        Somaaux = None
        SomaauxPond = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.SomaauxPond = SomaauxPond
        SomaauxPond = None
        SomaauxDist = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.SomaauxDist = SomaauxDist
        SomaauxDist = None
        contaaux = np.zeros((self.global_vars.numcabeaux,self.global_vars.Ntre))
        self.global_vars.contaaux = contaaux
        contaaux = None

        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Os cálculo são realizados apenas na região da baica hidrográficia 
                if self.global_vars.bacia[lin][col] == 1:
                    # ARPlidar
                    if self.global_vars.numcabe[lin][col] > 0:
                        self.global_vars.numcabeaux = self.global_vars.numcabe[lin][col]
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.linaux2 = lin
                        self.global_vars.colaux2 = col
                        self.global_vars.linaux3 = lin
                        self.global_vars.colaux3 = col
                        self.global_vars.numtreaux = 0
                        self.global_vars.caminho = 0
                        self.global_vars.usaux = self.global_vars.usosolo[lin][col]
                        self.global_vars.usaux2 = self.global_vars.usaux

                        # ARPdecliv
                        self.global_vars.numtreaux2 = 1

                        # Para o cálculo da média aritmética
                        self.global_vars.Somaaux[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DECLIVpix[lin][col]
                        self.global_vars.contaaux[self.global_vars.numcabeaux][self.global_vars.numtreaux2] = self.global_vars.Somaaux[self.global_vars.numcabeaux][self.global_vars.numtreaux2] + 1

                        # Para o cálculo da média ponderada
                        self.global_vars.Somaauxpond[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DECLIVpix[lin][col] * self.global_vars.DISTtre[lin][col]
                        self.global_vars.SomaauxDist[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DISTtre[lin][col]

                        while self.global_vars.caminho == 0:
                            self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                            self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                            self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]
                            

                            if condicao1 or condicao2:
                                # Mudou o tipo de uso do solo ou alcançou a rede de drenagem, 
                                # então terminou um trecho no píxel anterior
                                self.global_vars.numtreaux += 1
                                 # ARPlidar: adiciona a bacia hidrográfica como uma condição
                                if self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux] == 1 or self.global_vars.bacia[self.global_vars.linaux][self.global_vars.colaux] == 0:
                                    self.global_vars.caminho = 1
                                else:
                                    # Vai continuar o caminho, porém em um novo trecho
                                    self.global_vars.linaux3 = self.global_vars.linaux
                                    self.global_vars.colaux3 = self.global_vars.colaux
                                    self.global_vars.linaux2 = self.global_vars.linaux
                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]

                                    # ARPdecliv: grava qual trecho o píxel em questão pertence
                                    self.global_vars.numtreaux2 += 1

                                    # ARPdecliv: para a média aritmética
                                    self.global_vars.Somaaux[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DECLIVpix[self.global_vars.linaux][self.global_vars.colaux]
                                    self.global_vars.contaaux[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += 1

                                    # ARPdecliv: para a média ponderada
                                    self.global_vars.Somaauxpond[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DECLIVpix[self.global_vars.linaux][self.global_vars.colaux] * self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux]
                                    self.global_vars.SomaauxDist[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux]
                            
                            else:
                                # Vai continuar caminhando, e grava os valores dos pares (nlin,ncol) do último píxel que passou        
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux
                                self.global_vars.usaux = self.global_vars.usosolo[self.global_vars.linaux][self.global_vars.colaux]


                                # ARPdecliv: para a média aritmética
                                self.global_vars.Somaaux[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DECLIVpix[self.global_vars.linaux][self.global_vars.colaux]
                                self.global_vars.contaaux[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += 1

                                # ARPdecliv: para a média ponderada
                                self.global_vars.Somaauxpond[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DECLIVpix[self.global_vars.linaux][self.global_vars.colaux] * self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux]
                                self.global_vars.SomaauxDist[self.global_vars.numcabeaux][self.global_vars.numtreaux2] += self.global_vars.DISTtre[self.global_vars.linaux][self.global_vars.colaux]
                                             
    def tempo_canal(self):
        '''
        Esta função é responsável por determinar o tempo de viagem/concentração da água da foz até o exutório da bacia hidrográfica
        '''
        # Declara e redemenciona variáveis
        condicao = None
        condicao2 = None
        TempoRio = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        self.global_vars.TempoRio = TempoRio
        TempoRio = None

        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # O cáclulos são executados apenas na região da bacia
                if self.global_vars.bacia[lin][col] == 1:
                    # Os cálculos acontecerão na rede de drenagem da bacia hidrográfica
                    if  self.global_vars.dren[lin][col] == 1:
                        self.global_vars.linaux = lin
                        self.global_vars.colaux = col
                        self.global_vars.linaux1 = lin
                        self.global_vars.colaux1 = col
                        self.global_vars.linaux2 = lin
                        self.global_vars.colaux2 = col
                        self.global_vars.caminho = 0
                        self.global_vars.Tempoauxac = 0

                        # Guarda as características do tipo de trecho que o píxel em questão faz parte
                        self.classerio_aux = self.global_vars.classerio[lin][col]

                        while self.global_vars.caminho == 0:
                            condicao = self.global_vars.linaux < 1 or self.global_vars.linaux > self.rdc_vars.nlin or self.global_vars.colaux < 1 or self.global_vars.colaux > self.rdc_vars.ncol    
                            
                            if condicao:
                                self.global_vars.caminho = 1

                                # Contabilizando o último trecho
                                self.global_vars.Lfozaux1 = self.global_vars.Lfoz[self.global_vars.linaux1][self.global_vars.colaux1]
                                self.global_vars.Lfozaux2 = self.global_vars.Lfoz[self.global_vars.linaux2][self.global_vars.colaux2]
                                # Determina a diferença entre o píxel do Lfoz inicial e o do final
                                self.global_vars.Laux = self.global_vars.Lfozaux1 - self.global_vars.Lfozaux2
                                
                                # A declividade(Saux), o coeficiente de Manning(naux) e o raio hidráulico(Rhaux) são aqueles do tipo de rio (rede de drenagem)
                                self.global_vars.Saux = self.global_vars.Sclasse[self.classerio_aux]
                                self.global_vars.naux = self.global_vars.Mannclasse[self.classerio_aux]
                                self.global_vars.Rhaux = self.global_vars.Rhclasse[self.classerio_aux]

                                # Determinando a velocidade do percurso
                                condicao1 = self.global_vars.linaux2 == self.global_vars.linaux and self.global_vars.colaux2 == self.global_vars.colaux1
                                if condicao1:
                                    # Significa que não há mudança de pixel, ou seja, o pixel a montante é igual ao de jusante
                                    self.global_vars.Velaux = 0
                                    self.global_vars.Tempoaux = 0
                                else:
                                    # Determina a velocidade por percurso
                                    self.global_vars.Velaux = self.global_vars.Rhaux ** (2.0/3.0)*self.global_vars.Saux**(1.0/2.0)/self.global_vars.naux
                                    
                                    # Calculando o tempo de viagem/concentração do percuso em min
                                    # em que: Laux em metros e Velaux em m/s; resultado em min
                                    self.global_vars.Tempoaux = self.global_vars.Laux / self.global_vars.Velaux / 60.0
                                
                                # O tempo é acocumulado desde o primeiro percurso
                                self.global_vars.Tempoauxac += self.global_vars.Tempoaux
                            
                                # Após o fim do traçado desde o inicío do píxel, o tempo será armazenado e o acumulador zerado
                                self.global_vars.TempoRio[lin][col] = self.global_vars.Tempoauxac
                                self.global_vars.Tempoauxac = 0
                        
                            else:
                                condicao2 = self.global_vars.classerio[self.global_vars.linaux][self.global_vars.colaux] != self.classerio_aux
                                # Checando se o caminho ainda está no trecho de mesma classe
                                if condicao2:
                                    self.global_vars.Lfozaux1 = self.global_vars.Lfoz[self.global_vars.linaux1][self.global_vars.colaux1]
                                    self.global_vars.Lfozaux2 = self.global_vars.Lfoz[self.global_vars.linaux2][self.global_vars.colaux2]

                                    # Determina a diferença entre o píxel do Lfoz inicial e o do final
                                    self.global_vars.Laux = self.global_vars.Lfozaux1 - self.global_vars.Lfozaux2
                                    
                                    # A declividade(Saux), o coeficiente de Manning(naux) e o raio hidráulico(Rhaux) são aqueles do tipo de rio (rede de drenagem)
                                    self.global_vars.Saux = self.global_vars.Sclasse[self.classerio_aux]
                                    self.global_vars.naux = self.global_vars.Mannclasse[self.classerio_aux]
                                    self.global_vars.Rhaux = self.global_vars.Rhclasse[self.classerio_aux]

                                    # Determinando a velocidade do percurso
                                    condicao1 = self.global_vars.linaux2 == self.global_vars.linaux and self.global_vars.colaux2 == self.global_vars.colaux1
                                    if condicao1:
                                        self.global_vars.Velaux = 0
                                        self.global_vars.Tempoaux = 0
                                    else:
                                        self.global_vars.Velaux = self.global_vars.Rhaux ** (2.0/3.0)*self.global_vars.Saux**(1.0/2.0)/self.global_vars.naux
                                        
                                        # Calculando o tempo de viagem/concentração do percuso em min 
                                        # em que: Laux em metros e Velaux em m/s; resultado em min
                                        self.global_vars.Tempoaux = self.global_vars.Laux / self.global_vars.Velaux / 60.0
                                    
                                    # O tempo é acocumulado desde o primeiro percurso
                                    self.global_vars.Tempoauxac += self.global_vars.Tempoaux

                                    # Atualizando o novo ponto de partida
                                    self.global_vars.linaux1 = self.global_vars.linaux
                                    self.global_vars.colaux1 = self.global_vars.colaux
                                    self.classerio_aux = self.global_vars.classerio[self.global_vars.linaux1][self.global_vars.colaux1]
                                
                                # Armazenando o píxel contabilizado
                                self.global_vars.linaux2 = self.global_vars.linaux
                                self.global_vars.colaux2 = self.global_vars.colaux  

                                # Deteminando o próximo píxel do caminho
                                self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                                self.global_vars.caminho = 0 
                                self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                                self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]
    def tempo_sup(self):
        """
        Esta função função determina o tempo de concentração/escoamento para os píxels da superfície da rede de drenagem (aqueles que não são canais)
        """
        # Redimenciona as variáveis necessárias
        lincabe = np.zeros(self.global_vars.numcabeaux)
        self.global_vars.lincabe = lincabe
        lincabe = None
        colcabe = np.zeros(self.global_vars.numcabeaux)
        self.global_vars.colcabe = colcabe
        colcabe = None
        TS = np.zeros((self.global_vars.numcabeaux, self.global_vars.Ntre))
        self.global_vars.TS = TS
        TS = None
        TScabe = np.zeros(self.global_vars.numcabeaux)
        self.global_vars.TScabe = TScabe
        TScabe = None
        TScabe2d = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.TScabe2d = TScabe2d
        TScabe2d = None
        TSnaocabe2d = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.TSnaocabe2d = TSnaocabe2d
        TSnaocabe2d = None
        TSpixacum = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.global_vars.TSpixacum = TSpixacum
        TSpixacum = None

        for lin in range(self.rdc_vars.nlin):
            for col in range(self.global_vars):
                if self.global_vars.numcabe[lin][col] > 0:
                    self.global_vars.numcabeaux = int(self.global_vars.numcabe[lin][col])
                    self.global_vars.lincabe[self.global_vars.numcabeaux] = lin
                    self.global_vars.colcabe[self.global_vars.numcabeaux] = col


        for item in range(self.global_vars.Ncabec):
            self.global_vars.numtreaux = self.global_vars.numtre[item]
            for t in range(self.global_vars.numtreaux):
                self.global_vars.usaux = self.global_vars.numtre[self.global_vars.numcabeaux][t]
                self.global_vars.Ltreaux = self.global_vars.Ltre[self.global_vars.numcabeaux][t]
                self.global_vars.Streaux = self.global_vars.Stre[self.global_vars.numcabeaux][t] 

                if self.global_vars.Streaux > 0:
                    # Determinando o TS: tempo de concentração
                    self.global_vars.TS[self.global_vars.numcabeaux][t] = 5.474 * ((self.global_vars.Mann[self.global_vars.usaux]*self.global_vars.Ltreaux)**0.8)/((self.global_vars.P24**0.5)*((self.global_vars.Streaux/1000.0)**0.4))
                else:
                    self.global_vars.TS[self.global_vars.numcabeaux][t] = 0
                
                self.global_vars.TScabe[self.global_vars.numcabeaux] += self.global_vars.TS[self.global_vars.numcabeaux][t]
            
            lin1 = self.global_vars.lincabe[self.global_vars.numcabeaux]
            col1 = self.global_vars.colcabe[self.global_vars.numcabeaux]
            self.global_vars.TScabe2d[lin1][col1] = self.global_vars.TScabe[self.global_vars.numcabeaux]
        
        for lin in range(self.rdc_vars.nlin):
            for col in range(self.rdc_vars.ncol):
                # As ações são baseadas na região da bacia hidrográfica
                if self.global_vars.bacia[lin][col] == 1:
                    self.global_vars.numcabeaux = int(self.global_vars.CABEpix[lin][col])
                    self.global_vars.Taux = 0

                    # Verificando se o píxel é válido; executando cabeceiras
                    if self.global_vars.numcabeaux > 0 and self.global_vars.numcabe[lin][col] == 0:
                        
                        self.global_vars.t = self.global_vars.refcabtre[lin][col]
                        self.global_vars.Ltreaux = self.global_vars.Ltre[self.global_vars.numcabeaux][self.global_vars.t]
                        self.global_vars.Ttreaux = self.global_vars.TS[self.global_vars.numcabeaux][self.global_vars.t]
                        self.global_vars.DISTtreaux = self.global_vars.DISTtre[lin][col]
                        self.global_vars.Taux = self.global_vars.DISTtreaux * self.global_vars.Ttreaux / self.global_vars.Ltreaux

                        # ARPdecliv
                        if self.global_vars.subtipodecliv == 'b':
                            self.global_vars.Streaux = self.global_vars.Stre[self.global_vars.numcabeaux][self.global_vars.t]
                            self.global_vars.usaux = self.global_vars.usotre[self.global_vars.numcabeaux][self.global_vars.t]
                            
                            if self.global_vars.Streaux > 0:
                                self.global_vars.Taux = 5.474 * ((self.global_vars.Mann[self.global_vars.usaux] * self.global_vars.DISTtreaux)**0.8) / ((self.global_vars.P24**0.5)*((self.global_vars.Streaux / 1000.0)**0.4))
                            else:
                                self.global_vars.Taux = 0

                        self.global_vars.numtreaux = self.global_vars.numtre[self.global_vars.numcabeaux]

                        if self.global_vars.t < self.global_vars.numtreaux:
                            tt = self.global_vars.t + 1
                            for tt in range(self.global_vars.numtreaux):
                                self.global_vars.Taux += self.global_vars.TS[self.global_vars.numcabeaux][tt]
                        
                        self.global_vars.TSnaocabe2d[lin][col] = self.global_vars.Taux

        self.global_vars.TStodos2d = self.global_vars.TSnaocabe2d + self.global_vars.TScabe2d

        if self.global_vars.tipo_decliv == 4:

            for col in range(self.rdc_vars.ncol):
                for lin in range(self.rdc_vars.nlin):
                    # Exclindo a região fora da bacia
                    self.global_vars.linaux = lin
                    self.global_vars.colaux = col
                    self.global_vars.caminho = 0 
                    self.global_vars.tempocam = 0.0
                    
                    # Para píxels que representam a rede de drenagem
                    if self.global_vars.dren[lin][col]== 1:
                        self.global_vars.caminho = 1
                    else:
                        while self.global_vars.caminho == 0:
                            condicao = self.global_vars.linaux <= 1 or self.global_vars.linaux >=self.rdc_vars.nlin or self.global_vars.colaux <= 1 or self.global_vars.colaux >=self.rdc_vars.nlin \
                                                                    or self.global_vars.bacia[self.global_vars.colaux][self.global_vars.colaux]==0
                            if condicao:
                                self.global_vars.caminho = 1
                            else:
                                if self.global_vars.dren[self.global_vars.linaux][self.global_vars.colaux]:
                                    # Alcançou a rede de drenagem: encerra a busca
                                    self.global_vars.caminho = 1
                                    self.global_vars.TSpixacum[lin][col] = self.global_vars.tempocam
                                else:
                                    self.global_vars.diraux = self.global_vars.direcoes[self.global_vars.linaux][self.global_vars.colaux]
                                    self.global_vars.caminho = 0

                                    self.global_vars.colaux2 = self.global_vars.colaux
                                    self.global_vars.linaux2 = self.global_vars.linaux

                                    # Calculando a distância incremental percorrida
                                    self.global_vars.linaux += self.global_vars.dlin[self.global_vars.diraux]
                                    self.global_vars.colaux += self.global_vars.dcol[self.global_vars.diraux]

                                    # Atualizando o tempo de escoamento desde o píxel inicial
                                    self.global_vars.tempocam += self.global_vars.TSpix[self.global_vars.linaux2][self.global_vars.colaux2]

    def tempo_total_func(self):
        '''
        Esta função determina o tempo total de escoamento/concentração da bacia hidrográfica
        '''
        # Redimenciona as variáveis necessárias
        TempoTot = np.zeros((self.rdc_vars.nlin,self.rdc_vars.ncol))
        self.global_vars.TempoTot = TempoTot
        TempoTot = None

        for col in range(self.rdc_vars.ncol):
            for lin in range(self.rdc_vars.nlin):
                # Os procedimentos são realizados ao longo da bacia hidrográfica
                if self.global_vars.bacia[lin][col] == 1:
                    # Ainda, as verificaçãoes seão baseadas na rede de drenagem
                    if self.global_vars.dren[lin][col] == 1:
                        self.global_vars.TempoTot[lin][col] = self.global_vars.TempoRio[lin][col]
                    else:
                        # ARPlidar: otimização
                        self.global_vars.pixel_ref_dren = self.global_vars.pixeldren[lin][col]
                        if self.global_vars.pixel_ref_dren != 0:
                            self.global_vars.ll = self.global_vars.lincontadren[self.global_vars.pixel_ref_dren]
                            self.global_vars.cc = self.global_vars.colcontadren[self.global_vars.pixel_ref_dren]
                            self.global_vars.auxTempoCanal = self.global_vars.TempoRio[self.global_vars.ll][self.global_vars.cc]
                    # ARPtest
                    if self.global_vars.tipo_decliv == 1 or self.global_vars.tipo_decliv == 2 or self.global_vars.tipo_decliv == 3:
                        self.global_vars.TempoTot[lin][col] = self.global_vars.TStodos2d[lin][col] + self.global_vars.auxTempoCanal

                    if self.global_vars.tipo_decliv == 4:
                        self.global_vars.TempoTot[lin][col] = self.global_vars.TSpixacum[lin][col] + self.global_vars.auxTempoCanal
# Funções para as rotinas Excess rainfall e flow routing
    def numera_pix_bacia(self):
        '''Esta função enumera e quantifica os píxels presentes na bacia hidrográfica, além de atualizar variáveis inerente ao programa'''
        # Dimensionamento das variáveis
        numero_pixel = 0
        self.numb_pix_bacia = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        # Enumera os pixels presentes na bacia hidrográfica
        for lin in range(self.rdc_vars.nlin):
            for col in range(self.rdc_vars.ncol):
                if self.global_vars.bacia[lin][col] == 1:
                    numero_pixel += 1
                    self.numb_pix_bacia[lin][col] = numero_pixel

        # Computa o número total de pixels que são bacia hidrográfica
        self.numero_total_pix = numero_pixel
        numero_pixel = None

    def leh_CN(self):
        '''Esta função lê o arquivo enviado pelo usuário contendo os valores do parametro CURVE-NUMBER (CN) para os diferentes pixels da bacia hidrográfica'''
        # Define variáveis
        self.CN = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        arquivo = self.dlg_exc_rain.le_2_pg2.text() 
        # Tratamento de erros: verifica se o arquivo foi corretamente enviado
        if arquivo:
            # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
            rst_file_CN = gdal.Open(arquivo)
            
            # Lendo os dados raste como um array 
            dados_lidos_raster_CN = rst_file_CN.GetRasterBand(1).ReadAsArray()

            #  Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
            if rst_file_CN is not None:
                # Reorganizando os dados lidos em uma nova matriz, essa possui as informações sobre as classes dos rios
                self.CN = dados_lidos_raster_CN
                # Fechando o dataset GDAL referente ao arquivo raster
                rst_file_CN = None
            else:
                # Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro
                resulte = f"Failde to open the raster file: {arquivo}"
                QMessageBox.warning(None, "ERROR!", resulte)
                
        else:
            # Exibe uma mensagem de erro
            result ="Nenhum arquivo foi selecionado!"
            QMessageBox.warning(None, "ERROR!", result)
        return self.CN 

    
    def leh_tempo_viagem(self):
        '''Esta função lê o arquivo contendo o tempo de concentração de cada pixel presente na bacia hidrográfica e o armazena'''

        arquivo = self.dlg_flow_rout.le_3_pg2.text()
        # Tratamento de erros: verifica se o arquivo foi corretamente enviado
        if arquivo:
            # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
            rst_file_Tempo_total = gdal.Open(arquivo)
            
            # Lendo os dados raste como um array 
            dados_lidos_raster_Tempo_total = rst_file_Tempo_total.GetRasterBand(1).ReadAsArray()

            #  Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
            if rst_file_Tempo_total is not None:
                # Reorganizando os dados lidos em uma nova matriz, essa possui as informações sobre as classes dos rios
                Tempo_total = dados_lidos_raster_Tempo_total
                # Fechando o dataset GDAL referente ao arquivo raster
                rst_file_Tempo_total = None
            else:
                # Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro
                resulte = f"Failde to open the raster file: {arquivo}"
                QMessageBox.warning(None, "ERROR!", resulte)
                
        else:
            # Exibe uma mensagem de erro
            result ="Nenhum arquivo foi selecionado!"
            QMessageBox.warning(None, "ERROR!", result)

        return Tempo_total        

    def leh_parametros(self, alfa, d_t, criterio_parada,function):
        '''Esta função lê os valores enviados pelo usuário contento os parâmetros do modelo: abstração inicial, time step, tempo critério de parada e o beta'''
        # Armazena as informações enviadas
        self.alfa = float(alfa)
        self.delta_t = float(d_t)
        self.criterio_parada = float(criterio_parada)

        if function ==2:
            self.beta = float(self.dlg_flow_rout.le_5_pg1.text())

    def leh_precip_distribuida(self, file_):
        '''Esta função lê o arquivo enviado pelo usuário contento os valores da precipitação destribuidos ao longo dos pixels pertencentes a baica hidrográfica'''
        self.quantidade_blocos_chuva = 0
        # Lê os dados enviados e os armaneza
        arquivo = file_
        with open(arquivo, 'r', encoding = 'utf-8') as arquivo_txt:
            # armazena o cabeçalho (primeira linha)
            lines = arquivo_txt.readline().strip()

            # Sepera as linhas por vígula
            split_lines = lines.split(',')

        self.quantidade_blocos_chuva = len(split_lines) - 1 

    def leh_posto_pluv(self):
        '''Esta função é responsável por ler e armazenar as informações dos postos pluviométricos'''
        # Definição das variáveis
        id_postos = []
        latitude = []
        longitude = []
        numero_posto = []
        dict_numero_posto = {}
        w = 0
        arquivo_posto = self.dlg_exc_rain.le_2_pg_ri.text()
        with open(arquivo_posto, 'r', encoding = 'utf-8') as arquivo_txt:
            # Armazena cabeçalho
            cabecalho = arquivo_txt.readline().strip()
            # Lê as linhas do arquivo enviado
            for line in arquivo_txt:
                split_lines = line.split(',')
                id_postos.append(int(split_lines[0]))
                latitude.append(float(split_lines[1]))
                longitude.append(float(split_lines[2]))
                dict_numero_posto[w] = id_postos[w]
                w+=1
                numero_posto.append(w)

        # Redimensiona as variáveis globais
        self.quantidade_postos = len(numero_posto)
        self.id_postos = np.array(id_postos)
        self.latitude = np.array(latitude)
        self.longitude = np.array(longitude)
        self.numero_posto = dict_numero_posto

    def leh_arquivo_precipitacao(self):
        '''Esta função lê e armazena os valores de precipitação de cada posto ao longo do tempo'''
        # Definição das variáveis
        w = 0
        # Recebe e lê o arquivo
        arquivo_precipitacao = self.dlg_exc_rain.le_3_pg_ri.text()
        with open(arquivo_precipitacao, 'r', encoding = 'utf-8') as arquivo_txt:
            # Armazena cabeçalho
            cabecalho = arquivo_txt.readline().strip()

            # Redimenciona variáveis
            linhas = arquivo_txt.readlines()
            self.blocos_chuva = len(linhas)
            self.tempo = np.zeros(self.blocos_chuva)
            self.chuva = np.zeros((self.blocos_chuva,(self.quantidade_postos)))

            # Retira informações do arquivo
            w = 0
            for line in linhas:
                split_line = line.split(',')

                # Armazena tempo
                self.tempo[w] = split_line[0]

                # Armazena chuva
                for c in range(self.quantidade_postos):
                    self.chuva[w][c] = split_line[c+1]
                w +=1

    def precipitacao_acumulada(self):
        '''Esta função lê o arquivo contendo o tempo de concentração de cada pixel presente na bacia hidrográfica e o armazena'''

        arquivo = self.dlg_flow_rout.le_5_pg2.text()
        # Tratamento de erros: verifica se o arquivo foi corretamente enviado
        if arquivo:
            # Realizando a abertura do arquivo raster e coletando as informações referentes as dimensões do mesmo
            rst_file_chuva_acumulada = gdal.Open(arquivo)
            
            # Lendo os dados raste como um array 
            dados_lidos_raster_chuva_acumulada = rst_file_chuva_acumulada.GetRasterBand(1).ReadAsArray()

            #  Tratamento de erros: verifica se o arquivo raster foi aberto corretamente
            if rst_file_chuva_acumulada is not None:
                # Reorganizando os dados lidos em uma nova matriz, essa possui as informações sobre as classes dos rios
                chuva_acumulada = dados_lidos_raster_chuva_acumulada
                # Fechando o dataset GDAL referente ao arquivo raster
                rst_file_chuva_acumulada = None
            else:
                # Caso o arquivo raster apresente erros durante a abertura, ocorrerá um erro
                resulte = f"Failde to open the raster file: {arquivo}"
                QMessageBox.warning(None, "ERROR!", resulte)
                
        else:
            # Exibe uma mensagem de erro
            result ="Nenhum arquivo foi selecionado!"
            QMessageBox.warning(None, "ERROR!", result)

        return chuva_acumulada 

    @optimize           
    def rainfall_interpolation(self):
        '''Esta função gera o arquivo com a precipitação por pixel por meio da interpolação dos valores das estações pluviométricas enviadas pelo usuário'''
        # Definição de variáveis
        numero_pixel = 0
        numerador = 0
        denominador = 0
        distancia_y = 0
        distancia_x = 0
        rainfall = 0

        # Gera o arquivo com precipitação interpolada por pixel
        arquivo = self.dlg_exc_rain.le_4_pg_ri.text()
        with open(arquivo, 'w', encoding = 'utf-8') as arquivo_txt:
            # JVD:optimize: Escreve cabeçalho
            arquivo_txt.write('Pixel,')
            arquivo_txt.write(','.join(map(str, self.tempo)) + '\n')

            # JVDoptimize: interpolação da precipitação
            for lin in range(self.rdc_vars.nlin):
                for col in range(self.rdc_vars.ncol):
                    if self.global_vars.bacia[lin][col] == 1:
                        numero_pixel += 1
                        linha = str(numero_pixel)
                        x_pixel = self.X_minimo + (col * self.d_x) + (self.d_x / 2)
                        y_pixel = self.Y_minimo - (lin * self.d_y) + (self.d_y / 2)

                        # Aplicação da fórmula de interpolação
                        for w in range(self.blocos_chuva):
                            numerador = 0
                            denominador = 0
                            for k in range(self.quantidade_postos):
                                for q in range(self.quantidade_postos):
                                    if self.numero_posto[q] == self.id_postos[k]:
                                        distancia_y = self.latitude[k] - y_pixel
                                        distancia_x = self.longitude[k] - x_pixel                                
                                        distancia = np.sqrt((distancia_x ** 2) + (distancia_y ** 2))
                                        numerador += (float(self.chuva[w][q]) / (distancia**2))
                                        denominador += (1/(distancia**2))
                            rainfall = numerador / denominador
                            linha = linha + ',' + f'{rainfall}'

                        # Escreve informação no arquivo
                        arquivo_txt.write(linha+'\n')

    @optimize
    def rainfall_interpolation_map(self):
        '''Se o botão save maps for clicado: gera os arquivos raster com precipitação interpolada por pixel por duração do evento'''
        # Cria variáveis
        self.chuva_pixel = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        numero_pixel = 0
        numerador = 0
        denonimador = 0
        # Gera um arquivo por evento de precipitação
        for w in range(self.blocos_chuva):
            # Pasta enviada pelo user
            path = self.dlg_exc_rain.le_5_pg_ri.text()
            arquivo = path + f'\{str(self.tempo[w])}.RST'

            # interpolação da pricipitação para o evento em questão
            for lin in range(self.rdc_vars.nlin):
                for col in range(self.rdc_vars.ncol):
                    if self.global_vars.bacia[lin][col] == 1:
                        numero_pixel += 1
                        numerador = 0
                        denominador = 0
                        for k in range(self.quantidade_postos):
                            for q in range(self.quantidade_postos):
                                if self.numero_posto[q] == self.id_postos[k]:
                                    x_pixel = self.X_minimo + (col * self.d_x) + (self.d_x / 2)
                                    y_pixel = self.Y_minimo - (lin * self.d_y) + (self.d_y / 2)
                                    distancia_y = self.latitude[k] - y_pixel
                                    distancia_x = self.longitude[k] - x_pixel
                                    distancia = ((distancia_x ** 2) + (distancia_y ** 2))**(1/2)
                                    numerador += (self.chuva[w][q] / (distancia**2))
                                    denominador += (1/(distancia**2))
                        
                        # Armazena o valor da pricipitação do pixel
                        rainfall_pix = numerador / denominador
                        self.chuva_pixel[lin][col] = rainfall_pix

            num_pix_max = np.amax(self.chuva_pixel)
            # Escreve arquivo raster (.RST) com a precipitação por pixel em toda bacia para o evento em questão
            dados_chuva_pixel = np.array([[float(self.chuva_pixel[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
            tipo_dados = gdalconst.GDT_Float32

            # Obtendo o driver o para escrita do arquivo em GeoTiff
            driver = gdal.GetDriverByName('RST')
            dataset.SetGeoTransform(self.rdc_vars.geotransform)
            dataset.SetProjection(self.rdc_vars.projection)
            # Cria arquivo final
            dataset = driver.Create(arquivo, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)

            # Escreve os dados na banda do arquivo
            banda = dataset.GetRasterBand(1)
            banda.WriteArray(dados_chuva_pixel)

            # Fechando o arquivo
            dataset = None
            banda = None
            driver = None
            tipo_dados = None

            # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
            self.rdc_vars.nlin3 = self.rdc_vars.nlin
            self.rdc_vars.ncol3 = self.rdc_vars.ncol
            self.rdc_vars.tipo_dado = 2
            self.rdc_vars.tipoMM = 2
            self.rdc_vars.VarMM2 = self.chuva_pixel
            self.rdc_vars.i3 = 0 
            self.rdc_vars.Xmin3 = self.X_minimo
            self.rdc_vars.Xmax3 = self.X_maximo
            self.rdc_vars.Ymin3 = self.Y_minimo
            self.rdc_vars.Ymax3 = self.Y_maximo
            self.rdc_vars.Varmax = num_pix_max
            self.rdc_vars.Varmin = 0
            nomeRST = arquivo
            self.global_vars.metrordc = self.global_vars.metro
            self.escreve_RDC(nomeRST)          

    def excess_rainfall(self):
        '''Esta função determina gera os arquivos associados a precipitação excedente de cada pixel presente na baica hidrográfica, fumentando-se no método do SCS-CN'''

        # JVD: estrutura dos arrays
        self.time = np.zeros(50000)
        self.hacum = np.zeros(50000)
        self.perdas_iniciais = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.pe_acumulada_pixel = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.chuva_total_pixel = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.Spotencial = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))

        self.hexc_pix = np.zeros((self.numero_total_pix, self.quantidade_blocos_chuva))
        
        arquivo_precipitacao = self.dlg_exc_rain.le_4_pg2.text()
        with open(arquivo_precipitacao, 'r', encoding = 'utf-8') as arquivo_txt:
            # Armazena cabeçalho do arquivo
            cabecalho = arquivo_txt.readline().strip()
            for lin in range(self.rdc_vars.nlin):
                for col in range(self.rdc_vars.ncol):
                    if self.global_vars.bacia[lin][col]==1:
                        # Cálculo do potencial de armazenamento do solo por pixel presente na bacia
                        self.Spotencial[lin][col] = (25400/self.CN[lin][col])-254

                        # Cálculo das perdas iniciais por pixel presente na bacia
                        self.perdas_iniciais[lin][col] = self.alfa * self.Spotencial[lin][col]

                        Pacum = 0
                        self.time[0] = 0

                        # Armazena as linha do arquivo de precipitação
                        line = arquivo_txt.readline().strip()
                        split_line = line.split(',')

                        for w in range(1, self.quantidade_blocos_chuva+1):
                            chuva_distribuida = float(split_line[w])
                            self.time[w] = self.time[w-1] + self.delta_t

                            Pacum += chuva_distribuida 

                            # Cálculo da chuva excedente
                            if Pacum <= self.perdas_iniciais[lin][col]:
                                self.hacum[w] = 0
                            else:
                                self.hacum[w] = ((Pacum - self.perdas_iniciais[lin][col])**2) / (Pacum - self.perdas_iniciais[lin][col] + self.Spotencial[lin][col])

                            # precipitação efetiva desacumulada por pixel
                            self.hexc_pix[pixel_atual][w-1] = self.hacum[w] - self.hacum[w-1]

                        # Chuva excedente acumulada do pixel
                        self.pe_acumulada_pixel[lin][col] = self.hacum[self.quantidade_blocos_chuva]

                        # Chuva total no pixel
                        self.chuva_total_pixel[lin][col] = Pacum

    @optimize       
    def hidrograma_dlr(self):
        '''Esta função gera o hidrograma-DLR da bacia hidrográfica conforme os dados de precipitação enviados'''
        # Definição das variáveis
        Tmax = 0
        self.tempo_total = self.leh_tempo_viagem()
        self.Spotencial = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.volume_total_pix = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.vazao_pico = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.tempo_pico = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.TempoTotal_reclass = np.zeros((self.rdc_vars.nlin, self.rdc_vars.ncol))
        self.vazao_pixel = np.zeros(50000)
        self.tempo_intervalo = np.zeros(50000)
        time = np.zeros(50000)
        pe_acumulada_pixel = self.precipitacao_acumulada()
        self.tempo_vazao_pixel = np.zeros(50000)
        self.vazao_amortecida_pixel = np.zeros(50000)
        self.vazao = np.zeros(50000)

        # JVDoptmize: máximo tempo de viagem ao exutório
        tempo_total_bacia = self.tempo_total[self.global_vars.bacia == 1]
        Tmax = np.amax(tempo_total_bacia)
        
        # Reclassificação do tempo de viagem ao exutório para multiplos de delta_t
        w = 0
        self.tempo_intervalo[w] = 0
        while self.tempo_intervalo[w] <= Tmax + self.delta_t:
            self.tempo_intervalo[w + 1] = self.tempo_intervalo[w] + self.delta_t
            w += 1

        # JVD: correção sintaxe de vb to py
        # self.num_intervalos = w - 1
        self.num_intervalos = w
        diferenca = 0
        for lin in range(self.rdc_vars.nlin):
            for col in range(self.rdc_vars.ncol):
                diferenca_minima = 100000000
                if self.global_vars.bacia[lin][col] == 1:
                    for g in range(self.num_intervalos):
                        if self.tempo_intervalo[g] >= self.tempo_total[lin][col]:
                            diferenca = -(self.tempo_total[lin][col] - self.tempo_intervalo[g])

                        else:
                            diferenca = (self.tempo_total[lin][col] - self.tempo_intervalo[g])

                        if diferenca < diferenca_minima:
                            diferenca_minima = diferenca
                            self.TempoTotal_reclass[lin][col] = float(self.tempo_intervalo[g])

        # Determinação do hidrograma
        # Dados do arquivo de precipitação enviado
        tempo_exutorio = 0
        k = 0
        storage_coefficient = 0
        c_1 = 0
        c_2 = 0
        area_bacia = 0

        # lê hietograma 
        arquivo_precipitacao = self.dlg_flow_rout.le_4_pg2.text()
        with open(arquivo_precipitacao, 'r', encoding = 'utf-8') as arquivo_txt:
            # Armazena cabecalho do arquivo com a precipitação efetiva por pixel
            cabecalho = arquivo_txt.readline().strip()

            for lin in range(self.rdc_vars.nlin):
                for col in range(self.rdc_vars.ncol):
                    if self.global_vars.bacia[lin][col] == 1:
                        time[0] = 0
                        
                        # Armazena as linha do arquivo de precipitação efetiva
                        line = arquivo_txt.readline().strip()
                        split_line = line.split(',')

                        for h in range(1, self.quantidade_blocos_chuva + 1):
                            self.Pexc = float(split_line[h])
                            time[h] = time[h-1] + self.delta_t

                            if self.Pexc > 0:
                                # Vazão correspondente no exutório
                                self.Pexc = (((self.Pexc/1000) * (self.global_vars.dx ** 2)) / self.delta_t) * (1 / 60)  # Vazão em m³/s

                                # Representação da vazão no exutório (translação)
                                tempo_exutorio = time[h-1] + self.TempoTotal_reclass[lin][col]

                                k = int(tempo_exutorio / self.delta_t)
                                self.vazao_pixel[k] = self.Pexc

                        # Volume de água gerado por pixel
                        self.volume_total_pix[lin][col] = (pe_acumulada_pixel[lin][col] / (10 ** 3)) * (self.global_vars.dx ** 2)  # em m³

                        # Volume total de água gerada em todo evento
                        self.volume_total += self.volume_total_pix[lin][col]

                        # Parâmetro para estimativa do armazenamento
                        storage_coefficient = self.tempo_total[lin][col] / ((1 / self.beta) - 1)  # em minutos

                        c_1 = self.delta_t / ((2 * storage_coefficient) + self.delta_t)
                        c_2 = 1 - (2 * c_1)

                        # Amortecimento do hidrograma do pixel
                        k = 0
                        blocos_vazao = 0
                        self.tempo_vazao_pixel[k] = 0
                        self.vazao_amortecida_pixel[k] = c_1 * self.vazao_pixel[k]
                        self.vazao[k] = self.vazao[k] + self.vazao_amortecida_pixel[k]
                        while self.tempo_vazao_pixel[k] <= self.criterio_parada:
                            self.vazao_amortecida_pixel[k+1] = (c_1 * self.vazao_pixel[k+1]) + (c_1 * self.vazao_pixel[k]) + (c_2 * self.vazao_amortecida_pixel[k])
                            self.tempo_vazao_pixel[k+1] = self.tempo_vazao_pixel[k] + self.delta_t
                            k += 1
                            blocos_vazao += 1
                            self.vazao[k] = self.vazao[k] + self.vazao_amortecida_pixel[k]

                        # Determinação da vazão e do tempo de pico do hidrograma-DLR por pixel
                        self.vazao_pico[lin][col] = np.amax(self.vazao)
                        self.blocos_vazao = blocos_vazao

                        # Zera vazão no pixel
                        self.vazao_pixel.fill(0)
                        self.vazao_amortecida_pixel.fill(0)

            # Cálculo da área da bacia
            area_bacia = self.numero_total_pix * (self.global_vars.dx **2) # em m²

            # Chuva excedente calculada
            self.chuva_excedente_calc = (self.volume_total / area_bacia) * (10**3) #em mm

    def min_max(self):
        """
        Esta função determinar os limites das variáveis varMax e varMin 
        """
        self.rdc_vars.Varmax = -1.0e7
        self.rdc_vars.Varmin = 1.0e7

        if self.rdc_vars.tipoMM == 2:
            for col in range(self.rdc_vars.ncol3):
                for lin in range(self.rdc_vars.nlin3):
                    if self.rdc_vars.VarMM2[lin][col] > self.rdc_vars.Varmax:
                        self.rdc_vars.Varmax = self.rdc_vars.VarMM2[lin][col]
                    
                    elif self.rdc_vars.VarMM2[lin][col] < self.rdc_vars.Varmin:
                        self.rdc_vars.Varmin = self.rdc_vars.VarMM2[lin][col]

        else:
            for col in range(self.rdc_vars.ncol3):
                for lin in range(self.rdc_vars.nlin3):
                    if self.rdc_vars.VarMM3[lin][col][self.rdc_vars.i3] > self.rdc_vars.Varmax:
                        self.rdc_vars.Varmax = self.rdc_vars.VarMM3[lin][col][self.rdc_vars.i3]
                        
                    elif self.rdc_vars.VarMM3[lin][col][self.rdc_vars.i3] < self.rdc_vars.Varmin:
                        self.rdc_vars.Varmin = self.rdc_vars.VarMM3[lin][col][self.rdc_vars.i3]

    def tamanho_numero(self, varaux, num):
        '''
        Esta função a dimensão dos números que serão usados na padronização do documento
        '''
        negativo, nzeros, pp, varaux2, limsup = None, None, None, None, None
        
        if varaux < 0:
            negativo = 1
        else:
            negativo = 0
        
        varaux2 = np.abs(varaux)
        
        for pp in range(11):
            limsup = 10.0**pp
            if varaux2 < limsup:
                nzeros = pp
                break

        # Se o valor for inteiro
        if num == 1:
            if nzeros == 0:
                self.global_vars.tamnum = 1 + negativo
            else:
                self.global_vars.tamnum = nzeros + negativo
        # Se o valor for real
        else:
            if nzeros == 0:
                self.global_vars.tamnum = 8 + 1 + negativo
            else:
                self.global_vars.tamnum = 8 + nzeros + negativo   

        return self.global_vars.tamnum

    def aux_RDC(self, textoaux, varaux, tamnum):
        """
        Esta função é responsável por formatar as informações dos arquivos de saida do programa
        """
        if tamnum == 1:
            formated_phrase = f'{textoaux:14s}{varaux:1d}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 2:
            formated_phrase = f'{textoaux:14s}{varaux:2d}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 3:
            formated_phrase = f'{textoaux:14s}{varaux:3d}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 4:
            formated_phrase = f'{textoaux:14s}{varaux:4d}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 5:
            formated_phrase = f'{textoaux:14s}{varaux:5d}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 6:
            formated_phrase = f'{textoaux:14s}{varaux:7d}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 8:
            formated_phrase = f'{textoaux:14s}{varaux:8d}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 9:
            formated_phrase = f'{textoaux:14s}{varaux:9.7f}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 10:
            formated_phrase = f'{textoaux:14s}{varaux:10.7f}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 11:
            formated_phrase = f'{textoaux:14s}{varaux:11.7f}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 12:
            formated_phrase = f'{textoaux:14s}{varaux:12.7f}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 13:
            formated_phrase = f'{textoaux:14s}{varaux:13.7f}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 14:
            formated_phrase = f'{textoaux:14s}{varaux:14.7f}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 15:
            formated_phrase = f'{textoaux:14s}{varaux:15.7f}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 16:
            formated_phrase = f'{textoaux:14s}{varaux:16.7f}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 17:
            formated_phrase = f'{textoaux:14s}{varaux:17.7f}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 18:
            formated_phrase = f'{textoaux:14s}{varaux:18.7f}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
        elif tamnum == 19:
            formated_phrase = f'{textoaux:14s}{varaux:19.7f}\n'
            formated_phrase = str(formated_phrase)
            return formated_phrase
         
    def escreve_RDC(self, nome_RST):
        """
        Esta função constrói os arquivos de saída das diferentes funcionalidades do programa
        """
        # Identifica a posição da extensão no arquivo .rst
        pos_ext = nome_RST.find('.rst')

        # Atribui o nome do arquivo .rst ao novo arquivo .rdc
        nome_rdc = nome_RST[:pos_ext] + '.rdc'

        # Abrindo o arquivo 
        with open(nome_rdc, 'w', encoding = 'utf-8') as rdc_file:
            # Escreve linha com formato do arquivo
            rdc_file.write('file format : IDRISI Raster A.1\n')
            # Escreve linha com o título do arquivo
            rdc_file.write('File title  : \n')

            # Escreve linha com tipo de dado
            if self.rdc_vars.tipo_dado == 1:
                rdc_file.write('data type   : integer\n')
            elif self.rdc_vars.tipo_dado == 2:
                rdc_file.write('data type   : real\n')

            # Escreve a linha com o tipo de arquivo
            rdc_file.write('file type   : binary\n')

            # Escreve a linha com o número de colunas
            self.global_vars.varaux = self.rdc_vars.ncol3
            self.rdc_vars.num = 1
            textoaux = 'columns     : ' 
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            phrase = self.aux_RDC(textoaux, self.global_vars.varaux, tamnum)
            rdc_file.write(phrase)

            # Escreve a linha com o número de linhas
            self.global_vars.varaux = self.rdc_vars.nlin3
            self.rdc_vars.num = 1 # num = 1 : integer
            textoaux = 'rows        : ' 
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            phrase = self.aux_RDC(textoaux, self.global_vars.varaux, tamnum)
            rdc_file.write(phrase)
            # Escreve a linha com o sistema de referência
            rdc_file.write(f'ref. system : {self.rdc_vars.sistemaref}\n')

            # Escreve a linha com a unidade de referência
            if self.global_vars.metro == 1:
                rdc_file.write('ref. units  : m\n')
            else:
                rdc_file.write('ref. units  : deg\n')
            
            # Escreve linha com distância unitária de referência
            rdc_file.write(f'unit dist.  : {1.0:<9.7f}\n')


            # Escreve linha com coordenada xmin
            self.global_vars.varaux = self.rdc_vars.Xmin3
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'min. X      : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            phrase = self.aux_RDC(textoaux, self.global_vars.varaux, tamnum)
            rdc_file.write(phrase)

            # Escreve linha com coordenada xmax
            self.global_vars.varaux = self.rdc_vars.Xmax3
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'max. X      : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            phrase = self.aux_RDC(textoaux, self.global_vars.varaux, tamnum)
            rdc_file.write(phrase)
            
            # Escreve linha com coordenada ymin
            self.global_vars.varaux = self.rdc_vars.Ymin3
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'min. Y      : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            phrase = self.aux_RDC(textoaux, self.global_vars.varaux, tamnum)
            rdc_file.write(phrase)

            # Escreve linha com coordenada ymax
            self.global_vars.varaux = self.rdc_vars.Ymax3
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'max. Y      : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            phrase = self.aux_RDC(textoaux, self.global_vars.varaux, tamnum)
            rdc_file.write(phrase)

            # Escreve a linha com o valor do erro dos dados
            rdc_file.write(f"pos'n error : unknown\n")

            # Escreve linha com resolução
            self.global_vars.varaux = self.global_vars.dx
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'resolution  : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            phrase = self.aux_RDC(textoaux, self.global_vars.varaux, tamnum)
            rdc_file.write(phrase)

            # Escreve a linha com o valor mínimo dos dados 
            self.global_vars.varaux = self.rdc_vars.Varmin
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'min. value  : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            phrase = self.aux_RDC(textoaux, self.global_vars.varaux, tamnum)
            rdc_file.write(phrase)

            # Escreve a linha com o valor máximo dos dados 
            self.global_vars.varaux = self.rdc_vars.Varmax
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'max. value  : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            phrase = self.aux_RDC(textoaux, self.global_vars.varaux, tamnum)
            rdc_file.write(phrase)

            # Escreve a linha com o valor mínimo de exebição 
            self.global_vars.varaux = self.rdc_vars.Varmin
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'display min : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            phrase = self.aux_RDC(textoaux, self.global_vars.varaux, tamnum)
            rdc_file.write(phrase)

            #  Escreve a linha com o valor máximo para exibição 
            self.global_vars.varaux = self.rdc_vars.Varmax
            self.rdc_vars.num = 2 # num = 2 : real
            textoaux = 'display max : '
            tamnum = self.tamanho_numero(self.global_vars.varaux, self.rdc_vars.num)
            phrase = self.aux_RDC(textoaux, self.global_vars.varaux, tamnum)
            rdc_file.write(phrase)

            # Escreve a linha com a unidade dos dados
            rdc_file.write('value units : unspecified\n')

            # Escreve a linha com o valor do erro dos dados
            rdc_file.write(f'value error : unknown\n')

            # Escreve linha com sinalizador
            rdc_file.write(f'flag value  : {0:1d}\n')
            
            # Escreve a linha com a definição do sinalizador
            rdc_file.write("flag def'n  : none\n")

            # Escreve a linha com o número de categorias da legenda
            rdc_file.write(f'legend cats : {0:1d}\n')

            # Escreve a linha sobre a criação da imagem
            rdc_file.write('lineage     : This file was created automatically by an ARP and JVD PYTHON program')
        
    def escreve_num_pix_drenagem(self):
        '''Esta função gera o mapa de numeração dos píxels da rede de drenagem'''

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        self.fn_num_pix_dren = self.dlg_flow_tt.le_1_pg4.text()
        
        # Define os dados a serem escritos
        dados_num_pix_dren = np.array([[float(self.global_vars.pixeldren[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver RST do GDAL
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_num_pix_dren, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_num_pix_dren)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
       
        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 1
        self.rdc_vars.tipoMM = 2
        self.rdc_vars.VarMM2 = self.contadren
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymax3 = self.rdc_vars.ymax
        nomeRST = self.fn_num_pix_dren
        self.global_vars.metrordc = self.global_vars.metro
        self.min_max()
        self.escreve_RDC(nomeRST)

    def escreve_conectividade(self):
        """
        Esta função é responsável por formular os arquivos de saída (tanto o raster (.rst), quanto sua documentação (.rdc))
        para os dados referentes ao mapa de conectividade das cabeceiras da bacia hidrográfica
        """

        # Escrevendo o resultado do mapa de conectividade dos pixels da superficie a rede de drenagem
        self.fn_n_conect_dren = self.dlg_flow_tt.le_2_pg4.text()

        # Define os dados a serem escritos
        dados_n_conect_dren = np.array([[float(self.global_vars.pixeldren[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver RST do GDAL
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_n_conect_dren, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_n_conect_dren)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Aloca as variáveis para escrita da documentação do arquivo rdc para o comprimento da foz da bacia hidrográfica
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = self.global_vars.pixeldren
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymax3 = self.rdc_vars.ymax
        nomeRST = self.fn_n_conect_dren
        self.global_vars.metrordc = self.global_vars.metro
        self.min_max()
        self.escreve_RDC(nomeRST)
       
    def escreve_comprimento_acumulado(self):
        """
        Esta função é responsável por formular os arquivos de saída (tanto o raster (.rst), quanto sua documentação (.rdc))
        para os dados referentes aos comprimentos da rede de drenagem da bacia hidrográfica
        """

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        self.fn_comp_acum = self.dlg_flow_tt.le_1_pg4.text()

        # Define os dados a serem escritos
        dados_comp_acum = np.array([[float(self.global_vars.Lac[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)]) #lac n existe
        tipo_dados = gdalconst.GDT_Float32

        # Os arquivos terão formato rst
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_comp_acum, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)
        
        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_comp_acum)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = self.global_vars.Lac
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymax3 = self.rdc_vars.ymax
        nomeRST = self.fn_comp_acum
        self.global_vars.metrordc = self.global_vars.metro
        self.min_max()
        self.escreve_RDC(nomeRST)

    def escreve_comprimento_acumulado_foz(self):
        """
        Esta função é responsável por formular os arquivos de saída (tanto o raster (.rst), quanto sua documentação (.rdc))
        para os dados referentes aos comprimentos da rede de drenagem da bacia hidrográfica
        """
        # Escrevendo o resultado do comprimento da rede de drenagem
        self.fn_comp_foz = self.dlg_flow_tt.le_3_pg4.text()
            
        # Define os dados a serem escritos
        dados_comp_foz = np.array([[float(self.global_vars.Lfoz[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Os arquivos terão formato rst
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_comp_foz, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)
        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_comp_foz)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da foz da bacia hidrográfica
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = self.global_vars.Lfoz
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymax3 = self.rdc_vars.ymax
        nomeRST = self.fn_comp_foz
        self.global_vars.metrordc = self.global_vars.metro
        self.min_max()
        self.escreve_RDC(nomeRST)

    def escreve_declivi_pixel(self):
        '''Esta função gera o mapa de numeração dos pixels da rede de drenagem'''

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        self.fn_decli_pix = self.dlg_flow_tt.le_5_pg4.text()

        # Define os dados a serem escritos
        dados_decli_pix = np.array([[float(self.global_vars.decliv_pixel[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver RST do GDAL
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_decli_pix, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_decli_pix)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = self.global_vars.decliv_pixel
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymax3 = self.rdc_vars.ymax
        nomeRST = self.fn_decli_pix
        self.global_vars.metrordc = self.global_vars.metro
        self.min_max()
        self.escreve_RDC(nomeRST)

    def escreve_decliv_pixel_jus(self):
        '''Esta função gera o mapa de numeração dos pixels jusantes da rede de drenagem'''

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        self.fn_decli_pix_jus = self.dlg_flow_tt.le_6_pg4.text()
        
        # Define os dados a serem escritos
        dados_decli_pix_jus = np.array([[float(self.global_vars.decliv_pixel_jus[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver RST do GDAL
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_decli_pix_jus, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_decli_pix_jus)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = self.global_vars.decliv_pixel_jus
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymax3 = self.rdc_vars.ymax
        nomeRST = self.fn_decli_pix_jus
        self.global_vars.metrordc = self.global_vars.metro
        self.min_max()
        self.escreve_RDC(nomeRST)
    
    def escreve_tempo_total(self):
        '''Esta função gera o mapa de conectividade dos píxels de superfície da rede de drenagem'''

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        self.fn_temp_total = self.dlg_flow_tt.le_7_pg4.text()
        
        # Define os dados a serem escritos
        dados_temp_total = np.array([[float(self.global_vars.TempoTot[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)]) #tempo total não exist
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver RST do GDAL
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_temp_total, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_temp_total)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None   

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.global_vars.VarMM2 = self.global_vars.TempoTot
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.rdc_vars.xmin
        self.rdc_vars.Xmax3 = self.rdc_vars.xmax
        self.rdc_vars.Ymin3 = self.rdc_vars.ymin
        self.rdc_vars.Ymax3 = self.rdc_vars.ymax
        nomeRST = self.fn_temp_total
        self.global_vars.metrordc = self.global_vars.metro
        self.min_max()
        self.escreve_RDC(nomeRST)

    def escreve_hidrograma_dlr(self):
        '''Esta função gera contento o hidrograma total da bacia hidrográfica estudada'''
        self.fn_hidrograma = self.dlg_flow_rout.le_6_pg4.text()
        with open(self.fn_hidrograma, 'w', encoding = 'utf-8') as arquivo_txt:
            arquivo_txt.write('tempo(min), vazão calculada(m³/s)\n')
            for k in range(self.blocos_vazao):
                arquivo_txt.write(f'{self.tempo_vazao_pixel[k]}, {self.vazao[k]}\n')

    def escreve_hietograma_pe(self):
        '''Esta função gera o arquivo contento o valor da precipitação efetiva por pixel durante os blocos de chuva'''

        # Recebe diretório e nome do arquivo do usurário      
        arquivo = self.dlg_exc_rain.le_6_pg4.text()
        with open(arquivo, 'w', encoding = 'utf-8') as arquivo_txt:
            # JVD:optimize: Escreve cabeçalho
            arquivo_txt.write('Pixel,')
            for k in range(1,self.quantidade_blocos_chuva+1):
                arquivo_txt.write(f'{self.time[k]},')
            arquivo_txt.write('\n')

            # Escreve linhas com dados de precipitação efetiva por pixel
            for k in range(1,self.numero_total_pix+1):
                for w in range(self.quantidade_blocos_chuva):
                    if w <  self.quantidade_blocos_chuva-1:
                        arquivo_txt.write(f'{k},{self.hexc_pix[k-1][w]}')
                    else:
                        arquivo_txt.write(f',{self.hexc_pix[k-1][w]}'+'\n')

    def escreve_numb_pix_bacia(self):
        '''Esta função gera o mapa contendo a numeração dos pixels presentes na bacia hidrografíca'''
        # JVDopmize: determinação da perda inicial máxima
        numb_pix_max = np.amax(self.numb_pix_bacia)

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        self.fn_numb_pix = self.dlg_exc_rain.le_1_pg4.text()

        # Define os dados a serem escritos
        dados_numb_pix = np.array([[float(self.numb_pix_bacia[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver para escrita do arquivo em GeoTiff
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_numb_pix, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_numb_pix)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.rdc_vars.VarMM2 = self.numb_pix_bacia
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.X_minimo
        self.rdc_vars.Xmax3 = self.X_maximo
        self.rdc_vars.Ymin3 = self.Y_minimo
        self.rdc_vars.Ymax3 = self.Y_maximo
        self.rdc_vars.Varmax = numb_pix_max
        self.rdc_vars.Varmin = 0
        nomeRST = self.fn_numb_pix
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)    

    def escreve_perdas_ini(self):
        '''Esta função gera o mapa contendo os valores das perdas iniciais dos pixels presentes na bacia hidrografíca'''
        # JVDopmize: determinação da perda inicial máxima
        perda_ini_max = np.amax(self.perdas_iniciais)

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        self.fn_perda_ini = self.dlg_exc_rain.le_3_pg4.text()
        
        # Define os dados a serem escritos
        dados_perda_ini = np.array([[float(self.perdas_iniciais[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver para escrita do arquivo em GeoTiff
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_perda_ini, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_perda_ini)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.rdc_vars.VarMM2 = self.perdas_iniciais
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.X_minimo
        self.rdc_vars.Xmax3 = self.X_maximo
        self.rdc_vars.Ymin3 = self.Y_minimo
        self.rdc_vars.Ymax3 = self.Y_maximo
        self.rdc_vars.Varmax = perda_ini_max
        self.rdc_vars.Varmin = 0
        nomeRST = self.fn_perda_ini
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)      

    def escreve_S_potencial(self):
        '''Esta função gera o arquivo raster contendo os valores da retenção máxima (S) por pixel presente na bacia hidrográfica'''
        # JVDoptmize: calcula a retenção máxima
        max_retencao = np.amax(self.Spotencial)

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        self.fn_Spotencial = self.dlg_exc_rain.le_2_pg4.text()
        
        # Define os dados a serem escritos
        dados_Spotencial = np.array([[float(self.Spotencial[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver para escrita do arquivo em GeoTiff
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_Spotencial, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_Spotencial)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.rdc_vars.VarMM2 = self.Spotencial
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.X_minimo
        self.rdc_vars.Xmax3 = self.X_maximo
        self.rdc_vars.Ymin3 = self.Y_minimo
        self.rdc_vars.Ymax3 = self.Y_maximo
        self.rdc_vars.Varmax = max_retencao
        self.rdc_vars.Varmin = 0
        nomeRST = self.fn_Spotencial
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)       

    def escreve_precipitacao_excedente(self):
        '''Esta função é responsável por gerar o arquivo raster contendo os valores da precipitação excedente por pixel presente na baica hidrográfica'''
        # JVDoptmize: determina precipitação excedente máxima
        pe_maxima = np.amax(self.chuva_acumulada_pixel)

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        self.fn_pe_acum = self.dlg_exc_rain.le_5_pg4.text()
        
        # Define os dados a serem escritos
        dados_pe_acum = np.array([[float(self.chuva_acumulada_pixel[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver para escrita do arquivo em GeoTiff
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_pe_acum, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_pe_acum)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.rdc_vars.VarMM2 = self.chuva_acumulada_pixel
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.X_minimo
        self.rdc_vars.Xmax3 = self.X_maximo
        self.rdc_vars.Ymin3 = self.Y_minimo
        self.rdc_vars.Ymax3 = self.Y_maximo
        self.rdc_vars.Varmax = pe_maxima
        self.rdc_vars.Varmin = 0
        nomeRST = self.fn_pe_acum
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)  

    def escreve_precipitacao_total_acum(self):
        '''Esta função gera o arquivo raster contendo a precipitação total acumulada por pixel presente na bacia hidrográfica'''
        # JVDoptmize: determina precipitação máxima acumulada
        p_acum_max = np.amax(self.chuva_total_pixel)

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        self.fn_p_acum = self.dlg_exc_rain.le_4_pg4()
        
        # Define os dados a serem escritos
        dados_p_acum = np.array([[float(self.chuva_total_pixel[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver para escrita do arquivo em GeoTiff
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_p_acum, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_p_acum)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.rdc_vars.VarMM2 = self.chuva_total_pixel
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.X_minimo
        self.rdc_vars.Xmax3 = self.X_maximo
        self.rdc_vars.Ymin3 = self.Y_minimo
        self.rdc_vars.Ymax3 = self.Y_maximo
        self.rdc_vars.Varmax = p_acum_max
        self.rdc_vars.Varmin = 0
        nomeRST = self.fn_p_acum
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)  

    def escreve_volume_gerado_pixel(self):
        '''Esta função gera o arquivo raster contendo o volume gerado por pixel presente na bacia hidrográfica'''
        # JVDoptmize: determina precipitação máxima acumulada
        vol_max = np.amax(self.volume_total_pix)

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        self.fn_vol = self.dlg_flow_rout.le_5_pg4.text()
        
        # Define os dados a serem escritos
        dados_vol = np.array([[float(self.volume_total_pix[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
        tipo_dados = gdalconst.GDT_Float32

        # Obtendo o driver para escrita do arquivo em GeoTiff
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_vol, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_vol)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.rdc_vars.VarMM2 = self.volume_total_pix
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.X_minimo
        self.rdc_vars.Xmax3 = self.X_maximo
        self.rdc_vars.Ymin3 = self.Y_minimo
        self.rdc_vars.Ymax3 = self.Y_maximo
        self.rdc_vars.Varmax = vol_max
        self.rdc_vars.Varmin = 0
        nomeRST = self.fn_vol
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST)  

    def escreve_vazao_pico_pixel(self, unit):
        '''Esta função gera o arquivo raster contendo o volume gerado por pixel presente na bacia hidrográfica
           unit: identifica a unidade da vazão escolhida pelo usuário;
                - unit == 1: m³/s
                - unit != 1: L/s'''
        # JVDoptmize: determina precipitação máxima acumulada
        vazao_pixo_max = np.amax(self.vazao_pico)

        # Abrindo o arquivo(fn : file name) para escrita dos resultados
        self.fn_vazao_pico = self.dlg_flow_rout.le_4_pg4.text()

        # Define os dados a serem escritos
        if unit == 1:
            dados_vazao_pico = np.array([[float(self.vazao_pico[lin][col]) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
            tipo_dados = gdalconst.GDT_Float32
        else:
            dados_vazao_pico = np.array([[float(self.vazao_pico[lin][col]/1000) for col in range(self.rdc_vars.ncol)] for lin in range(self.rdc_vars.nlin)])
            tipo_dados = gdalconst.GDT_Float32            
        # Obtendo o driver para escrita do arquivo em GeoTiff
        driver = gdal.GetDriverByName('RST')

        # Cria arquivo final
        dataset = driver.Create(self.fn_vazao_pico, self.rdc_vars.ncol, self.rdc_vars.nlin, 1, tipo_dados)
        dataset.SetGeoTransform(self.rdc_vars.geotransform)
        dataset.SetProjection(self.rdc_vars.projection)

        # Escreve os dados na banda do arquivo
        banda = dataset.GetRasterBand(1)
        banda.WriteArray(dados_vazao_pico)

        # Fechando o arquivo
        dataset = None
        banda = None
        driver = None
        tipo_dados = None

        # Alocando as variáveis para escrita da documentação do arquivo rdc para o comprimento da rede de drenagem
        self.rdc_vars.nlin3 = self.rdc_vars.nlin
        self.rdc_vars.ncol3 = self.rdc_vars.ncol
        self.rdc_vars.tipo_dado = 2
        self.rdc_vars.tipoMM = 2
        self.rdc_vars.VarMM2 = self.vazao_pico
        self.rdc_vars.i3 = 0 
        self.rdc_vars.Xmin3 = self.X_minimo
        self.rdc_vars.Xmax3 = self.X_maximo
        self.rdc_vars.Ymin3 = self.Y_minimo
        self.rdc_vars.Ymax3 = self.Y_maximo
        self.rdc_vars.Varmax = vazao_pixo_max
        self.rdc_vars.Varmin = 0
        nomeRST = self.fn_vazao_pico
        self.global_vars.metrordc = self.global_vars.metro
        self.escreve_RDC(nomeRST) 

    def save_buttons(self, line_edit,file_type = 'raster'):
        '''Esta função configura os botões da salvar (criar arquivo)'''
        # Seleciona o arquivo enviado pelo usuário
        while True:
            # Obtendo o caminho do arquivo a ser salvo usando um diálogo de arquivo
            if file_type == 'raster':
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file",'',"Raster Files (*.rst)")
                if file_name:
                    line_edit.setText(file_name)
                    break
                else:
                    # O usuário não solucionou um arquivo (um caminho para salvar o arquivo de saída)
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break
            elif file_type == 'text':
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file",'',"Text (*.txt)")
                if file_name:
                    line_edit.setText(file_name)
                    break
                else:
                    # O usuário não solucionou um arquivo (um caminho para salvar o arquivo de saída)
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break

    def save_to_file(self, function, page):
        '''Esta função gera o arquivo com as informações enviadas por meio do usuário por página
        Function: Indica qual função a página pertence
                function == 1: Flow travel time;
                function == 2: Excess rainfall;
                function == 3: Flow routing
        Page: variável que identifica a página do arquivo que será escrito
                page == 1: Configurations;
                page == 2: Input Data;
                page == 3: Data Validation;
                page == 4: Run
        '''
        # Seleciona o arquivo enviado pelo usuário
        while True:
            if function == 1:
                if page == 1:
                    # Obtendo o caminho do arquivo a ser salvo usando um diálogo de arquivo
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "ftt_configuration_page", "Text Files (*.txt)")
                    # Verifica se o usuário selecionou um arquivo
                    if file_name:
                        # Armazenará as informações da primeira página
                        with open(file_name, 'w', encoding ='utf-8') as arquivo_txt:
                            arquivo_txt.write('Flow Travel Time - Configuration\n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Minimum slope surface travel time determination (m/km):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_1_pg1.text()}\n')
                            arquivo_txt.write('Maximum slope for surface travel time determination (m/km):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_2_pg1.text()}\n')
                            arquivo_txt.write('Orthogonal step for distance computation (dx):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_3_pg1.text()}\n')
                            arquivo_txt.write('Diagonal step for distance computation (dx):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_tt.le_4_pg1.text()}\n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Flow direction code: \n')
                            arquivo_txt.write(f'A = {self.dlg_flow_tt.le_5_pg1.text()}\n')
                            arquivo_txt.write(f'B = {self.dlg_flow_tt.le_6_pg1.text()}\n')
                            arquivo_txt.write(f'C = {self.dlg_flow_tt.le_7_pg1.text()}\n')
                            arquivo_txt.write(f'D = {self.dlg_flow_tt.le_8_pg1.text()}\n')
                            arquivo_txt.write(f'E = {self.dlg_flow_tt.le_9_pg1.text()}\n')
                            arquivo_txt.write(f'F = {self.dlg_flow_tt.le_10_pg1.text()}\n')
                            arquivo_txt.write(f'G = {self.dlg_flow_tt.le_11_pg1.text()}\n')
                            arquivo_txt.write(f'H = {self.dlg_flow_tt.le_12_pg1.text()}\n')
                            arquivo_txt.write('lineage: This file was created automatically by an ARP and JVD QGIS plugin')
                    else:
                        # O usuário não solucionou um arquivo (um caminho para salvar o arquivo de saída)
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo
                    break

                elif page == 2:
                    # Salva as informações fornecidas na página de input
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "ftt_input_data_page", "Text Files (*.txt)")        
                    if file_name:
                            # Atribuindo o nome do arquivo(fn : file name) para escrita dos resultados da página 1
                            with open(file_name, 'w', encoding ='utf-8') as arquivo_txt:
                                arquivo_txt.write('Flow Travel Time - Input Data: \n')
                                arquivo_txt.write('\n')
                                arquivo_txt.write('Watershed delineation:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_1_pg2.text()}\n')
                                arquivo_txt.write('\nDigital elevation model:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_2_pg2.text()}\n')
                                arquivo_txt.write('\nFlow direction (RDC and RST):\n')
                                linhas_text_edit = self.dlg_flow_tt.te_1_pg2.toPlainText()
                                linhas = linhas_text_edit.split('\n')
                                arquivo_txt.write(f'=> {linhas[0]}\n=> {linhas[1]}\n')
                                arquivo_txt.write('\nRiver drainage newtwork (RDN):\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_3_pg2.text()}\n')
                                arquivo_txt.write('\nRDN segmentation into classes:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_4_pg2.text()}\n')
                                arquivo_txt.write('\nCharacteristics of RDN classes:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_7_pg2.text()}\n')
                                arquivo_txt.write('\nLand use or land corver (LULC) map:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_5_pg2.text()}\n')
                                arquivo_txt.write('\nManning roughness coeficient for each LULC:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_8_pg2.text()}\n')
                                arquivo_txt.write('\nRainfall depth for 24-h duration (mm):\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_6_pg2.text()}\n')
                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

                # elif page == 3:
                    # Salva informações página de data validation

                elif page == 4:
                    # Salva as informações fornecidas na página de run
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "ftt_run_page", "Text Files (*.txt)")
                    if file_name:
                            # Atribuindo o nome do arquivo(fn : file name) para escrita dos resultados da página 1
                            with open(file_name, 'w', encoding ='utf-8') as arquivo_txt:
                                arquivo_txt.write('Flow Travel Time - Run page: \n')
                                arquivo_txt.write('\n')
                                arquivo_txt.write('Numering pixels part of the river drainage network:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_1_pg4.text()}\n')
                                arquivo_txt.write('Areas draining directly to each pixel of the RDN:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_2_pg4.text()}\n')
                                arquivo_txt.write('Upstream flowpath length:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_3_pg4.text()}')
                                arquivo_txt.write('Downstream flowpath slope (m/m):\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_4_pg4.text()}\n')
                                arquivo_txt.write('Downstream flowpath length:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_5_pg4.text()}\n')
                                arquivo_txt.write('Slope relative to downstream pixel:\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_6_pg4.text()}\n')
                                arquivo_txt.write('Flow travel time (min):\n')
                                arquivo_txt.write(f'=> {self.dlg_flow_tt.le_7_pg4.text()}\n')

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

            elif function == 2:
                if page == 1:
                    # Salva as informações fornecidas na página de configuration: excess rainfall
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "exc_rain_configuration_page", "Text Files (*.txt)")
                    if file_name:
                        with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                            arquivo_txt.write('Excess Rainfall - Configuration page\n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Initial abstraction parameter (λ):\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_1_pg1.text()}\n')
                            arquivo_txt.write('Time step (min):\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_2_pg1.text()}\n')
                            arquivo_txt.write('Finish (min):\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_4_pg1.text()}\n')
                            arquivo_txt.write('Rainfall defination:\n')
                            arquivo_txt.write('    Areal averaged:\n')
                            arquivo_txt.write(f'   =>{self.dlg_exc_rain.rb_1_pg1.isChecked()}\n')
                            arquivo_txt.write('    Spatially distributed:\n')
                            arquivo_txt.write(f'   =>{self.dlg_exc_rain.rb_2_pg1.isChecked()}\n')

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

                elif page == 2:
                    # Armazena as informações acerca da função rainfall intepolation
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "exc_rain_rainfall_inter_page", "Text Files (*.txt)")
                    if file_name:
                        with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                            arquivo_txt.write('Excess Rainfall - Rainfall interpolation: \n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Watershed delineation:\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_1_pg_ri.text()}\n')
                            arquivo_txt.write('Rain gauges metadata:\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_2_pg_ri.text()}\n')
                            arquivo_txt.write('Rainfall data:\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_3_pg_ri.text()}\n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Rainfall file:\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_4_pg_ri.text()}\n')
                            arquivo_txt.write('Rainfall maps:\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_5_pg_ri.text()}\n')

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                        
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

                elif page == 3:
                    # Salva as informações fornecidas na página de input data: excess rainfall
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "exc_rain_input_data_page", "Text Files (*.txt)")
                    if file_name:
                        with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                            arquivo_txt.write('Excess Rainfall - Input data page: \n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Watershed delineation:\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_1_pg2.text()}\n')
                            arquivo_txt.write('Map of curve-number:\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_2_pg2.text()}\n')
                            if self.dlg_exc_rain.rb_1_pg1.isChecked():
                                arquivo_txt.write('Areal averaged rainfall:\n')
                                arquivo_txt.write(f'=> {self.dlg_exc_rain.le_3_pg2.text()}\n')
                            else:
                                arquivo_txt.write('List of files with the spatially distributed rainfall:\n')
                                arquivo_txt.write(f'=> {self.dlg_exc_rain.le_4_pg2.text()}\n')

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

                # elif page == 3:   

                elif page == 4:
                    # Salva informações da página de run : excess rainfall
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "exc_rain_run_page", "Text Files (*.txt)")
                    if file_name:
                        with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                            arquivo_txt.write('Excess Rainfall - Run page: \n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Numbering of watershed pixels:\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_1_pg4.text()}\n')
                            arquivo_txt.write('Maximum potential retention (mm):\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_2_pg4.text()}\n')
                            arquivo_txt.write('Initial abstraction (mm):\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_3_pg4.text()}\n')
                            arquivo_txt.write('Total rainfall (mm):\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_4_pg4.text()}\n')
                            arquivo_txt.write('Total excess rainfall (mm):\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_5_pg4.text()}\n')
                            arquivo_txt.write('Excess hyetographs per pixel (mm):\n')
                            arquivo_txt.write(f'=> {self.dlg_exc_rain.le_6_pg4.text()}\n')     
                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

            elif function == 3:
                if page == 1:
                # Salva as informações fornecidas na página de configuration: flow routing
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "flow_rout_configuration_page", "Text Files (*.txt)")
                    if file_name:
                        with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                            arquivo_txt.write('Flow Routing - Configuration page: \n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Model type:\n')
                            arquivo_txt.write('    Hidropixel - TUH:\n')
                            arquivo_txt.write(f'   => {self.dlg_flow_rout.rb_1_pg1.isChecked()}\n')
                            arquivo_txt.write('    Hidropixel - TUH+:\n')
                            arquivo_txt.write(f'   => {self.dlg_flow_rout.rb_2_pg1.isChecked()}\n')
                            arquivo_txt.write('    Hidropixel - DLR:\n')
                            arquivo_txt.write(f'   => {self.dlg_flow_rout.rb_3_pg1.isChecked()}\n')
                            arquivo_txt.write('Initial abstraction parameter (λ):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_1_pg1.text()}\n')
                            arquivo_txt.write('Time step (min):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_2_pg1.text()}\n')                            
                            arquivo_txt.write('Finish time (min):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_4_pg1.text()}\n')                            
                            arquivo_txt.write('Parameter β:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_5_pg1.text()}\n')                            

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break 

                elif page == 2:
                    # Salva as informações fornecidas na página de input data: flow routing
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "flow_rout_input_data_page", "Text Files (*.txt)")
                    if file_name:
                        with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                            arquivo_txt.write('Flow Routing - Input data page: \n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('Numbering of watershed pixels:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_1_pg2.text()}\n')
                            arquivo_txt.write('Watershed delineation:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_2_pg2.text()}\n')
                            arquivo_txt.write('Flow travel time:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_3_pg2.text()}\n')
                            arquivo_txt.write('Excess hyetographs per pixel:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_4_pg2.text()}\n')
                            arquivo_txt.write('Total excess rainfall per pixel (mm):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_5_pg2.text()}\n')

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

                # elif page == 3

                elif page == 4:
                    # Salva as informações fonecidas na página de run: flow routing 
                    file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "flow_rout_run_page", "Text Files (*.txt)")
                    if file_name:
                        with open(file_name, 'w', encoding = 'utf-8') as arquivo_txt:
                            arquivo_txt.write('Flow Routing - Run page: \n')
                            arquivo_txt.write('\n')
                            arquivo_txt.write('TUH peak discharge per pixel:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_1_pg4.text()}\n')
                            arquivo_txt.write(f'            (L/s) => {self.dlg_flow_rout.rb_1_pg4.isChecked()}\n')
                            arquivo_txt.write('Select unit:\n')
                            arquivo_txt.write(f'            (m³/s) => {self.dlg_flow_rout.rb_2_pg4.isChecked()}\n')
                            arquivo_txt.write('TUH peak time per pixel (min):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_2_pg4.text()}\n')
                            arquivo_txt.write('TUH base time per pixel (min):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_3_pg4.text()}\n')                                                          
                            arquivo_txt.write('Resulting peak discharge per pixel:\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_4_pg4.text()}\n')
                            arquivo_txt.write(f'            (L/s) => {self.dlg_flow_rout.rb_3_pg4.isChecked()}\n')
                            arquivo_txt.write('Select unit:\n')
                            arquivo_txt.write(f'            (m³/s) => {self.dlg_flow_rout.rb_4_pg4.isChecked()}\n')                            
                            arquivo_txt.write('Resulting runoff velume per pixel (m³):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_5_pg4.text()}\n')
                            arquivo_txt.write('Resulting watershed hydrograph (m³/s):\n')
                            arquivo_txt.write(f'=> {self.dlg_flow_rout.le_6_pg4.text()}\n')  

                    else:
                        # Caso o usuário não selecione um arquivo
                        result = "Wait! You did not select any file."
                        reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                        if reply == QMessageBox.Cancel:
                            break
                    # Encerra a chamada da tela de seleção de arquivo 
                    break

    def read_from_file(self, function, page, directory):
        '''Esta função é responsável por obter as informações a partir dos arquivos enviados pelo usuário
        Function: Indica qual função a página pertence
                function == 1: Flow travel time;
                function == 2: Excess rainfall;
                function == 3: Flow routing
        Page: variável que identifica a página do arquivo que será escrito
                page == 1: Configurations;
                page == 2: Input Data;
                page == 3: Data Validation;
                page == 4: Run
        '''
        # Seleciona o arquivo enviado pelo usuário
        while True:
            options = QFileDialog.Options()
            file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory = directory, filter="Text Files (*.txt)", options = options)
            if file_:
                if function == 1:
                    cont = 0
                    if page == 1:
                        # Ler as informações da página 1: configuration
                        with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                            # Armazena as informações do arquivo enviado em uma lista
                            values = []
                            for line in arquivo_txt:
                                # Buscará as flag adicionada "=>" ou "="
                                if "=>" in line or '=' in line:
                                    # Os primeiros 5 objetos são baseados na primeira flag
                                    if cont < 4:
                                        value = line.replace('=>', '').strip()
                                        values.append(value)
                                    # As direções de fluxo são baseadas na segunda flag
                                    elif cont >= 4:
                                        value_ = line.split("=")[1].strip()
                                        values.append(value_)
                                    cont += 1
                        # Adiciona as informações lidas nas suas respectivas lineEdits
                        self.dlg_flow_tt.le_1_pg1.setText(str(values[0]))
                        self.dlg_flow_tt.le_2_pg1.setText(str(values[1]))
                        self.dlg_flow_tt.le_3_pg1.setText(str(values[2]))
                        self.dlg_flow_tt.le_4_pg1.setText(str(values[3]))
                        self.dlg_flow_tt.le_5_pg1.setText(str(values[4]))
                        self.dlg_flow_tt.le_6_pg1.setText(str(values[5]))
                        self.dlg_flow_tt.le_7_pg1.setText(str(values[6]))
                        self.dlg_flow_tt.le_8_pg1.setText(str(values[7]))
                        self.dlg_flow_tt.le_9_pg1.setText(str(values[8]))
                        self.dlg_flow_tt.le_10_pg1.setText(str(values[9]))
                        self.dlg_flow_tt.le_11_pg1.setText(str(values[10]))
                        self.dlg_flow_tt.le_12_pg1.setText(str(values[11]))
                        
                        break

                    elif page == 2:
                        # Ler o arquivo da página 2: input dat
                        with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=>' in line:
                                    # Substitui o identificador => por uma string fazia e retira os espaços da linha
                                    value = line.replace('=>', '').strip()
                                    values.append(value)
                        
                        # Adiciona as informações lidas à seus respectivos campos
                        self.dlg_flow_tt.le_1_pg2.setText(str(values[0]))
                        self.dlg_flow_tt.le_2_pg2.setText(str(values[1]))
                        self.dlg_flow_tt.te_1_pg2.setPlainText(str(values[2]))
                        self.dlg_flow_tt.te_1_pg2.append(str(values[3]))
                        self.dlg_flow_tt.le_3_pg2.setText(str(values[4]))
                        self.dlg_flow_tt.le_4_pg2.setText(str(values[5]))
                        self.dlg_flow_tt.le_7_pg2.setText(str(values[6]))

                        # Atribui os valores do arquivo enviado a tabela em questão
                        self.read_tb_from_file_2(self.dlg_flow_tt.tbw_1_pg2,values[6], 1)
                        self.dlg_flow_tt.le_5_pg2.setText(str(values[7]))
                        self.dlg_flow_tt.le_8_pg2.setText(str(values[8]))

                        # Atribui os valores do arquivo enviado a tabela em questão
                        self.read_tb_from_file_2(self.dlg_flow_tt.tbw_2_pg2,values[8],2)
                        self.dlg_flow_tt.le_6_pg2.setText(str(values[9]))
                        
                        break               

                    elif page == 4:
                        # Ler arquivos página 4
                        with open(file_, 'r', encoding='utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=>' in line:
                                    # Substitui o identificador => por uma string fazia e retira os espaços da linha
                                    value = line.replace('=>', '').strip()
                                    values.append(value)

                        # Adiciona as informações lidas à seus respectivos campos            
                        self.dlg_flow_tt.le_1_pg3.setText(str(values[0]))
                        self.dlg_flow_tt.le_2_pg3.setText(str(values[1]))
                        self.dlg_flow_tt.le_3_pg3.setText(str(values[2]))
                        self.dlg_flow_tt.le_4_pg3.setText(str(values[3]))
                        self.dlg_flow_tt.le_5_pg3.setText(str(values[4]))
                        self.dlg_flow_tt.le_6_pg3.setText(str(values[5]))
                        self.dlg_flow_tt.le_7_pg3.setText(str(values[6]))
                        break

                elif function == 2:
                    # Lê os arquivos da primeira página
                    if page == 1:
                        with open(file_, 'r', encoding = 'utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=>' in line:
                                    # Substitui o identificador => por uma string fazia e retira os espaços da linha
                                    value = line.replace('=>', '').strip()
                                    values.append(value)      
                        self.dlg_exc_rain.le_1_pg1.setText(str(values[0]))                      
                        self.dlg_exc_rain.le_2_pg1.setText(str(values[1]))
                        self.dlg_exc_rain.le_4_pg1.setText(str(values[2]))
                        self.dlg_exc_rain.rb_1_pg1.setChecked(str(values[2])=='True')                 
                        self.dlg_exc_rain.rb_2_pg1.setChecked(str(values[3])=='True')             
                        break
                    
                    # Lê informações página rainfall interpolation
                    elif page == 2:
                        with open(file_, 'r', encoding = 'utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=>' in line:
                                    # Substitui o identificador => por uma string fazia e retira os espaços da linha
                                    value = line.replace('=>', '').strip()
                                    values.append(value) 

                        self.dlg_exc_rain.le_1_pg_ri.setText(str(values[0]))           
                        self.dlg_exc_rain.le_2_pg_ri.setText(str(values[1]))           
                        self.dlg_exc_rain.le_3_pg_ri.setText(str(values[2]))           
                        self.dlg_exc_rain.le_4_pg_ri.setText(str(values[3]))
                        self.dlg_exc_rain.le_5_pg_ri.setText(str(values[4]))
                        break         

                    # Lê os arquivos da segunda página
                    elif page == 3:
                        with open(file_, 'r', encoding = 'utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=>' in line:
                                    # Substitui o identificador => por uma string fazia e retira os espaços da linha
                                    value = line.replace('=>', '').strip()
                                    values.append(value) 

                        self.dlg_exc_rain.le_1_pg2.setText(str(values[0]))           
                        self.dlg_exc_rain.le_2_pg2.setText(str(values[1]))           
                        self.dlg_exc_rain.le_3_pg2.setText(str(values[2]))           
                        self.dlg_exc_rain.le_4_pg2.setText(str(values[3]))
                        break

                    # elif page == 4 and file_ != '':

                    # Lê os arquivos da quarta página                    
                    elif page == 5:
                        with open(file_, 'r', encoding = 'utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=>' in line:
                                    # Substitui o identificador => por uma string fazia e retira os espaços da linha
                                    value = line.replace('=>', '').strip()
                                    values.append(value) 
                        self.dlg_exc_rain.le_1_pg4.setText(str(values[0]))           
                        self.dlg_exc_rain.le_2_pg4.setText(str(values[1]))           
                        self.dlg_exc_rain.le_3_pg4.setText(str(values[2]))           
                        self.dlg_exc_rain.le_4_pg4.setText(str(values[3]))
                        self.dlg_exc_rain.le_5_pg4.setText(str(values[4]))
                        self.dlg_exc_rain.le_6_pg4.setText(str(values[5]))
                        break
                
                elif function == 3:
                    # Lê os arquivos da primeira página
                    if page == 1:
                        with open(file_, 'r', encoding = 'utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=>' in line:
                                    # Substitui o identificador => por uma string fazia e retira os espaços da linha
                                    value = line.replace('=>', '').strip()
                                    values.append(value)
                        self.dlg_flow_rout.rb_1_pg1.setChecked(str(values[0])=='True')
                        self.dlg_flow_rout.rb_2_pg1.setChecked(str(values[1])=='True')
                        self.dlg_flow_rout.rb_3_pg1.setChecked(str(values[2])=='True')
                        self.dlg_flow_rout.le_1_pg1.setText(str(values[3]))
                        self.dlg_flow_rout.le_2_pg1.setText(str(values[4]))
                        self.dlg_flow_rout.le_4_pg1.setText(str(values[5]))
                        self.dlg_flow_rout.le_5_pg1.setText(str(values[6]))
                        break
                    # Lê os arquivos da segunda página
                    elif page == 2:
                        with open(file_, 'r', encoding = 'utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=>' in line:
                                    # Substitui o identificador => por uma string fazia e retira os espaços da linha
                                    value = line.replace('=>', '').strip()
                                    values.append(value)

                        self.dlg_flow_rout.le_1_pg2.setText(str(values[0]))
                        self.dlg_flow_rout.le_2_pg2.setText(str(values[1]))
                        self.dlg_flow_rout.le_3_pg2.setText(str(values[2]))
                        self.dlg_flow_rout.le_4_pg2.setText(str(values[3]))
                        self.dlg_flow_rout.le_5_pg2.setText(str(values[4]))
                        break           
                    # Lê os arquivos da quarta página
                    elif page == 4:
                        with open(file_, 'r', encoding = 'utf-8') as arquivo_txt:
                            # Armazenará os valores das linhas
                            values = []
                            for line in arquivo_txt:
                                if '=>' in line:
                                    # Substitui o identificador => por uma string fazia e retira os espaços da linha
                                    value = line.replace('=>', '').strip()
                                    values.append(value)

                        self.dlg_flow_rout.le_1_pg4.setText(str(value[0]))
                        self.dlg_flow_rout.rb_2_pg4.setChecked(bool(values[1]))                 
                        self.dlg_flow_rout.rb_3_pg4.setChecked(bool(values[2]))            
                        self.dlg_flow_rout.le_2_pg4.setText(str(value[3]))           
                        self.dlg_flow_rout.le_3_pg4.setText(str(value[4]))           
                        self.dlg_flow_rout.le_4_pg4.setText(str(value[5]))
                        self.dlg_flow_rout.rb_3_pg4.setChecked(bool(values[6]))                 
                        self.dlg_flow_rout.rb_4_pg4.setChecked(bool(values[7])) 
                        self.dlg_flow_rout.le_5_pg4.setText(str(value[8]))           
                        self.dlg_flow_rout.le_6_pg4.setText(str(value[9]))                          
                        break
            else:
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    break 

    def save_table_to_file(self, table):
        '''Esta função lê as informações adicionadas às tabelas e as armazena em um arquivo'''
        while True:
            if table == 1:
                # Solicita um local de salvamento para o usuário
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "RDN_classes", "Text or CSV Files (*.txt *.csv)")
                if file_name:
                    self.dlg_flow_tt.le_7_pg2.setText(file_name)
                    # seleciona as dimensões da tabela
                    nlin_tb1 = self.dlg_flow_tt.tbw_1_pg2.rowCount()
                    ncol_tb1 = self.dlg_flow_tt.tbw_1_pg2.columnCount()

                    # Escreve o arquivo de saída
                    with open(file_name, 'w', encoding='utf-8') as arquivo_txt_csv:
                        arquivo_txt_csv.write(f'Num_classes:{nlin_tb1}\nClass ID;Slope(m/m);Manning Coef;Hydraulic radius\n')
                        # Adicionando as informações das linhas e colunas ao arquivo de saída
                        for lin in range(nlin_tb1):
                            for col in range(ncol_tb1):
                                item = self.dlg_flow_tt.tbw_1_pg2.item(lin, col)
                                # Verifica se o item existe
                                if item is not None:  
                                    arquivo_txt_csv.write(f'{item.text()}')
                                arquivo_txt_csv.write(';')  
                            arquivo_txt_csv.write('\n')
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break 

            elif table ==2:
                file_name, _ = QFileDialog.getSaveFileName(None, "Save the file", "Manning_roughness_coef_for_each_LULC", "Text or CSV Files (*.txt *.csv)")
                if file_name:
                    self.dlg_flow_tt.le_8_pg2.setText(file_name)
                    # seleciona as dimensões da tabela
                    nlin_tb1 = self.dlg_flow_tt.tbw_2_pg2.rowCount()
                    ncol_tb1 = self.dlg_flow_tt.tbw_2_pg2.columnCount()

                    # Escreve o arquivo de saída
                    with open(file_name, 'w', encoding='utf-8') as arquivo_txt_csv:
                        arquivo_txt_csv.write('Class ID;Class Name;Manning Coef\n')
                        # Adicionando as informações das linhas e colunas ao arquivo de saída
                        for lin in range(nlin_tb1):
                            for col in range(ncol_tb1):
                                item = self.dlg_flow_tt.tbw_2_pg2.item(lin, col)
                                # Verifica se o item existe
                                if item is not None:  
                                    arquivo_txt_csv.write(f'{item.text()}')
                                    arquivo_txt_csv.write(';')  
                            arquivo_txt_csv.write('\n')
                    break
                else:
                    result = "Wait! You did not select any file."
                    reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break 

    def read_tb_from_file(self,table, lineEdit,table_ordem):
        '''Esta função adiciona os valores do arquivo enviado pelo usuário à respectiva tabela'''
        # Seleciona o arquivo enviado pelo usuário
        options = QFileDialog.Options()
        directory = self.dlg_flow_tt.le_21_pg1.text()
        # Atualiza a flag para leitura dos dados da tabela
        self.flag = 1
        self.flag_1 = 1

        while True:
            # Solicita o arquivo
            file_, _ = QFileDialog.getOpenFileName(None, caption="Select a file!", directory=directory, filter="Text or CSV Files (*.txt *.csv)", options=options)
            
            if file_:
                # Configura a primeira tabela
                if table_ordem == 1:
                    lineEdit.setText(file_)
                    # Abre o arquivo e processa as linhas
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                        # Lê a linha e o cabeçalho
                        self.global_vars.nclasses = arquivo_txt_csv.readline().strip().split(':')[1]
                        self.global_vars.nclasses =int(self.global_vars.nclasses)
                        arquivo_txt_csv.readline()

                        # Define o número de linhas que a tabela receberá
                        num_row_total = self.global_vars.nclasses

                        # Inicializa as listas para armazenamento das informações
                        id_class_list = []
                        Sclasse_list = []
                        Mannclasse_list = []
                        Rhclasse_list = []

                        # Iterando sobre as linhas do arquivo
                        for line in arquivo_txt_csv:
                            # Divide a linha nos espaços em branco e converte para float
                            indice, Scla, Mann, Rh = map(float, line.split())
                            # Adiciona os valores às listas
                            id_class_list.append(indice)
                            Sclasse_list.append(Scla)
                            Mannclasse_list.append(Mann)
                            Rhclasse_list.append(Rh)
                    
                    # Atualiza as variáveis gerais
                    self.global_vars.j = np.array(id_class_list)
                    self.global_vars.Sclasse = np.array(Sclasse_list)
                    self.global_vars.Mannclasse = np.array(Mannclasse_list)
                    self.global_vars.Rhclasse = np.array(Rhclasse_list)
                    
                    # Atualiza no número de linhas da tabela (recebe o número de classes dos rios da bacia hidrográfica)
                    table.setRowCount(num_row_total)
                    
                    # Coleta as dimensões da tabela
                    n_row = table.rowCount()
                    n_column = table.columnCount()

                    # Itera sobre os elementos da tabela
                    for col in range(n_column):
                        for lin in range(n_row):
                            if col == 0:
                                # Adiciona a coluna do id
                                item = QTableWidgetItem(str(id_class_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 1:
                                # Adiciona a coluna da declividade
                                item = QTableWidgetItem(str(Sclasse_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 2:
                                # Adiciona a coluna do coef de Manning  
                                item = QTableWidgetItem(str(Mannclasse_list[lin]))
                                table.setItem(lin, col, item)
                            elif col == 3:
                                # Adiciona a coluna do raio hidráulico
                                item = QTableWidgetItem(str(Rhclasse_list[lin]))
                                table.setItem(lin, col, item)               
                    break

                # Configura a segunda tabela
                else:

                    # Criando variável extra, para armazenar os tipos de uso e coeficente de Manning
                    lineEdit.setText(file_)
                    uso_manning = []
                    coef_maning = []
                    class_name = []
                    class_name_val = []
                    uso_manning_val = []
                    coef_maning_val = []

                    # Abrindo o arquivo que contém o coeficiente de Manning para os diferentes usos do solo
                    with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                        # Amazena a linha do cabeçalho
                        firt_line = arquivo_txt_csv.readline().strip()

                        # Lê as informações de uso do solo e coeficiente de Manning 
                        for line in arquivo_txt_csv:
                            # Coletando as informações de cada linha
                            info = line.strip().split()
                            # Armazenando os valores das linhas nas suas respectivas variáveis
                            uso_manning = int(info[0])
                            coef_maning = float(info[1])
                            class_name = str(info[2])


                            # Adicionando os valores nas variáveis destinadas
                            uso_manning_val = np.append(uso_manning_val, uso_manning)
                            coef_maning_val = np.append(coef_maning_val, coef_maning)
                            class_name_val.append(class_name)

                    # Adicionando cada valor às suas respectivas variáveis
                    self.global_vars.usaux = uso_manning_val
                    self.global_vars.Mann = coef_maning_val

                    # Atualiza o número de linhas da tabela
                    table.setRowCount(len(uso_manning_val))

                    # Coleta as dimensões da tabela
                    n_row = table.rowCount()
                    n_column = table.columnCount()

                    # Adiciona as informações à tabela
                    for col in range(n_column):
                        for lin in range(n_row):
                            if col == 0:
                                # Adiciona a coluna class Id
                                item = QTableWidgetItem(str(uso_manning_val[lin]))
                                table.setItem(lin, col, item)
                            elif col == 1:
                                # Adiciona a coluna class Name
                                item = QTableWidgetItem(str(class_name_val[lin]))
                                table.setItem(lin, col, item)
                            elif col == 2:
                                # Adiciona a coluna do coef de Manning  
                                item = QTableWidgetItem(str(coef_maning_val[lin]))
                                table.setItem(lin, col, item)
                    
                    break

            else:
                result = "Wait! You did not select any file."
                reply = QMessageBox.warning(None, "No files selected", result, QMessageBox.Ok | QMessageBox.Cancel)
                if reply == QMessageBox.Cancel:
                    break 
                
    def read_tb_from_file_2(self,table, line_edit,table_ordem):
        '''Esta função adiciona os valores do arquivo enviado pelo usuário ao clicar no botão READ FROM FILE da página 2.
            table == 1: a tabela de referência é a tabelea das caracteristicas da rede de drenagem
            table == 2 referencia a tabela das classes e coeficientes de manning. 
            '''
        # Atribui os valores do arquivo enviado à tabela das características
        if table_ordem == 1:
            file_ = line_edit
            # Abre o arquivo e processa as linhas
            with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                # Lê a linha e o cabeçalho
                arquivo_txt_csv.readline()
                arquivo_txt_csv.readline()

                # Inicializa as listas para armazenamento das informações
                id_class_list = []
                Sclasse_list = []
                Mannclasse_list = []
                Rhclasse_list = []

                # Iterando sobre as linhas do arquivo
                for line in arquivo_txt_csv:
                    # Divide a linha nos espaços em branco e converte para float
                    indice, Scla, Mann, Rh = map(float, line.split())
                    # Adiciona os valores às listas
                    id_class_list.append(indice)
                    Sclasse_list.append(Scla)
                    Mannclasse_list.append(Mann)
                    Rhclasse_list.append(Rh)
            
            # Atualiza no número de linhas da tabela (recebe o número de classes dos rios da bacia hidrográfica)
            table.setRowCount(len(id_class_list))
            
            # Coleta as dimensões da tabela
            n_row = table.rowCount()
            n_column = table.columnCount()
            # Itera sobre os elementos da tabela
            for col in range(n_column):
                for lin in range(n_row):
                    if col == 0:
                        # Adiciona a coluna do id
                        item = QTableWidgetItem(str(id_class_list[lin]))
                        table.setItem(lin, col, item)
                    elif col == 1:
                        # Adiciona a coluna da declividade
                        item = QTableWidgetItem(str(Sclasse_list[lin]))
                        table.setItem(lin, col, item)
                    elif col == 2:
                        # Adiciona a coluna do coef de Manning  
                        item = QTableWidgetItem(str(Mannclasse_list[lin]))
                        table.setItem(lin, col, item)
                    elif col == 3:
                        # Adiciona a coluna do raio hidráulico
                        item = QTableWidgetItem(str(Rhclasse_list[lin]))
                        table.setItem(lin, col, item)               
            
        # Adiciona os dados a tabela de classes
        elif table_ordem == 2:
            
            file_ = line_edit
            # Criando variável extra, para armazenar os tipos de uso e coeficente de Manning
            uso_manning = []
            coef_maning = []
            class_name = []
            class_name_val = []
            uso_manning_val = []
            coef_maning_val = []

            # Abrindo o arquivo que contém o coeficiente de Manning para os diferentes usos do solo
            with open(file_, 'r', encoding='utf-8') as arquivo_txt_csv:
                # Amazena a linha do cabeçalho
                firt_line = arquivo_txt_csv.readline().strip()
                # Lê as informações de uso do solo e coeficiente de Manning 
                for line in arquivo_txt_csv:
                    # Coletando as informações de cada linha
                    info = line.strip().split()
                    # Armazenando os valores das linhas nas suas respectivas variáveis
                    uso_manning = int(info[0])
                    coef_maning = float(info[1])
                    class_name = str(info[2])
                    # Adicionando os valores nas variáveis destinadas
                    uso_manning_val = np.append(uso_manning_val, uso_manning)
                    coef_maning_val = np.append(coef_maning_val, coef_maning)
                    class_name_val.append(class_name)

            # Atualiza o número de linhas da tabela
            table.setRowCount(len(uso_manning_val))
            # Coleta as dimensões da tabela
            n_row = table.rowCount()
            n_column = table.columnCount()
            # Adiciona as informações à tabela
            for col in range(n_column):
                for lin in range(n_row):
                    if col == 0:
                        # Adiciona a coluna class Id
                        item = QTableWidgetItem(str(uso_manning_val[lin]))
                        table.setItem(lin, col, item)
                    elif col == 1:
                        # Adiciona a coluna class Name
                        item = QTableWidgetItem(str(class_name_val[lin]))
                        table.setItem(lin, col, item)
                    elif col == 2:
                        # Adiciona a coluna do coef de Manning  
                        item = QTableWidgetItem(str(coef_maning_val[lin]))
                        table.setItem(lin, col, item)

    def add_new_row(self,table):
        '''Está função adiciona uma linha a uma tabela relecionada'''
        last_row = table.rowCount()
        table.insertRow(last_row)
    
    def delete_row(self,table):
        '''Esta função deleta uma linha de uma referida tabela'''
        selected_row = table.currentRow()
        if selected_row >= 0:
            table.removeRow(selected_row)
        else:
            QMessageBox.warning(None, "Warning", "You did not select any row.")
             
    def save(self):
        '''Esta função é usada para salvar as informações adiconadas'''
        self.save_result = True

    def close_gui(self, function):
        '''Está função é usada para torna nulo (limpar) as informações adicionadas nos diferentes objetos das funções do Hidropixel Plugin
           - Function = 1 : Flow travel time
           - Function = 2 : Excess rainfall
           - Function = 3 : Flow routing'''

        if function == 1:
            # Verifica se alguma lineEdit sobreu alteração: modifica a execução da função close
            line_edit_list = [
                self.dlg_flow_tt.le_1_pg1.text(),
                self.dlg_flow_tt.le_2_pg1.text(),
                self.dlg_flow_tt.le_5_pg1.text(),
                self.dlg_flow_tt.le_6_pg1.text(),
                self.dlg_flow_tt.le_7_pg1.text(),
                self.dlg_flow_tt.le_8_pg1.text(),
                self.dlg_flow_tt.le_9_pg1.text(),
                self.dlg_flow_tt.le_10_pg1.text(),
                self.dlg_flow_tt.le_11_pg1.text(),
                self.dlg_flow_tt.le_12_pg1.text(),
                self.dlg_flow_tt.le_21_pg1.text(),
                self.dlg_flow_tt.le_1_pg2.text(),
                self.dlg_flow_tt.le_2_pg2.text(),
                self.dlg_flow_tt.le_3_pg2.text(),
                self.dlg_flow_tt.le_4_pg2.text(),
                self.dlg_flow_tt.le_5_pg2.text(),
                self.dlg_flow_tt.le_6_pg2.text(),
                self.dlg_flow_tt.le_7_pg2.text(),
                self.dlg_flow_tt.le_8_pg2.text(),
                self.dlg_flow_tt.le_1_pg4.text(),
                self.dlg_flow_tt.le_2_pg4.text(),
                self.dlg_flow_tt.le_3_pg4.text(),
                self.dlg_flow_tt.le_4_pg4.text(),
                self.dlg_flow_tt.le_5_pg4.text(),
                self.dlg_flow_tt.le_6_pg4.text(),
                self.dlg_flow_tt.le_7_pg4.text()
            ]

            # Verifica se algum elemento da lista de line_edits foi modificado
            if any(item != '' for item in line_edit_list) and self.save_result == False:
                while True:

                    result = "Wait! You did not save your changes. Are you sure you want to close?"
                    reply = QMessageBox.warning(None, "Changes not saved", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break

                    else: 
                        # Limpando as informações armazenadas: line edit
                        self.dlg_flow_tt.le_1_pg1.clear()
                        self.dlg_flow_tt.le_2_pg1.clear()
                        self.dlg_flow_tt.le_3_pg1.clear()
                        self.dlg_flow_tt.le_4_pg1.clear()
                        self.dlg_flow_tt.le_5_pg1.clear()
                        self.dlg_flow_tt.le_6_pg1.clear()
                        self.dlg_flow_tt.le_7_pg1.clear()
                        self.dlg_flow_tt.le_8_pg1.clear()
                        self.dlg_flow_tt.le_9_pg1.clear()
                        self.dlg_flow_tt.le_10_pg1.clear()
                        self.dlg_flow_tt.le_11_pg1.clear()
                        self.dlg_flow_tt.le_12_pg1.clear()
                        self.dlg_flow_tt.le_21_pg1.clear()

                        self.dlg_flow_tt.le_1_pg2.clear()
                        self.dlg_flow_tt.le_2_pg2.clear()
                        self.dlg_flow_tt.te_1_pg2.clear()
                        self.dlg_flow_tt.le_3_pg2.clear()
                        self.dlg_flow_tt.le_4_pg2.clear()
                        self.dlg_flow_tt.le_5_pg2.clear()
                        self.dlg_flow_tt.le_6_pg2.clear()
                        self.dlg_flow_tt.le_7_pg2.clear()
                        self.dlg_flow_tt.le_8_pg2.clear()

                        self.dlg_flow_tt.le_1_pg4.clear()
                        self.dlg_flow_tt.le_2_pg4.clear()
                        self.dlg_flow_tt.le_3_pg4.clear()
                        self.dlg_flow_tt.le_4_pg4.clear()
                        self.dlg_flow_tt.le_5_pg4.clear()
                        self.dlg_flow_tt.le_6_pg4.clear()
                        self.dlg_flow_tt.le_7_pg4.clear()

                        # Limpando as informações armazenadas: tables widgets
                        nlin_tb1 = self.dlg_flow_tt.tbw_1_pg2.rowCount()
                        ncol_tb1 = self.dlg_flow_tt.tbw_1_pg2.columnCount()
                        nlin_tb2 = self.dlg_flow_tt.tbw_2_pg2.rowCount()
                        ncol_tb2 = self.dlg_flow_tt.tbw_2_pg2.columnCount()
                        # Primeira tabela
                        for lin in range(nlin_tb1):
                            for col in range(ncol_tb1):
                                item = self.dlg_flow_tt.tbw_1_pg2.item(lin, col)
                                if item is not None:
                                    item.setText('')

                        # Segunda tabela
                        for lin in range(nlin_tb2):
                            for col in range(ncol_tb2):
                                item = self.dlg_flow_tt.tbw_2_pg2.item(lin, col)
                                if item is not None:
                                    item.setText('')
                        self.dlg_flow_tt.ch_1_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_2_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_3_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_4_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_5_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_6_pg4.setChecked(False)  
                        self.dlg_flow_tt.ch_7_pg4.setChecked(False)
                        self.dlg_flow_tt.close()

                    # Atualiza as variáveis para a condição de salvamento
                    self.save_result = False
                    break

            # Se não houver moficações nos objetos do plugin, a janela será fechada normalmente
            else:
                self.dlg_flow_tt.close()
                self.save_result = False

        elif function == 2:
            # Verifica se alguma lineEdit sobreu alteração: modifica a execução da função close
            line_edit_list = [
                self.dlg_exc_rain.le_1_pg1.text(),
                self.dlg_exc_rain.le_2_pg1.text(),
                self.dlg_exc_rain.le_3_pg1.text(),
                self.dlg_exc_rain.le_1_pg_ri.text(),
                self.dlg_exc_rain.le_2_pg_ri.text(),
                self.dlg_exc_rain.le_3_pg_ri.text(),
                self.dlg_exc_rain.le_4_pg_ri.text(),
                self.dlg_exc_rain.le_5_pg_ri.text(),
                self.dlg_exc_rain.le_1_pg2.text(),
                self.dlg_exc_rain.le_2_pg2.text(),
                self.dlg_exc_rain.le_3_pg2.text(),
                self.dlg_exc_rain.le_4_pg2.text(),
                self.dlg_exc_rain.le_1_pg4.text(),
                self.dlg_exc_rain.le_2_pg4.text(),
                self.dlg_exc_rain.le_3_pg4.text(),
                self.dlg_exc_rain.le_4_pg4.text(),
                self.dlg_exc_rain.le_5_pg4.text(),
                self.dlg_exc_rain.le_6_pg4.text()
            ]

            # Verifica se algum elemento da função foi modificado
            if any(item != '' for item in line_edit_list) and self.save_result == False:
                while True:

                    result = "Wait! You did not save your changes. Are you sure you want to close?"
                    reply = QMessageBox.warning(None, "Changes not saved", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break
                    
                    else:
                        # Limpando os elementos da função excess rainfall
                        self.dlg_exc_rain.le_1_pg1.clear()
                        self.dlg_exc_rain.le_2_pg1.clear()
                        self.dlg_exc_rain.le_3_pg1.clear()
                        self.dlg_exc_rain.le_4_pg1.clear()
                        self.dlg_exc_rain.le_1_pg_ri.clear()
                        self.dlg_exc_rain.le_2_pg_ri.clear()
                        self.dlg_exc_rain.le_3_pg_ri.clear()
                        self.dlg_exc_rain.le_4_pg_ri.clear()
                        self.dlg_exc_rain.le_5_pg_ri.clear()
                        self.dlg_exc_rain.le_1_pg2.clear()
                        self.dlg_exc_rain.le_2_pg2.clear()
                        self.dlg_exc_rain.le_3_pg2.clear()
                        self.dlg_exc_rain.le_4_pg2.clear()
                        self.dlg_exc_rain.le_1_pg4.clear()
                        self.dlg_exc_rain.le_2_pg4.clear()
                        self.dlg_exc_rain.le_3_pg4.clear()
                        self.dlg_exc_rain.le_4_pg4.clear()
                        self.dlg_exc_rain.le_5_pg4.clear()
                        self.dlg_exc_rain.le_6_pg4.clear()     
                        self.dlg_exc_rain.rb_1_pg1.setChecked(False) 
                        self.dlg_exc_rain.rb_2_pg1.setChecked(False) 
                        self.dlg_exc_rain.ch_1_pg4.setChecked(False)  
                        self.dlg_exc_rain.ch_2_pg4.setChecked(False)  
                        self.dlg_exc_rain.ch_3_pg4.setChecked(False)  
                        self.dlg_exc_rain.ch_4_pg4.setChecked(False)  
                        self.dlg_exc_rain.ch_5_pg4.setChecked(False)  
                        self.dlg_exc_rain.ch_6_pg4.setChecked(False)
                        self.dlg_exc_rain.close()

                    # Atualiza as variáveis para a condição de salvamento
                    self.save_result = False
                    break
            else:
                # Se não houver moficações nos objetos do plugin, a janela será fechada normalmente
                self.save_result = False
                self.dlg_exc_rain.close()

        elif function == 3:
            # Verifica se alguma lineEdit sobreu alteração: modifica a execução da função close
            line_edit_list = [
                self.dlg_flow_rout.le_1_pg1.text(),
                self.dlg_flow_rout.le_2_pg1.text(),
                self.dlg_flow_rout.le_3_pg1.text(),
                self.dlg_flow_rout.le_4_pg1.text(),
                self.dlg_flow_rout.le_5_pg1.text(),
                self.dlg_flow_rout.le_1_pg2.text(),
                self.dlg_flow_rout.le_2_pg2.text(),
                self.dlg_flow_rout.le_3_pg2.text(),
                self.dlg_flow_rout.le_4_pg2.text(),
                self.dlg_flow_rout.le_5_pg2.text(),
                self.dlg_flow_rout.le_1_pg4.text(),
                self.dlg_flow_rout.le_2_pg4.text(),
                self.dlg_flow_rout.le_3_pg4.text(),
                self.dlg_flow_rout.le_4_pg4.text(),
                self.dlg_flow_rout.le_5_pg4.text(),
                self.dlg_flow_rout.le_6_pg4.text()
            ]

            # Verifica se algum elemento da função foi modificado
            if any(item != '' for item in line_edit_list) and self.save_result == False:
                while True:

                    result = "Wait! You did not save your changes. Are you sure you want to close?"
                    reply = QMessageBox.warning(None, "Changes not saved", result, QMessageBox.Ok | QMessageBox.Cancel)
                    if reply == QMessageBox.Cancel:
                        break
                    
                    else:
                        # Limpando os elementos da função excess rainfall
                        self.dlg_flow_rout.le_1_pg1.clear()
                        self.dlg_flow_rout.le_2_pg1.clear()
                        self.dlg_flow_rout.le_3_pg1.clear()
                        self.dlg_flow_rout.le_4_pg1.clear()
                        self.dlg_flow_rout.le_5_pg1.clear()
                        self.dlg_flow_rout.le_1_pg2.clear()
                        self.dlg_flow_rout.le_2_pg2.clear()
                        self.dlg_flow_rout.le_3_pg2.clear()
                        self.dlg_flow_rout.le_4_pg2.clear()
                        self.dlg_flow_rout.le_5_pg2.clear()
                        self.dlg_flow_rout.le_1_pg4.clear()
                        self.dlg_flow_rout.le_2_pg4.clear()
                        self.dlg_flow_rout.le_3_pg4.clear()
                        self.dlg_flow_rout.le_4_pg4.clear()
                        self.dlg_flow_rout.le_5_pg4.clear()
                        self.dlg_flow_rout.le_6_pg4.clear()     
                        self.dlg_flow_rout.rb_1_pg1.setChecked(False) 
                        self.dlg_flow_rout.rb_2_pg1.setChecked(False) 
                        self.dlg_flow_rout.rb_3_pg1.setChecked(False)  
                        self.dlg_flow_rout.rb_1_pg4.setChecked(False) 
                        self.dlg_flow_rout.rb_2_pg4.setChecked(False) 
                        self.dlg_flow_rout.rb_3_pg4.setChecked(False) 
                        self.dlg_flow_rout.rb_4_pg4.setChecked(False) 
                        self.dlg_flow_rout.ch_1_pg4.setChecked(False)  
                        self.dlg_flow_rout.ch_2_pg4.setChecked(False)  
                        self.dlg_flow_rout.ch_3_pg4.setChecked(False)  
                        self.dlg_flow_rout.ch_4_pg4.setChecked(False)  
                        self.dlg_flow_rout.ch_5_pg4.setChecked(False)  
                        self.dlg_flow_rout.ch_6_pg4.setChecked(False)
                        self.dlg_flow_rout.close()

                    # Atualiza as variáveis para a condição de salvamento
                    self.save_result = False
                    break
   
            else:
                # Se não houver moficações nos objetos do plugin, a janela será fechada normalmente
                self.save_result = False
                self.dlg_flow_rout.close()

    def clear_table(self,table,lineEdit):
        '''Esta função limpa os valores armazenados na respectiva tabela'''
        # Limpando as informações armazenadas: tables widgets
        nlin_tb1 = table.rowCount()
        ncol_tb1 = table.columnCount()

        # Reinicia a respectiva tabela
        for lin in range(nlin_tb1):
            for col in range(ncol_tb1):
                item = table.item(lin, col)
                if item is not None:
                    item.setText('')
        # Limpa a lineEdit
        lineEdit.clear()

    def adiciona_layer(self, file_path):
        '''Esta função adiciona um arquivo enviado às layers do atual projeto do usuário no QGIS'''
        # Adiciona o arquivo raster ao projeto do QGIS
        file_name = os.path.basename(file_path)
        layer = QgsRasterLayer(file_path, 'gdal')
        layer.setName(file_name)
        QgsProject.instance().addMapLayer(layer)

        # Atualiza a tela do QGIS
        iface.layerTreeView().refreshLayerSymbology(layer.id())

    def rain_def_condition(self, rain_condition):
        '''Esta função verifica a condição da variável precipitação para execução da rotina Excess rainfall
           - rain_condition == 1 : areal averaged
           - rain_condition == 2 : spatiallu distributed'''

        if rain_condition == 1:
            # Objetos ligado a opção de precipitação média na área da baica ficam ativos
            self.dlg_exc_rain.le_3_pg2.setEnabled(True)
            self.dlg_exc_rain.label_31.setEnabled(True)
            self.dlg_exc_rain.tbtn_pg2_3.setEnabled(True)
            self.dlg_exc_rain.label_35.setEnabled(True)  

            # Objetos ligado a opção de precipitação distribuida espacialmente ficam inativos
            self.dlg_exc_rain.le_4_pg2.setEnabled(False)
            self.dlg_exc_rain.label_32.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_4.setEnabled(False)
            self.dlg_exc_rain.label_36.setEnabled(False)           

        elif rain_condition == 2:
            # Objetos ligado a opção de precipitação distribuida espacialmente ficam ativos
            self.dlg_exc_rain.le_4_pg2.setEnabled(True)
            self.dlg_exc_rain.label_32.setEnabled(True)
            self.dlg_exc_rain.tbtn_pg2_4.setEnabled(True)
            self.dlg_exc_rain.label_36.setEnabled(True)
            
            # Objetos ligado a opção de precipitação média na área da baica ficam inativos         
            self.dlg_exc_rain.le_3_pg2.setEnabled(False)
            self.dlg_exc_rain.label_31.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_3.setEnabled(False)
            self.dlg_exc_rain.label_35.setEnabled(False)  

    def cancel_log_page(self, text_edit, pg_parameters, pg_logge):
        '''Esta função configura o botão de cancelar da página de log'''
        mensagem_log1 = None
        # Cria texto formatado para adicionar ao text edit? mensagem de aviso
        mensagem_log1 = '<font>\nATTENTION: stopping FLOW TRAVEL TIME process...</font>'

        # Adiciona o texto formatado no QTextEdit
        text_edit.insertHtml(mensagem_log1)

        # Reativa a página de parametros
        pg_parameters.setEnabled(True)

        # Desativa a página de logge
        pg_logge.setEnabled(False)

    def cancel_rainfall_interpol(self):
        '''Esta configura o botão cancel da página run da função rainfall interpolation'''
        # Adiciona mensagem de cancelamento do processo 
        self.dlg_rain_interpl_run.te_rain_int('BREAKING THE RAINFALL INTERPOLATION PROCESSING...')
        self.dlg_rain_interpl_run.close()

    def run_flow_tt(self):
        '''Está função ativa a página de log e configura a ordem de execução das funções para o cálculo do tempo de viagem'''
        # Ativiva a página de log e limpa as informações passadas no text_edit 
        mensagem_log1 = None
        self.dlg_flow_tt.tabWidget.setCurrentIndex(1)
        self.dlg_flow_tt.pg_log_ftt.setEnabled(True)
        self.dlg_flow_tt.te_logg.clear()

        # Configura a progressbar
        self.dlg_flow_tt.progressBar.setRange(0, 100)
        self.dlg_flow_tt.progressBar.setValue(0)

        # Adiciona avisa acerca do tempo de processamento
        reply = QMessageBox.information(None, "Information", "This will take a few minutes (maybe hours)...", QMessageBox.Ok | QMessageBox.Cancel)
        
        # Apenas inicia o prpocessamento se o usuário estiver de acordo com o tempo de processamento
        if reply == QMessageBox.Ok:

            # Configura as informações do textEdit da referida página
            font = QFont()
            font.setPointSize(11)
            version_info = {
                "QGIS Version": '3.34.0-Prizren',
                "Qt Version": '5.15.3',
                "Python Version": '3.9.5',
                "GDAL Version": '3.8.0'}
            
            datatime_started = datetime.now().isoformat()
            mensagem_log1 = "The plugin was developed with:\n"
            mensagem_log1 += f"QGIS Version: {version_info['QGIS Version']}\n"
            mensagem_log1 += f"Qt Version: {version_info['Qt Version']}\n"
            mensagem_log1 += f"Python Version: {version_info['Python Version']}\n"
            mensagem_log1 += f"GDAL Version: {version_info['GDAL Version']}\n"
            mensagem_log1 += "--------------------------------------------------------\n"
            mensagem_log1 += f"Algorithm started at: {datatime_started}\n"
            mensagem_log1 += "--------------------------------------------------------\n"

            # Cria condição de parada da execução: se o usuário clicar no botão cancel da página de log
            while True:
                # Método usado para permitir a iteração do usuário enquanto o programa está em execução
                QApplication.processEvents()
                self.dlg_flow_tt.btn_cancel_log.clicked.connect(lambda: self.cancel_log_page(self.dlg_flow_tt.te_logg,self.dlg_flow_tt.pg_par_ftt, self.dlg_flow_tt.pg_log_ftt))

                # Verifica a existência de incoerências nas informações fornecidas pelo usuário
                list_line_edit_value_pg1 = [self.dlg_flow_tt.le_5_pg1.text(),
                                            self.dlg_flow_tt.le_6_pg1.text(),
                                            self.dlg_flow_tt.le_7_pg1.text(),
                                            self.dlg_flow_tt.le_8_pg1.text(),
                                            self.dlg_flow_tt.le_9_pg1.text(),
                                            self.dlg_flow_tt.le_10_pg1.text(),
                                            self.dlg_flow_tt.le_11_pg1.text(),
                                            self.dlg_flow_tt.le_12_pg1.text()
                                        ]
                duplicate = []
                # Verifica se há duplicatas no código
                for i in range(len(list_line_edit_value_pg1)):
                    for j in range(i+1,len(list_line_edit_value_pg1)):
                        if list_line_edit_value_pg1[i] == list_line_edit_value_pg1[j]:
                            # Para os elementos iguais, armazena eles em uma lista
                            duplicate.append(list_line_edit_value_pg1[i])

                if any(item == '' for item in duplicate):
                    self.dlg_flow_tt.pages_flow_tt.setCurrentIndex(0)
                    # Vefica se os códigos das diferções de drenagem foram corretamente enviados
                    QMessageBox.warning(self.dlg_flow_tt, 'Warning', "Direction codes might not None.")
                    return

                elif duplicate and all(item != '' for item in duplicate):
                    self.dlg_flow_tt.pages_flow_tt.setCurrentIndex(0)
                    # O usuário enviou 2 valores semelhantes, será mostrado uma mensagem de erro
                    QMessageBox.warning(self.dlg_flow_tt, 'Warning', f"The value(s) '{duplicate}' is(are) (a) duplicate(s)! Direction codes do not accept duplicates.")
                    return
                    
                else:
                    # Se não existir erros nas informações enviadas, será mostrada a página de log e o programa será executado
                    self.dlg_flow_tt.pg_par_ftt.setEnabled(False)

                    # Adiciona as mensagem de log ao text edit e configura a função run
                    self.dlg_flow_tt.te_logg.append(mensagem_log1)

                    # ---Entradas---
                    mensagem_log1 = "READING INPUT FILES...\n"
                    arquivo_bacia = self.dlg_flow_tt.le_1_pg2.text()
                    self.leh_bacia(arquivo_bacia,1)
                    self.leh_direcoes_de_fluxo()
                    self.leh_modelo_numerico_dTerreno()
                    self.leh_drenagem()
                    self.leh_uso_do_solo()
                    self.dlg_flow_tt.te_logg.append(mensagem_log1)

                    if self.flag == 0:
                        # O usuário digitou as informações
                        self.leh_valores_table_1()
                    
                    if self.flag_1 == 0:
                        # O usuário digitou as informações
                        self.leh_valores_table_2()

                    self.leh_precipitacao_24h()

                    # Atualiza a progressbar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    # ---Cálculos---
                    mensagem_log1 = 'PROCESSING...\n'
                    self.dlg_flow_tt.te_logg.append(mensagem_log1)
                    if self.global_vars.unidaderef3 == 'deg':
                        # sistema em graus, assumindo latlong
                        self.global_vars.metro = 0
                    else:
                        # sistema em metros
                        # se sistema de referencia em metros, fazer metro=1 (não faz projeção)
                        # caso contrário (se metro=0), assume que está graus e faz projeção para metros
                        self.global_vars.metro = 1

                    # Processing NumeraPix...
                    self.numera_pixel()

                    # Atualiza a progressbar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    # Processing DistDren...
                    self.dist_drenagem()

                    # Atualiza a progressbar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    # Processing DistTrecho...
                    self.dist_trecho()
                    
                    # Atualiza a progressbar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    # Processing TempoSup...
                    self.tempo_sup()
                    
                    # Atualiza a progressbar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    # Processing ComprimAcu...
                    self.comprimento_acumulado()
                    
                    # Atualiza a progressbar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    # Processing TempoCanal...
                    self.tempo_canal()
                    
                    # Atualiza a progressbar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)
                    
                    # Processig TempoTotal...
                    self.tempo_total_func()
                    
                    # Atualiza a progressbar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    # Saídas
                    mensagem_log1 = 'WRITING OUTPUT FILES...\n'
                    self.dlg_flow_tt.te_logg.append(mensagem_log1)

                    if self.dlg_flow_tt.ch_1_pg4.isChecked():
                        # Cria o arquivo selecionado
                        self.escreve_num_pix_drenagem()

                    if self.dlg_flow_tt.ch_2_pg4.isChecked():
                        # Cria o arquivo selecionado
                        self.escreve_conectividade()

                    if self.dlg_flow_tt.ch_3_pg4.isChecked():
                        # Cria o arquivo selecionado
                        self.escreve_comprimento_acumulado()

                    if self.dlg_flow_tt.ch_4_pg4.isChecked():
                        # Cria o arquivo selecionado
                        self.escreve_comprimento_acumulado_foz()

                    if self.dlg_flow_tt.ch_5_pg4.isChecked():
                        # Cria o arquivo selecionado
                        self.escreve_declivi_pixel()

                    if self.dlg_flow_tt.ch_6_pg4.isChecked():
                        # Cria o arquivo selecionado
                        self.escreve_decliv_pixel_jus()

                    if self.dlg_flow_tt.ch_7_pg4.isChecked():
                        # Cria o arquivo selecionado
                        self.escreve_tempo_total()

                    # Atualiza a progressbar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    mensagem_log1 = 'ADDING FILES SELECTED TO PROJECT LAYERS IN QGIS...\n'
                    self.dlg_flow_tt.te_logg.append(mensagem_log1)

                    if self.dlg_flow_tt.ch_8_pg4.isChecked() and self.fn_num_pix_dren  != '':
                        # Adiciona o arquivo selecionado: num_pix_dren
                        self.adiciona_layer(self.fn_num_pix_dren)
                        mensagem_log1 = 'Added...\n'
                        self.dlg_flow_tt.te_logg.append(mensagem_log1)

                    if self.dlg_flow_tt.ch_9_pg4.isChecked() and self.fn_n_conect_dren  != '':
                        # Adiciona o arquivo selecionado: num_conexao_dren
                        self.adiciona_layer(self.fn_n_conect_dren)
                        mensagem_log1 = 'Added...\n'
                        self.dlg_flow_tt.te_logg.append(mensagem_log1)

                    if self.dlg_flow_tt.ch_10_pg4.isChecked() and self.fn_comp_acum != '':
                        # Adiciona o arquivo selecionado
                        self.adiciona_layer(self.fn_comp_acum)
                        mensagem_log1 = 'Added...\n'
                        self.dlg_flow_tt.te_logg.append(mensagem_log1)

                    if self.dlg_flow_tt.ch_11_pg4.isChecked() and self.fn_comp_foz != '':
                        # Adiciona o arquivo selecionado
                        self.adiciona_layer(self.fn_comp_foz)
                        mensagem_log1 = 'Added...\n'
                        self.dlg_flow_tt.te_logg.append(mensagem_log1)

                    if self.dlg_flow_tt.ch_12_pg4.isChecked() and self.fn_decli_pix != '':
                        # Adiciona o arquivo selecionado
                        self.adiciona_layer(self.fn_decli_pix)
                        mensagem_log1 = 'Added...\n'
                        self.dlg_flow_tt.te_logg.append(mensagem_log1)

                    if self.dlg_flow_tt.ch_13_pg4.isChecked() and self.fn_decli_pix_jus != '':
                        # Adiciona o arquivo selecionado
                        self.adiciona_layer(self.fn_decli_pix_jus)
                        mensagem_log1 = 'Added...\n'
                        self.dlg_flow_tt.te_logg.append(mensagem_log1)

                    if self.dlg_flow_tt.ch_14_pg4.isChecked() and self.fn_temp_total != '':
                        # Adiciona o arquivo selecionado
                        self.adiciona_layer(self.fn_temp_total)
                        mensagem_log1 = 'Added...\n'
                        self.dlg_flow_tt.te_logg.append(mensagem_log1)

                    # Atualiza a progressbar
                    self.dlg_flow_tt.progressBar.setValue(self.dlg_flow_tt.progressBar.value() + 10)

                    # Adiciona as informação ao text edit
                    QMessageBox.information(None, "Information", "Operation completed successfully!", )

                    # Finaliza execução do programa
                    break
        else:
            # O usuário selecionou a opção para cancelar
            self.dlg_flow_tt.tabWidget.setCurrentIndex(0)

    def run_exc_rain(self):
        '''Está função ativa a página de log e configura a ordem de execução das funções da rotina excess rainfall'''
        # Ativiva a página de log e limpa as informações passadas no text_edit 
        mensagem_log1 = None
        self.dlg_exc_rain.tabWidget.setCurrentIndex(1)
        self.dlg_exc_rain.pg_log_exc_rain.setEnabled(True)
        self.dlg_exc_rain.te_logg.clear()

        # Configura a progressbar
        self.dlg_exc_rain.progressBar.setRange(0, 100)
        self.dlg_exc_rain.progressBar.setValue(0)

        # Adiciona avisa acerca do tempo de processamento
        reply = QMessageBox.information(None, "Information", "This will take a few minutes (maybe hours)...", QMessageBox.Ok | QMessageBox.Cancel)
        
        # Apenas inicia o prpocessamento se o usuário estiver de acordo com o tempo de processamento
        if reply == QMessageBox.Ok:

            # Configura as informações do textEdit da referida página
            font = QFont()
            font.setPointSize(11)
            version_info = {
                "QGIS Version": '3.34.0-Prizren',
                "Qt Version": '5.15.3',
                "Python Version": '3.9.5',
                "GDAL Version": '3.8.0'}
            
            datatime_started = datetime.now().isoformat()
            mensagem_log1 = "The plugin was developed with:\n"
            mensagem_log1 += f"QGIS Version: {version_info['QGIS Version']}\n"
            mensagem_log1 += f"Qt Version: {version_info['Qt Version']}\n"
            mensagem_log1 += f"Python Version: {version_info['Python Version']}\n"
            mensagem_log1 += f"GDAL Version: {version_info['GDAL Version']}\n"
            mensagem_log1 += "--------------------------------------------------------\n"
            mensagem_log1 += f"Algorithm started at: {datatime_started}\n"
            mensagem_log1 += "--------------------------------------------------------\n"
            self.dlg_exc_rain.te_logg.append(mensagem_log1)

            # Cria condição de parada da execução: se o usuário clicar no botão cancel da página de log
            while True:
                # Método usado para permitir a iteração do usuário enquanto o programa está em execução
                QApplication.processEvents()
                self.dlg_exc_rain.btn_cancel_log.clicked.connect(lambda: self.cancel_log_page(self.dlg_exc_rain.te_logg, self.dlg_exc_rain.pg_par_exc_rain, self.dlg_exc_rain.pg_log_exc_rain))
                
                # Initial configuration
                if self.rdc_vars.unidaderef =='deg':
                    # Sistema está em graus, assumindo lat e long: será feita a projeção para metros
                    self.global_vars.metro = 0
                else:
                    # Sistema está em metros, não é preciso fazer a projeção para metros
                    self.global_vars.metro = 1

                # Reading input files
                mensagem_log1 = 'READING INPUT FILES...\n'
                self.dlg_exc_rain.te_logg.append(mensagem_log1)
                # Lê arquivo da bacia hidrográfica
                arquivo_bacia = self.dlg_exc_rain.le_1_pg2.text()
                self.leh_bacia(arquivo_bacia, 2)
                
                # Lê arquico contendo o valor do Curve Number para cada pixel da bacia hidrográfica 
                self.leh_CN()
                self.leh_parametros(self.dlg_exc_rain.le_1_pg1.text(),self.dlg_exc_rain.le_2_pg1.text(),self.dlg_exc_rain.le_4_pg1.text() ,1)
                self.leh_precip_distribuida(self.dlg_exc_rain.le_4_pg2.text())

                # Atualiza a progressbar
                self.dlg_exc_rain.progressBar.setValue(self.dlg_exc_rain.progressBar.value() + 10)
                
                # Processing and wrinting output files
                mensagem_log1 = 'PROCESSING...\n'
                self.dlg_exc_rain.te_logg.append(mensagem_log1)                
                self.numera_pix_bacia()
                self.excess_rainfall()

                # Atualiza a progressbar
                self.dlg_exc_rain.progressBar.setValue(self.dlg_exc_rain.progressBar.value() + 50)  
          
                # Saídas
                mensagem_log1 = 'WRITING OUTPUT FILES...\n'
                self.dlg_exc_rain.te_logg.append(mensagem_log1)
                if self.dlg_exc_rain.ch_1_pg4.isChecked():
                    # Cria o arquivo selecionado
                    self.escreve_numb_pix_bacia()

                if self.dlg_exc_rain.ch_2_pg4.isChecked():
                    # Cria o arquivo selecionado
                    self.escreve_S_potencial()

                if self.dlg_exc_rain.ch_3_pg4.isChecked():
                    # Cria o arquivo selecionado
                    self.escreve_perdas_ini()

                if self.dlg_exc_rain.ch_4_pg4.isChecked():
                    # Cria o arquivo selecionado
                    self.escreve_precipitacao_total_acum()

                if self.dlg_exc_rain.ch_5_pg4.isChecked():
                    # Cria o arquivo selecionado
                    self.escreve_precipitacao_excedente()

                if self.dlg_exc_rain.ch_6_pg4.isChecked():
                    # Cria o arquivo selecionado
                    self.escreve_hietograma_pe()

                # Atualiza a progressbar
                self.dlg_exc_rain.progressBar.setValue(self.dlg_exc_rain.progressBar.value() + 20)

                mensagem_log1 = 'ADDING FILES SELECTED TO PROJECT LAYERS IN QGIS...\n'
                self.dlg_exc_rain.te_logg.append(mensagem_log1)

                if self.dlg_exc_rain.ch_7_pg4.isChecked() and self.fn_numb_pix != '':
                    # Adiciona o arquivo selecionado: numbering pixel_basin
                    self.adiciona_layer(self.fn_numb_pix)
                    mensagem_log1 = 'Added...\n'
                    self.dlg_exc_rain.te_logg.append(mensagem_log1)

                if self.dlg_exc_rain.ch_8_pg4.isChecked() and self.fn_Spotencial != '':
                    # Adiciona o arquivo selecionado: maximum potencial retention
                    self.adiciona_layer(self.fn_Spotencial)
                    mensagem_log1 = 'Added...\n'
                    self.dlg_exc_rain.te_logg.append(mensagem_log1)

                if self.dlg_exc_rain.ch_9_pg4.isChecked() and self.fn_perda_ini != '':
                    # Adiciona o arquivo selecionado: inital abstraction
                    self.adiciona_layer(self.fn_perda_ini)
                    mensagem_log1 = 'Added...\n'
                    self.dlg_exc_rain.te_logg.append(mensagem_log1)

                if self.dlg_exc_rain.ch_10_pg4.isChecked() and self.fn_p_acum != '':
                    # Adiciona o arquivo selecionado: total rainfall
                    self.adiciona_layer(self.fn_p_acum)
                    mensagem_log1 = 'Added...\n'
                    self.dlg_exc_rain.te_logg.append(mensagem_log1)

                if self.dlg_exc_rain.ch_11_pg4.isChecked() and self.fn_pe_acum != '':
                    # Adiciona o arquivo selecionado: total excess rainfall
                    self.adiciona_layer(self.fn_pe_acum)
                    mensagem_log1 = 'Added...\n'
                    self.dlg_exc_rain.te_logg.append(mensagem_log1)

                # Atualiza a progressbar
                self.dlg_exc_rain.progressBar.setValue(self.dlg_exc_rain.progressBar.value() + 20)
                if self.dlg_exc_rain.progressBar.value() != 100:
                    self.dlg_exc_rain.progressBar.setValue(100)
                # Finaliza operação do programa
                QMessageBox.information(None, "Information", "Operation completed successfully!", )
                break
        else:
            # O usuário selecionou a opção para cancelar
            self.dlg_exc_rain.tabWidget.setCurrentIndex(0)

    def run_rainfall_interpolation(self, interpol_map):
        '''Esta função ordena a execução dos métodos para realizar a interpolação da precipitação para toda a bacia hidrográfica
           interpol_map == 0: gera apenas o arquivo txt com a precipitação por pixel ao longo dos eventos
           interpol_map == 1: gera um arquivo raster contento a precipitação por pixel para cada um dos eventos de precipitação'''
        # Ativiva a página de log e limpa as informações passadas no text_edit 
        # Verifica se algum elemento da lista de line_edits foi modificado
        while True:
            mensagem_log1 = None
            line_edit_list = [
                self.dlg_exc_rain.le_1_pg_ri.text(),
                self.dlg_exc_rain.le_2_pg_ri.text(),
                self.dlg_exc_rain.le_3_pg_ri.text(),
                self.dlg_exc_rain.le_4_pg_ri.text(),
                self.dlg_exc_rain.le_5_pg_ri.text()
                ]
            if False:
                result = "Wait! The input files are empty! You need to provide them."
                reply = QMessageBox.warning(None, "No input files", result, QMessageBox.Ok)
                if reply == QMessageBox.Ok:
                    break

            else:

                self.dlg_rain_interpl_run.show()
                self.dlg_rain_interpl_run.te_rain_int.clear()

                # Configura a progressbar
                self.dlg_rain_interpl_run.progressBar.setRange(0, 100)
                self.dlg_rain_interpl_run.progressBar.setValue(0)

                # Adiciona avisa acerca do tempo de processamento
                reply = QMessageBox.information(None, "Information", "This will take a few minutes (maybe hours)...", QMessageBox.Ok | QMessageBox.Cancel)
                
                # Apenas inicia o prpocessamento se o usuário estiver de acordo com o tempo de processamento
                if reply == QMessageBox.Ok:

                    # Configura as informações do textEdit da referida página
                    font = QFont()
                    datatime_started = datetime.now().isoformat()
                    mensagem_log1 = f"Algorithm started at: {datatime_started}\n"
                    mensagem_log1 += "--------------------------------------------------------\n"
                    self.dlg_rain_interpl_run.te_rain_int.append(mensagem_log1)
                    # Cria condição de parada da execução: se o usuário clicar no botão cancel da página de log
                    while True:
                        # Método usado para permitir a iteração do usuário enquanto o programa está em execução
                        QApplication.processEvents()
                        self.dlg_rain_interpl_run.btn_cancel_rain_int.clicked.connect(lambda: self.cancel_rainfall_interpol())
                        
                        # Initial configuration
                        if self.rdc_vars.unidaderef =='deg':
                            # Sistema está em graus, assumindo lat e long: será feita a projeção para metros
                            self.global_vars.metro = 0
                        else:
                            # Sistema está em metros, não é preciso fazer a projeção para metros
                            self.global_vars.metro = 1

                        # Reading input files
                        mensagem_log1 = 'READING INPUT FILES...\n'
                        self.dlg_rain_interpl_run.te_rain_int.append(mensagem_log1)
                        arquivo_bacia = self.dlg_exc_rain.le_1_pg_ri.text()
                        self.leh_bacia(arquivo_bacia, 2)
                        self.leh_posto_pluv()
                        self.leh_arquivo_precipitacao()

                        # Atualiza progressbar
                        self.dlg_rain_interpl_run.progressBar.setValue(40)

                        # Processing and wrinting output files
                        mensagem_log1 = 'PROCESSING...\n'
                        self.dlg_rain_interpl_run.te_rain_int.append(mensagem_log1)
                        if interpol_map == 1:
                            self.rainfall_interpolation_map()
                            mensagem_log1 = 'WRITING OUTPUT FILES...\n'
                            self.dlg_rain_interpl_run.te_rain_int.append(mensagem_log1)
                            self.dlg_rain_interpl_run.progressBar.setValue(self.dlg_exc_rain.progressBar.value()+60)
                        else:    
                            self.rainfall_interpolation()
                            mensagem_log1 = 'WRITING OUTPUT FILES...\n'
                            self.dlg_rain_interpl_run.te_rain_int.append(mensagem_log1)
                            self.dlg_rain_interpl_run.progressBar.setValue(self.dlg_exc_rain.progressBar.value()+60)

                        # Finaliza execução do programa
                        self.dlg_rain_interpl_run.btn_ok_rain_int.clicked.connect(lambda: self.dlg_rain_interpl_run.close())
                        break

                else:
                    # O usuário selecionou a opção para cancelar
                    self.dlg_rain_interpl_run.close()
                break

    def run_flow_routing(self):
        '''Está função ativa a página de log e configura a ordem de execução das funções da rotina flow rounting'''
        # Ativiva a página de log e limpa as informações passadas no text_edit 
        mensagem_log1 = None
        self.dlg_flow_rout.tabWidget.setCurrentIndex(1)
        self.dlg_flow_rout.pg_log_f_rout.setEnabled(True)
        self.dlg_flow_rout.te_logg.clear()

        # Configura a progressbar
        self.dlg_flow_rout.progressBar.setRange(0, 100)
        self.dlg_flow_rout.progressBar.setValue(0)

        # Adiciona avisa acerca do tempo de processamento
        reply = QMessageBox.information(None, "Information", "This will take a few minutes (maybe hours)...", QMessageBox.Ok | QMessageBox.Cancel)
        
        # Apenas inicia o prpocessamento se o usuário estiver de acordo com o tempo de processamento
        if reply == QMessageBox.Ok:

            # Configura as informações do textEdit da referida página
            font = QFont()
            font.setPointSize(11)
            version_info = {
                "QGIS Version": '3.34.0-Prizren',
                "Qt Version": '5.15.3',
                "Python Version": '3.9.5',
                "GDAL Version": '3.8.0'}
            
            datatime_started = datetime.now().isoformat()
            mensagem_log1 = "The plugin was developed with:\n"
            mensagem_log1 += f"QGIS Version: {version_info['QGIS Version']}\n"
            mensagem_log1 += f"Qt Version: {version_info['Qt Version']}\n"
            mensagem_log1 += f"Python Version: {version_info['Python Version']}\n"
            mensagem_log1 += f"GDAL Version: {version_info['GDAL Version']}\n"
            mensagem_log1 += "--------------------------------------------------------\n"
            mensagem_log1 += f"Algorithm started at: {datatime_started}\n"
            mensagem_log1 += "--------------------------------------------------------\n"
            self.dlg_flow_rout.te_logg.append(mensagem_log1)
            # Cria condição de parada da execução: se o usuário clicar no botão cancel da página de log
            while True:
                # Método usado para permitir a iteração do usuário enquanto o programa está em execução
                QApplication.processEvents()
                self.dlg_flow_rout.btn_cancel_log.clicked.connect(lambda: self.cancel_log_page(self.dlg_flow_rout.te_logg,self.dlg_flow_rout.pg_par_f_rout, self.dlg_flow_rout.pg_log_f_rout))
                
                # Initial configuration
                if self.rdc_vars.unidaderef =='deg':
                    # Sistema está em graus, assumindo lat e long: será feita a projeção para metros
                    self.global_vars.metro = 0
                else:
                    # Sistema está em metros, não é preciso fazer a projeção para metros
                    self.global_vars.metro = 1

                # Reading input files
                mensagem_log1 = 'READING INPUT FILES...\n'
                self.dlg_flow_rout.te_logg.append(mensagem_log1)

                # Lê bacia hidrográfica
                arquivo_bacia = self.dlg_flow_rout.le_2_pg2.text()
                self.leh_bacia(arquivo_bacia, 3)
                self.numera_pix_bacia()
                arquivo_precipitacao = self.dlg_flow_rout.le_4_pg2.text()
                self.leh_precip_distribuida(arquivo_precipitacao)
                alfa = self.dlg_flow_rout.le_1_pg1.text()
                time_step = self.dlg_flow_rout.le_2_pg1.text()
                criterio_parada = self.dlg_flow_rout.le_4_pg1.text()
                self.leh_parametros(alfa, time_step,criterio_parada,2)
                
                # Atualiza progressbar
                self.dlg_flow_rout.progressBar.setValue(10)

                # Processing and wrinting output files
                mensagem_log1 ='PROCESSING...'
                self.dlg_flow_rout.te_logg.append(mensagem_log1)
                self.hidrograma_dlr()

                # Atualiza progressbar
                self.dlg_flow_rout.progressBar.setValue(self.dlg_flow_rout.progressBar.value() + 40)

                mensagem_log1 = 'WRITING OUTPUT FILES...'
                self.dlg_flow_rout.te_logg.append(mensagem_log1)

                # Codição para unidade da vazão de pico
                if self.dlg_flow_rout.ch_4_pg4.isChecked():
                    if self.dlg_flow_rout.rb_3_pg4.isChecked():
                        self.escreve_vazao_pico_pixel(1)
                        self.dlg_flow_rout.progressBar.setValue(self.dlg_flow_rout.progressBar.value() + 10)
                    elif self.dlg_flow_rout.rb_4_pg4.isChecked():
                        self.escreve_vazao_pico_pixel(0)
                        self.dlg_flow_rout.progressBar.setValue(self.dlg_flow_rout.progressBar.value() + 10)

                # Escolha dos arquivos de saída volume por píxel
                if self.dlg_flow_rout.ch_4_pg4.isChecked():
                    self.escreve_volume_gerado_pixel()
                if self.dlg_flow_rout.ch_6_pg4.isChecked():
                    self.escreve_hidrograma_dlr()
                self.dlg_flow_rout.progressBar.setValue(self.dlg_flow_rout.progressBar.value() + 20)

                # Configura lógica para adição dos arquivos selecionados
                if self.dlg_flow_rout.ch_10_pg4.isChecked() and self.fn_vazao_pico != '':
                    # Adiciona o arquivo selecionado: total excess rainfall
                    self.adiciona_layer(self.fn_vazao_pico)
                    mensagem_log1 = 'Added...\n'
                    self.dlg_flow_rout.te_logg.append(mensagem_log1)

                if self.dlg_flow_rout.ch_11_pg4.isChecked() and self.fn_vol != '':
                    # Adiciona o arquivo selecionado: total excess rainfall
                    self.adiciona_layer(self.fn_vol)
                    mensagem_log1 = 'Added...\n'
                    self.dlg_flow_rout.te_logg.append(mensagem_log1)
                self.dlg_flow_rout.progressBar.setValue(self.dlg_flow_rout.progressBar.value() + 20)

                if self.dlg_flow_rout.progressBar.value() != 100:
                    self.dlg_flow_rout.progressBar.setValue(100)
                # Finaliza operação do programa
                QMessageBox.information(None, "Information", "Operation completed successfully!", )
                break
        else:
            # O usuário selecionou a opção para cancelar
            self.dlg_flow_rout.tabWidget.setCurrentIndex(0)
            
    def flow_trave_time(self):
        '''Esta função ordena a execução das outras funções para determinação do tempo de concentração para os pixels da bacia hidrográfica'''
        # Atribuição das variáveis
        self.coef_c = self.dlg_flow_tt.le_16_pg1.text()
        self.coef_d = self.dlg_flow_tt.le_17_pg1.text()
        self.coef_c = self.dlg_flow_tt.le_18_pg1.text()
        self.coef_c = self.dlg_flow_tt.le_19_pg1.text()
        self.n_canal = self.dlg_flow_tt.le_14_pg1.text()
        self.comp_treco = self.dlg_flow_tt.le_15_pg1.text()
        self.sheet_flow = self.dlg_flow_tt.le_13_pg1.text()
        self.profundidade_resers = self.dlg_flow_tt.le_20_pg1.text()


    def run(self):
        """Esta é a função principal do plugin, todas as funcionalidades propostas anteriormente serão efetivadas na função run"""
        
        # Verifica se a interface já foi mostrada anteriormente
        if not hasattr(self, 'dlg_hidro_pixel') or not  self.dlg_hidro_pixel.isVisible():
            # Inicializa self.dlg_hidro_pixel apenas se ainda não estiver inicializado ou se estiver fechado
            self.dlg_hidro_pixel = HidroPixelDialog()
            # Mostra a interface gráfica
            self.dlg_hidro_pixel.show()
            QApplication.processEvents()

            # Desativa a página de log, só será ativada após clicar no botão run
            self.dlg_flow_tt.pg_log_ftt.setEnabled(False)
            # Cria as flags para configurar a leitura dos dados da tabela
            self.flag = 0
            self.flag_1 = 0

            # Configura botões do menu do hidropixel
            self.dlg_hidro_pixel.btn_flow_trav.clicked.connect(lambda: self.dlg_flow_tt.show())
            self.dlg_hidro_pixel.btn_exes_rain.clicked.connect(lambda: self.dlg_exc_rain.show())
            self.dlg_hidro_pixel.btn_flow_rout.clicked.connect(lambda: self.dlg_flow_rout.show())
            # self.dlg_hidro_pixel.btn_help.clicked.connect()

            '''Configura os botões da página da rotina do flow travel time'''
            self.dlg_flow_tt.btn_config.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg1_config))      
            self.dlg_flow_tt.btn_input_data.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg2_in_data))
            self.dlg_flow_tt.btn_data_va_tool.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg3_data_val_tool))
            self.dlg_flow_tt.btn_run.clicked.connect(lambda: self.dlg_flow_tt.pages_flow_tt.setCurrentWidget(self.dlg_flow_tt.pg4_run))

            # Configura os botões da página configuration: flow travel time
            self.dlg_flow_tt.tbtn_pg1_1.clicked.connect(lambda: self.carrega_work_folder(self.dlg_flow_tt.le_21_pg1))
            
            # Configura os botões da página input data : flow travel time
            self.dlg_flow_tt.tbtn_pg2_1.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_1_pg2))
            self.dlg_flow_tt.tbtn_pg2_2.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_2_pg2))
            self.dlg_flow_tt.tbtn_pg2_3.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.te_1_pg2, qtd = 2))
            self.dlg_flow_tt.tbtn_pg2_4.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_3_pg2))
            self.dlg_flow_tt.tbtn_pg2_5.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_4_pg2))
            self.dlg_flow_tt.tbtn_pg2_6.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_tt.le_5_pg2))

            # Configura os botões da página run page: flow travel time
            self.dlg_flow_tt.tbtn_pg4_1.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_1_pg4))
            self.dlg_flow_tt.tbtn_pg4_2.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_2_pg4))
            self.dlg_flow_tt.tbtn_pg4_3.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_3_pg4))
            self.dlg_flow_tt.tbtn_pg4_4.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_4_pg4))
            self.dlg_flow_tt.tbtn_pg4_5.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_5_pg4))
            self.dlg_flow_tt.tbtn_pg4_6.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_6_pg4))
            self.dlg_flow_tt.tbtn_pg4_7.clicked.connect(lambda: self.save_buttons(self.dlg_flow_tt.le_7_pg4))

            # configura botões de salvar e salvar para um arquivo: flow travel time
            self.dlg_flow_tt.btn_save_file_pg1.clicked.connect(lambda: self.save_to_file(1, 1))
            self.dlg_flow_tt.btn_save_file_pg2.clicked.connect(lambda: self.save_to_file(1, 2))
            self.dlg_flow_tt.btn_save_file_pg4.clicked.connect(lambda: self.save_to_file(1, 4))

            # Configura botão para ler informações de uma arquivo enviado : flow travel time
            self.dlg_flow_tt.btn_read_pg1.clicked.connect(lambda: self.read_from_file(1,1,self.dlg_flow_tt.le_21_pg1.text()))
            self.dlg_flow_tt.btn_read_pg2.clicked.connect(lambda: self.read_from_file(1,2,self.dlg_flow_tt.le_21_pg1.text()))
            self.dlg_flow_tt.btn_read_pg4.clicked.connect(lambda: self.read_from_file(1,4,self.dlg_flow_tt.le_21_pg1.text()))

            # Configura botões das tabelas : flow travel time
            self.dlg_flow_tt.btn_read_t1.clicked.connect(lambda: self.read_tb_from_file(self.dlg_flow_tt.tbw_1_pg2,self.dlg_flow_tt.le_7_pg2, 1))
            self.dlg_flow_tt.btn_read_t2.clicked.connect(lambda: self.read_tb_from_file(self.dlg_flow_tt.tbw_2_pg2,self.dlg_flow_tt.le_8_pg2,2))
            self.dlg_flow_tt.btn_save_file_t1.clicked.connect(lambda: self.save_table_to_file(1))
            self.dlg_flow_tt.btn_save_file_t2.clicked.connect(lambda: self.save_table_to_file(2))
            self.dlg_flow_tt.btn_add_row_1.clicked.connect(lambda: self.add_new_row(self.dlg_flow_tt.tbw_1_pg2))
            self.dlg_flow_tt.btn_add_row_2.clicked.connect(lambda: self.add_new_row(self.dlg_flow_tt.tbw_2_pg2))
            self.dlg_flow_tt.btn_del_row_1.clicked.connect(lambda: self.delete_row(self.dlg_flow_tt.tbw_1_pg2))
            self.dlg_flow_tt.btn_del_row_2.clicked.connect(lambda: self.delete_row(self.dlg_flow_tt.tbw_2_pg2))
            
            # Configura botões de salvar das diferentes páginas : flow travel time
            self.dlg_flow_tt.btn_save_pg1.clicked.connect(lambda: self.save())
            self.dlg_flow_tt.btn_save_pg2.clicked.connect(lambda: self.save())
            self.dlg_flow_tt.btn_save_pg4.clicked.connect(lambda: self.save())

            # Configura os botões de limpeza das variáveis : flow travel time
            self.dlg_flow_tt.btn_clear_1.clicked.connect(lambda: self.clear_table(self.dlg_flow_tt.tbw_1_pg2,self.dlg_flow_tt.le_7_pg2))
            self.dlg_flow_tt.btn_clear_2.clicked.connect(lambda: self.clear_table(self.dlg_flow_tt.tbw_2_pg2,self.dlg_flow_tt.le_8_pg2))

            # configura botões da página run : flow travel time
            self.dlg_flow_tt.btn_close_pg4.clicked.connect(lambda: self.close_gui(1))
            
            # Configura run button : flow travel time
            self.dlg_flow_tt.btn_run_2.clicked.connect(lambda: self.run_flow_tt())

            # Configura botões página de log: flow travel time
            self.dlg_flow_tt.btn_close_log.clicked.connect(lambda: self.close_gui(1))

            '''Configura os botões da página da rotina excess rainfall'''

            # Configura botões gerais das páginas da rotina excess rainfall
            self.dlg_exc_rain.btn_config.clicked.connect(lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg1_config))      
            self.dlg_exc_rain.btn_rain_int.clicked.connect(lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg2_rain_int))      
            self.dlg_exc_rain.btn_input_data.clicked.connect(lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg3_in_data))
            self.dlg_exc_rain.btn_data_va_tool.clicked.connect(lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg4_data_val_tool))
            self.dlg_exc_rain.btn_run.clicked.connect(lambda: self.dlg_exc_rain.pages_exc_rain.setCurrentWidget(self.dlg_exc_rain.pg5_run))

            # Configura botões da página de configuration: excess rainfall
            self.dlg_exc_rain.tbtn_pg1_1.clicked.connect(lambda: self.carrega_work_folder(self.dlg_exc_rain.le_3_pg1))

            # Condição: usuário escolhe precipitação média (na bacia) ou destribuida (na bacia)
            self.dlg_exc_rain.le_4_pg2.setEnabled(False)
            self.dlg_exc_rain.label_32.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_4.setEnabled(False)
            self.dlg_exc_rain.label_36.setEnabled(False)
            self.dlg_exc_rain.le_3_pg2.setEnabled(False)
            self.dlg_exc_rain.label_31.setEnabled(False)
            self.dlg_exc_rain.tbtn_pg2_3.setEnabled(False)
            self.dlg_exc_rain.label_35.setEnabled(False)

            # Se o usuário escolher a opção para chuva média
            self.dlg_exc_rain.rb_1_pg1.toggled.connect(lambda: self.rain_def_condition(1))
            self.dlg_exc_rain.rb_2_pg1.toggled.connect(lambda: self.rain_def_condition(2))

            # Configura os botões da página input data : excess rainfall
            self.dlg_exc_rain.tbtn_pg2_1.clicked.connect(lambda: self.carrega_arquivos(self.dlg_exc_rain.le_1_pg2))
            self.dlg_exc_rain.tbtn_pg2_2.clicked.connect(lambda: self.carrega_arquivos(self.dlg_exc_rain.le_2_pg2))
            self.dlg_exc_rain.tbtn_pg2_3.clicked.connect(lambda: self.carrega_arquivos(self.dlg_exc_rain.le_3_pg2))
            self.dlg_exc_rain.tbtn_pg2_4.clicked.connect(lambda: self.carrega_arquivos(self.dlg_exc_rain.le_4_pg2,file_type = 'text'))
            
            # configura botões de salvar e salvar para um arquivo: excess rainfall
            self.dlg_exc_rain.btn_save_file_pg1.clicked.connect(lambda: self.save_to_file(2, 1))
            self.dlg_exc_rain.btn_save_file_pg_ri.clicked.connect(lambda: self.save_to_file(2, 2))
            self.dlg_exc_rain.btn_save_file_pg2.clicked.connect(lambda: self.save_to_file(2, 2))
            self.dlg_exc_rain.btn_save_file_pg4.clicked.connect(lambda: self.save_to_file(2, 4))

            # Configura botão para ler informações de uma arquivo enviado : excess rainfall
            self.dlg_exc_rain.btn_read_pg1.clicked.connect(lambda: self.read_from_file(2,1,self.dlg_exc_rain.le_3_pg1.text()))
            self.dlg_exc_rain.btn_read_pg_ri.clicked.connect(lambda: self.read_from_file(2,2,self.dlg_exc_rain.le_3_pg1.text()))
            self.dlg_exc_rain.btn_read_pg2.clicked.connect(lambda: self.read_from_file(2,3,self.dlg_exc_rain.le_3_pg1.text()))
            self.dlg_exc_rain.btn_read_pg4.clicked.connect(lambda: self.read_from_file(2,4,self.dlg_exc_rain.le_3_pg1.text()))

            # Configura botões de salvar das diferentes páginas : excess rainfall
            self.dlg_exc_rain.btn_save_pg1.clicked.connect(lambda: self.save())
            self.dlg_exc_rain.btn_save_pg2.clicked.connect(lambda: self.save())
            self.dlg_exc_rain.btn_save_pg4.clicked.connect(lambda: self.save())
            
            # Configura os botões da página run page: excess rainfall
            self.dlg_exc_rain.tbtn_pg4_1.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_1_pg4))
            self.dlg_exc_rain.tbtn_pg4_2.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_2_pg4))
            self.dlg_exc_rain.tbtn_pg4_3.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_3_pg4))
            self.dlg_exc_rain.tbtn_pg4_4.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_4_pg4))
            self.dlg_exc_rain.tbtn_pg4_5.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_5_pg4))
            self.dlg_exc_rain.tbtn_pg4_6.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_6_pg4,file_type = 'text'))
            
            # configura botões da página run : excess rainfall
            self.dlg_exc_rain.btn_run_2.clicked.connect(lambda: self.run_exc_rain())
            self.dlg_exc_rain.btn_close_pg4.clicked.connect(lambda: self.close_gui(2))
            
            # Configura botões da página rainfall interpolation
            self.dlg_exc_rain.tbtn_pg_r_1.clicked.connect(lambda: self.carrega_arquivos(self.dlg_exc_rain.le_1_pg_ri))
            self.dlg_exc_rain.tbtn_pg_r_2.clicked.connect(lambda: self.carrega_arquivos(self.dlg_exc_rain.le_2_pg_ri,file_type = 'text'))
            self.dlg_exc_rain.tbtn_pg_r_3.clicked.connect(lambda: self.carrega_arquivos(self.dlg_exc_rain.le_3_pg_ri,file_type = 'text'))
            self.dlg_exc_rain.tbtn_pg_r_4.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_4_pg_ri,file_type = 'text'))
            self.dlg_exc_rain.tbtn_pg_r_5.clicked.connect(lambda: self.save_buttons(self.dlg_exc_rain.le_5_pg_ri))
            self.dlg_exc_rain.btn_save_1_pg_ri.clicked.connect(lambda: self.run_rainfall_interpolation(0))
            self.dlg_exc_rain.btn_save_2_pg_ri.clicked.connect(lambda: self.run_rainfall_interpolation(1))


            '''Configura os botões da página da rotina flow routing'''
            self.dlg_flow_rout.btn_config.clicked.connect(lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg1_config))      
            self.dlg_flow_rout.btn_input_data.clicked.connect(lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg2_in_data))
            self.dlg_flow_rout.btn_data_va_tool.clicked.connect(lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg3_data_val_tool))
            self.dlg_flow_rout.btn_run.clicked.connect(lambda: self.dlg_flow_rout.pages_flow_rout.setCurrentWidget(self.dlg_flow_rout.pg4_run))    

            # Configura botões da página de configuration: flow routing
            self.dlg_flow_rout.tbtn_pg1_1.clicked.connect(lambda: self.carrega_work_folder(self.dlg_flow_rout.le_3_pg1))

            # Configura os botões da página input data : flow routing
            self.dlg_flow_rout.tbtn_pg2_1.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_rout.le_1_pg2))
            self.dlg_flow_rout.tbtn_pg2_2.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_rout.le_2_pg2))
            self.dlg_flow_rout.tbtn_pg2_3.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_rout.le_3_pg2))
            self.dlg_flow_rout.tbtn_pg2_4.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_rout.le_4_pg2,file_type='text'))
            self.dlg_flow_rout.tbtn_pg2_5.clicked.connect(lambda: self.carrega_arquivos(self.dlg_flow_rout.le_5_pg2))

            # configura botões de salvar e salvar para um arquivo: flow travel time
            self.dlg_flow_rout.btn_save_file_pg1.clicked.connect(lambda: self.save_to_file(3, 1))
            self.dlg_flow_rout.btn_save_file_pg2.clicked.connect(lambda: self.save_to_file(3, 2))
            self.dlg_flow_rout.btn_save_file_pg4.clicked.connect(lambda: self.save_to_file(3, 4))

            # Configura botão para ler informações de uma arquivo enviado : flow routing
            self.dlg_flow_rout.btn_read_pg1.clicked.connect(lambda: self.read_from_file(3,1,self.dlg_flow_rout.le_3_pg1.text()))
            self.dlg_flow_rout.btn_read_pg2.clicked.connect(lambda: self.read_from_file(3,2,self.dlg_flow_rout.le_3_pg1.text()))
            self.dlg_flow_rout.btn_read_pg4.clicked.connect(lambda: self.read_from_file(3,4,self.dlg_flow_rout.le_3_pg1.text()))

            # Configura botões de salvar das diferentes páginas : flow routing
            self.dlg_flow_rout.btn_save_pg1.clicked.connect(lambda: self.save())
            self.dlg_flow_rout.btn_save_pg2.clicked.connect(lambda: self.save())
            self.dlg_flow_rout.btn_save_pg4.clicked.connect(lambda: self.save())

            # Configura os botões da página run page: flow routing
            self.dlg_flow_rout.tbtn_pg4_1.clicked.connect(lambda: self.save_buttons(self.dlg_flow_rout.le_1_pg4))
            self.dlg_flow_rout.tbtn_pg4_2.clicked.connect(lambda: self.save_buttons(self.dlg_flow_rout.le_2_pg4))
            self.dlg_flow_rout.tbtn_pg4_3.clicked.connect(lambda: self.save_buttons(self.dlg_flow_rout.le_3_pg4))
            self.dlg_flow_rout.tbtn_pg4_4.clicked.connect(lambda: self.save_buttons(self.dlg_flow_rout.le_4_pg4))
            self.dlg_flow_rout.tbtn_pg4_5.clicked.connect(lambda: self.save_buttons(self.dlg_flow_rout.le_5_pg4))
            self.dlg_flow_rout.tbtn_pg4_6.clicked.connect(lambda: self.save_buttons(self.dlg_flow_rout.le_6_pg4, file_type = 'text'))            
            
            # configura botões da página run : flow routing
            self.dlg_flow_rout.btn_run_2.clicked.connect(lambda: self.run_flow_routing())
            self.dlg_flow_rout.btn_close_pg4.clicked.connect(lambda: self.close_gui(3))

            '''Menu Hidropixel Plugin'''
            # Run the dialog event loop
            self.dlg_hidro_pixel.exec_()
            self.close_gui(1)
            self.close_gui(2)
            self.close_gui(3)